/*
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
 * Autogenerated by Loqui.  Do not manually change.
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
*/
#region Usings
using Loqui;
using Loqui.Interfaces;
using Loqui.Internal;
using Mutagen.Bethesda.Binary;
using Mutagen.Bethesda.Fallout4;
using Mutagen.Bethesda.Fallout4.Internals;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Plugins.Aspects;
using Mutagen.Bethesda.Plugins.Binary.Overlay;
using Mutagen.Bethesda.Plugins.Binary.Streams;
using Mutagen.Bethesda.Plugins.Binary.Translations;
using Mutagen.Bethesda.Plugins.Cache;
using Mutagen.Bethesda.Plugins.Exceptions;
using Mutagen.Bethesda.Plugins.Internals;
using Mutagen.Bethesda.Plugins.Records;
using Mutagen.Bethesda.Plugins.Records.Internals;
using Mutagen.Bethesda.Plugins.Records.Mapping;
using Mutagen.Bethesda.Plugins.RecordTypeMapping;
using Mutagen.Bethesda.Plugins.Utility;
using Mutagen.Bethesda.Strings;
using Mutagen.Bethesda.Translations.Binary;
using Noggog;
using Noggog.StructuredStrings;
using Noggog.StructuredStrings.CSharp;
using RecordTypeInts = Mutagen.Bethesda.Fallout4.Internals.RecordTypeInts;
using RecordTypes = Mutagen.Bethesda.Fallout4.Internals.RecordTypes;
using System.Buffers.Binary;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Reactive.Disposables;
using System.Reactive.Linq;
#endregion

#nullable enable
namespace Mutagen.Bethesda.Fallout4
{
    #region Class
    public partial class Weapon :
        Fallout4MajorRecord,
        IEquatable<IWeaponGetter>,
        ILoquiObjectSetter<Weapon>,
        IWeaponInternal
    {
        #region Ctor
        protected Weapon()
        {
            CustomCtor();
        }
        partial void CustomCtor();
        #endregion

        #region VirtualMachineAdapter
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private VirtualMachineAdapter? _VirtualMachineAdapter;
        /// <summary>
        /// Aspects: IScripted
        /// </summary>
        public VirtualMachineAdapter? VirtualMachineAdapter
        {
            get => _VirtualMachineAdapter;
            set => _VirtualMachineAdapter = value;
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IVirtualMachineAdapterGetter? IWeaponGetter.VirtualMachineAdapter => this.VirtualMachineAdapter;
        #region Aspects
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IVirtualMachineAdapterGetter? IScriptedGetter.VirtualMachineAdapter => this.VirtualMachineAdapter;
        #endregion
        #endregion
        #region ObjectBounds
        /// <summary>
        /// Aspects: IObjectBounded
        /// </summary>
        public ObjectBounds ObjectBounds { get; set; } = new ObjectBounds();
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IObjectBoundsGetter IWeaponGetter.ObjectBounds => ObjectBounds;
        #region Aspects
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ObjectBounds? IObjectBoundedOptional.ObjectBounds
        {
            get => this.ObjectBounds;
            set => this.ObjectBounds = value ?? new ObjectBounds();
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IObjectBoundsGetter IObjectBoundedGetter.ObjectBounds => this.ObjectBounds;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IObjectBoundsGetter? IObjectBoundedOptionalGetter.ObjectBounds => this.ObjectBounds;
        #endregion
        #endregion
        #region PreviewTransform
        private readonly IFormLinkNullable<ITransformGetter> _PreviewTransform = new FormLinkNullable<ITransformGetter>();
        public IFormLinkNullable<ITransformGetter> PreviewTransform
        {
            get => _PreviewTransform;
            set => _PreviewTransform.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkNullableGetter<ITransformGetter> IWeaponGetter.PreviewTransform => this.PreviewTransform;
        #endregion
        #region AnimationSound
        private readonly IFormLinkNullable<IAnimationSoundTagSetGetter> _AnimationSound = new FormLinkNullable<IAnimationSoundTagSetGetter>();
        public IFormLinkNullable<IAnimationSoundTagSetGetter> AnimationSound
        {
            get => _AnimationSound;
            set => _AnimationSound.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkNullableGetter<IAnimationSoundTagSetGetter> IWeaponGetter.AnimationSound => this.AnimationSound;
        #endregion
        #region Name
        /// <summary>
        /// Aspects: INamed, INamedRequired, ITranslatedNamed, ITranslatedNamedRequired
        /// </summary>
        public TranslatedString? Name { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ITranslatedStringGetter? IWeaponGetter.Name => this.Name;
        #region Aspects
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        string INamedRequiredGetter.Name => this.Name?.String ?? string.Empty;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        string? INamedGetter.Name => this.Name?.String;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ITranslatedStringGetter? ITranslatedNamedGetter.Name => this.Name;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ITranslatedStringGetter ITranslatedNamedRequiredGetter.Name => this.Name ?? string.Empty;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        string? INamed.Name
        {
            get => this.Name?.String;
            set => this.Name = value;
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        string INamedRequired.Name
        {
            get => this.Name?.String ?? string.Empty;
            set => this.Name = value;
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        TranslatedString ITranslatedNamedRequired.Name
        {
            get => this.Name ?? string.Empty;
            set => this.Name = value;
        }
        #endregion
        #endregion
        #region Model
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private Model? _Model;
        /// <summary>
        /// Aspects: IModeled
        /// </summary>
        public Model? Model
        {
            get => _Model;
            set => _Model = value;
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IModelGetter? IWeaponGetter.Model => this.Model;
        #region Aspects
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IModelGetter? IModeledGetter.Model => this.Model;
        #endregion
        #endregion
        #region Icons
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private Icons? _Icons;
        /// <summary>
        /// Aspects: IHasIcons
        /// </summary>
        public Icons? Icons
        {
            get => _Icons;
            set => _Icons = value;
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IIconsGetter? IWeaponGetter.Icons => this.Icons;
        #region Aspects
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IIconsGetter? IHasIconsGetter.Icons => this.Icons;
        #endregion
        #endregion
        #region ObjectEffect
        private readonly IFormLinkNullable<IEffectRecordGetter> _ObjectEffect = new FormLinkNullable<IEffectRecordGetter>();
        public IFormLinkNullable<IEffectRecordGetter> ObjectEffect
        {
            get => _ObjectEffect;
            set => _ObjectEffect.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkNullableGetter<IEffectRecordGetter> IWeaponGetter.ObjectEffect => this.ObjectEffect;
        #endregion
        #region EnchantmentAmount
        public UInt16? EnchantmentAmount { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        UInt16? IWeaponGetter.EnchantmentAmount => this.EnchantmentAmount;
        #endregion
        #region Destructible
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private Destructible? _Destructible;
        public Destructible? Destructible
        {
            get => _Destructible;
            set => _Destructible = value;
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IDestructibleGetter? IWeaponGetter.Destructible => this.Destructible;
        #endregion
        #region EquipmentType
        private readonly IFormLinkNullable<IEquipTypeGetter> _EquipmentType = new FormLinkNullable<IEquipTypeGetter>();
        public IFormLinkNullable<IEquipTypeGetter> EquipmentType
        {
            get => _EquipmentType;
            set => _EquipmentType.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkNullableGetter<IEquipTypeGetter> IWeaponGetter.EquipmentType => this.EquipmentType;
        #endregion
        #region BlockBashImpactDataSet
        private readonly IFormLinkNullable<IImpactDataSetGetter> _BlockBashImpactDataSet = new FormLinkNullable<IImpactDataSetGetter>();
        public IFormLinkNullable<IImpactDataSetGetter> BlockBashImpactDataSet
        {
            get => _BlockBashImpactDataSet;
            set => _BlockBashImpactDataSet.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkNullableGetter<IImpactDataSetGetter> IWeaponGetter.BlockBashImpactDataSet => this.BlockBashImpactDataSet;
        #endregion
        #region AlternateBlockMaterial
        private readonly IFormLinkNullable<IMaterialTypeGetter> _AlternateBlockMaterial = new FormLinkNullable<IMaterialTypeGetter>();
        public IFormLinkNullable<IMaterialTypeGetter> AlternateBlockMaterial
        {
            get => _AlternateBlockMaterial;
            set => _AlternateBlockMaterial.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkNullableGetter<IMaterialTypeGetter> IWeaponGetter.AlternateBlockMaterial => this.AlternateBlockMaterial;
        #endregion
        #region PickUpSound
        private readonly IFormLinkNullable<ISoundDescriptorGetter> _PickUpSound = new FormLinkNullable<ISoundDescriptorGetter>();
        public IFormLinkNullable<ISoundDescriptorGetter> PickUpSound
        {
            get => _PickUpSound;
            set => _PickUpSound.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkNullableGetter<ISoundDescriptorGetter> IWeaponGetter.PickUpSound => this.PickUpSound;
        #endregion
        #region PutDownSound
        private readonly IFormLinkNullable<ISoundDescriptorGetter> _PutDownSound = new FormLinkNullable<ISoundDescriptorGetter>();
        public IFormLinkNullable<ISoundDescriptorGetter> PutDownSound
        {
            get => _PutDownSound;
            set => _PutDownSound.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkNullableGetter<ISoundDescriptorGetter> IWeaponGetter.PutDownSound => this.PutDownSound;
        #endregion
        #region Keywords
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private ExtendedList<IFormLinkGetter<IKeywordGetter>>? _Keywords;
        /// <summary>
        /// Aspects: IKeyworded&lt;IKeywordGetter&gt;
        /// </summary>
        public ExtendedList<IFormLinkGetter<IKeywordGetter>>? Keywords
        {
            get => this._Keywords;
            set => this._Keywords = value;
        }
        #region Interface Members
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IReadOnlyList<IFormLinkGetter<IKeywordGetter>>? IWeaponGetter.Keywords => _Keywords;
        #endregion

        #region Aspects
        IReadOnlyList<IFormLinkGetter<IKeywordGetter>>? IKeywordedGetter<IKeywordGetter>.Keywords => this.Keywords;
        IReadOnlyList<IFormLinkGetter<IKeywordCommonGetter>>? IKeywordedGetter.Keywords => this.Keywords;
        #endregion
        #endregion
        #region Description
        public TranslatedString? Description { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ITranslatedStringGetter? IWeaponGetter.Description => this.Description;
        #endregion
        #region InstanceNaming
        private readonly IFormLinkNullable<IInstanceNamingRuleGetter> _InstanceNaming = new FormLinkNullable<IInstanceNamingRuleGetter>();
        public IFormLinkNullable<IInstanceNamingRuleGetter> InstanceNaming
        {
            get => _InstanceNaming;
            set => _InstanceNaming.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkNullableGetter<IInstanceNamingRuleGetter> IWeaponGetter.InstanceNaming => this.InstanceNaming;
        #endregion
        #region AttachParentSlots
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private ExtendedList<IFormLinkGetter<IKeywordGetter>>? _AttachParentSlots;
        public ExtendedList<IFormLinkGetter<IKeywordGetter>>? AttachParentSlots
        {
            get => this._AttachParentSlots;
            set => this._AttachParentSlots = value;
        }
        #region Interface Members
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IReadOnlyList<IFormLinkGetter<IKeywordGetter>>? IWeaponGetter.AttachParentSlots => _AttachParentSlots;
        #endregion

        #endregion
        #region ObjectTemplates
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private ExtendedList<ObjectTemplate<Weapon.Property>>? _ObjectTemplates;
        public ExtendedList<ObjectTemplate<Weapon.Property>>? ObjectTemplates
        {
            get => this._ObjectTemplates;
            set => this._ObjectTemplates = value;
        }
        #region Interface Members
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IReadOnlyList<IObjectTemplateGetter<Weapon.Property>>? IWeaponGetter.ObjectTemplates => _ObjectTemplates;
        #endregion

        #endregion
        #region EmbeddedWeaponMod
        private readonly IFormLinkNullable<IObjectModificationGetter> _EmbeddedWeaponMod = new FormLinkNullable<IObjectModificationGetter>();
        public IFormLinkNullable<IObjectModificationGetter> EmbeddedWeaponMod
        {
            get => _EmbeddedWeaponMod;
            set => _EmbeddedWeaponMod.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkNullableGetter<IObjectModificationGetter> IWeaponGetter.EmbeddedWeaponMod => this.EmbeddedWeaponMod;
        #endregion
        #region FirstPersonModel
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private Model? _FirstPersonModel;
        public Model? FirstPersonModel
        {
            get => _FirstPersonModel;
            set => _FirstPersonModel = value;
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IModelGetter? IWeaponGetter.FirstPersonModel => this.FirstPersonModel;
        #endregion
        #region FirstPersonColorRemappingIndex
        public Single? FirstPersonColorRemappingIndex { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Single? IWeaponGetter.FirstPersonColorRemappingIndex => this.FirstPersonColorRemappingIndex;
        #endregion
        #region MO4F
        public Int32? MO4F { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Int32? IWeaponGetter.MO4F => this.MO4F;
        #endregion
        #region Ammo
        private readonly IFormLink<IAmmunitionGetter> _Ammo = new FormLink<IAmmunitionGetter>();
        public IFormLink<IAmmunitionGetter> Ammo
        {
            get => _Ammo;
            set => _Ammo.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkGetter<IAmmunitionGetter> IWeaponGetter.Ammo => this.Ammo;
        #endregion
        #region Speed
        public Single Speed { get; set; } = default;
        #endregion
        #region ReloadSpeed
        public Single ReloadSpeed { get; set; } = default;
        #endregion
        #region Reach
        public Single Reach { get; set; } = default;
        #endregion
        #region MinRange
        public Single MinRange { get; set; } = default;
        #endregion
        #region MaxRange
        public Single MaxRange { get; set; } = default;
        #endregion
        #region AttackDelay
        public Single AttackDelay { get; set; } = default;
        #endregion
        #region Unknown
        public Single Unknown { get; set; } = default;
        #endregion
        #region DamageOutOfRangeMult
        public Single DamageOutOfRangeMult { get; set; } = default;
        #endregion
        #region OnHit
        public Weapon.HitBehavior OnHit { get; set; } = default;
        #endregion
        #region Skill
        private readonly IFormLink<IActorValueInformationGetter> _Skill = new FormLink<IActorValueInformationGetter>();
        public IFormLink<IActorValueInformationGetter> Skill
        {
            get => _Skill;
            set => _Skill.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkGetter<IActorValueInformationGetter> IWeaponGetter.Skill => this.Skill;
        #endregion
        #region Resist
        private readonly IFormLink<IActorValueInformationGetter> _Resist = new FormLink<IActorValueInformationGetter>();
        public IFormLink<IActorValueInformationGetter> Resist
        {
            get => _Resist;
            set => _Resist.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkGetter<IActorValueInformationGetter> IWeaponGetter.Resist => this.Resist;
        #endregion
        #region Flags
        public Weapon.Flag Flags { get; set; } = default;
        #endregion
        #region Capacity
        public UInt16 Capacity { get; set; } = default;
        #endregion
        #region AnimationType
        public Weapon.AnimationTypes AnimationType { get; set; } = default;
        #endregion
        #region SecondaryDamage
        public Single SecondaryDamage { get; set; } = default;
        #endregion
        #region Weight
        public Single Weight { get; set; } = default;
        #endregion
        #region Value
        public UInt32 Value { get; set; } = default;
        #endregion
        #region BaseDamage
        public UInt16 BaseDamage { get; set; } = default;
        #endregion
        #region SoundLevel
        public SoundLevel SoundLevel { get; set; } = default;
        #endregion
        #region AttackSound
        private readonly IFormLink<ISoundDescriptorGetter> _AttackSound = new FormLink<ISoundDescriptorGetter>();
        public IFormLink<ISoundDescriptorGetter> AttackSound
        {
            get => _AttackSound;
            set => _AttackSound.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkGetter<ISoundDescriptorGetter> IWeaponGetter.AttackSound => this.AttackSound;
        #endregion
        #region Attack2dSound
        private readonly IFormLink<ISoundDescriptorGetter> _Attack2dSound = new FormLink<ISoundDescriptorGetter>();
        public IFormLink<ISoundDescriptorGetter> Attack2dSound
        {
            get => _Attack2dSound;
            set => _Attack2dSound.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkGetter<ISoundDescriptorGetter> IWeaponGetter.Attack2dSound => this.Attack2dSound;
        #endregion
        #region AttackLoopSound
        private readonly IFormLink<ISoundDescriptorGetter> _AttackLoopSound = new FormLink<ISoundDescriptorGetter>();
        public IFormLink<ISoundDescriptorGetter> AttackLoopSound
        {
            get => _AttackLoopSound;
            set => _AttackLoopSound.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkGetter<ISoundDescriptorGetter> IWeaponGetter.AttackLoopSound => this.AttackLoopSound;
        #endregion
        #region AttackFailSound
        private readonly IFormLink<ISoundDescriptorGetter> _AttackFailSound = new FormLink<ISoundDescriptorGetter>();
        public IFormLink<ISoundDescriptorGetter> AttackFailSound
        {
            get => _AttackFailSound;
            set => _AttackFailSound.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkGetter<ISoundDescriptorGetter> IWeaponGetter.AttackFailSound => this.AttackFailSound;
        #endregion
        #region IdleSound
        private readonly IFormLink<ISoundDescriptorGetter> _IdleSound = new FormLink<ISoundDescriptorGetter>();
        public IFormLink<ISoundDescriptorGetter> IdleSound
        {
            get => _IdleSound;
            set => _IdleSound.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkGetter<ISoundDescriptorGetter> IWeaponGetter.IdleSound => this.IdleSound;
        #endregion
        #region EquipSound
        private readonly IFormLink<ISoundDescriptorGetter> _EquipSound = new FormLink<ISoundDescriptorGetter>();
        public IFormLink<ISoundDescriptorGetter> EquipSound
        {
            get => _EquipSound;
            set => _EquipSound.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkGetter<ISoundDescriptorGetter> IWeaponGetter.EquipSound => this.EquipSound;
        #endregion
        #region UnequipSound
        private readonly IFormLink<ISoundDescriptorGetter> _UnequipSound = new FormLink<ISoundDescriptorGetter>();
        public IFormLink<ISoundDescriptorGetter> UnequipSound
        {
            get => _UnequipSound;
            set => _UnequipSound.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkGetter<ISoundDescriptorGetter> IWeaponGetter.UnequipSound => this.UnequipSound;
        #endregion
        #region FastEquipSound
        private readonly IFormLink<ISoundDescriptorGetter> _FastEquipSound = new FormLink<ISoundDescriptorGetter>();
        public IFormLink<ISoundDescriptorGetter> FastEquipSound
        {
            get => _FastEquipSound;
            set => _FastEquipSound.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkGetter<ISoundDescriptorGetter> IWeaponGetter.FastEquipSound => this.FastEquipSound;
        #endregion
        #region AccuracyBonus
        public Byte AccuracyBonus { get; set; } = default;
        #endregion
        #region AnimationAttackSeconds
        public Single AnimationAttackSeconds { get; set; } = default;
        #endregion
        #region Unknown2
        public UInt16 Unknown2 { get; set; } = default;
        #endregion
        #region ActionPointCost
        public Single ActionPointCost { get; set; } = default;
        #endregion
        #region FullPowerSeconds
        public Single FullPowerSeconds { get; set; } = default;
        #endregion
        #region MinPowerPerShot
        public Single MinPowerPerShot { get; set; } = default;
        #endregion
        #region Stagger
        public Stagger Stagger { get; set; } = default;
        #endregion
        #region Unknown3
        public Int32 Unknown3 { get; set; } = default;
        #endregion
        #region ExtraData
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private WeaponExtraData? _ExtraData;
        public WeaponExtraData? ExtraData
        {
            get => _ExtraData;
            set => _ExtraData = value;
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IWeaponExtraDataGetter? IWeaponGetter.ExtraData => this.ExtraData;
        #endregion
        #region CritDamageMult
        public Single CritDamageMult { get; set; } = default;
        #endregion
        #region CritChargeBonus
        public Single CritChargeBonus { get; set; } = default;
        #endregion
        #region CritEffect
        private readonly IFormLink<ISpellGetter> _CritEffect = new FormLink<ISpellGetter>();
        public IFormLink<ISpellGetter> CritEffect
        {
            get => _CritEffect;
            set => _CritEffect.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkGetter<ISpellGetter> IWeaponGetter.CritEffect => this.CritEffect;
        #endregion
        #region ImpactDataSet
        private readonly IFormLinkNullable<IImpactDataSetGetter> _ImpactDataSet = new FormLinkNullable<IImpactDataSetGetter>();
        public IFormLinkNullable<IImpactDataSetGetter> ImpactDataSet
        {
            get => _ImpactDataSet;
            set => _ImpactDataSet.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkNullableGetter<IImpactDataSetGetter> IWeaponGetter.ImpactDataSet => this.ImpactDataSet;
        #endregion
        #region NpcAddAmmoList
        private readonly IFormLinkNullable<ILeveledItemGetter> _NpcAddAmmoList = new FormLinkNullable<ILeveledItemGetter>();
        public IFormLinkNullable<ILeveledItemGetter> NpcAddAmmoList
        {
            get => _NpcAddAmmoList;
            set => _NpcAddAmmoList.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkNullableGetter<ILeveledItemGetter> IWeaponGetter.NpcAddAmmoList => this.NpcAddAmmoList;
        #endregion
        #region AimModel
        private readonly IFormLinkNullable<IAimModelGetter> _AimModel = new FormLinkNullable<IAimModelGetter>();
        public IFormLinkNullable<IAimModelGetter> AimModel
        {
            get => _AimModel;
            set => _AimModel.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkNullableGetter<IAimModelGetter> IWeaponGetter.AimModel => this.AimModel;
        #endregion
        #region Zoom
        private readonly IFormLinkNullable<IZoomGetter> _Zoom = new FormLinkNullable<IZoomGetter>();
        public IFormLinkNullable<IZoomGetter> Zoom
        {
            get => _Zoom;
            set => _Zoom.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkNullableGetter<IZoomGetter> IWeaponGetter.Zoom => this.Zoom;
        #endregion
        #region Template
        private readonly IFormLinkNullable<IWeaponGetter> _Template = new FormLinkNullable<IWeaponGetter>();
        public IFormLinkNullable<IWeaponGetter> Template
        {
            get => _Template;
            set => _Template.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkNullableGetter<IWeaponGetter> IWeaponGetter.Template => this.Template;
        #endregion
        #region DamageType
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private WeaponDamageType? _DamageType;
        public WeaponDamageType? DamageType
        {
            get => _DamageType;
            set => _DamageType = value;
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IWeaponDamageTypeGetter? IWeaponGetter.DamageType => this.DamageType;
        #endregion
        #region Filter
        public String? Filter { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        String? IWeaponGetter.Filter => this.Filter;
        #endregion
        #region MeleeSpeed
        public Weapon.MeleeSpeeds? MeleeSpeed { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Weapon.MeleeSpeeds? IWeaponGetter.MeleeSpeed => this.MeleeSpeed;
        #endregion
        #region DNAMDataTypeState
        public Weapon.DNAMDataType DNAMDataTypeState { get; set; } = default;
        #endregion
        #region CRDTDataTypeState
        public Weapon.CRDTDataType CRDTDataTypeState { get; set; } = default;
        #endregion

        #region To String

        public override void ToString(
            StructuredStringBuilder sb,
            string? name = null)
        {
            WeaponMixIn.ToString(
                item: this,
                sb: sb,
                name: name);
        }

        #endregion

        #region Mask
        public new class Mask<TItem> :
            Fallout4MajorRecord.Mask<TItem>,
            IEquatable<Mask<TItem>>,
            IMask<TItem>
        {
            #region Ctors
            public Mask(TItem initialValue)
            : base(initialValue)
            {
                this.VirtualMachineAdapter = new MaskItem<TItem, VirtualMachineAdapter.Mask<TItem>?>(initialValue, new VirtualMachineAdapter.Mask<TItem>(initialValue));
                this.ObjectBounds = new MaskItem<TItem, ObjectBounds.Mask<TItem>?>(initialValue, new ObjectBounds.Mask<TItem>(initialValue));
                this.PreviewTransform = initialValue;
                this.AnimationSound = initialValue;
                this.Name = initialValue;
                this.Model = new MaskItem<TItem, Model.Mask<TItem>?>(initialValue, new Model.Mask<TItem>(initialValue));
                this.Icons = new MaskItem<TItem, Icons.Mask<TItem>?>(initialValue, new Icons.Mask<TItem>(initialValue));
                this.ObjectEffect = initialValue;
                this.EnchantmentAmount = initialValue;
                this.Destructible = new MaskItem<TItem, Destructible.Mask<TItem>?>(initialValue, new Destructible.Mask<TItem>(initialValue));
                this.EquipmentType = initialValue;
                this.BlockBashImpactDataSet = initialValue;
                this.AlternateBlockMaterial = initialValue;
                this.PickUpSound = initialValue;
                this.PutDownSound = initialValue;
                this.Keywords = new MaskItem<TItem, IEnumerable<(int Index, TItem Value)>?>(initialValue, Enumerable.Empty<(int Index, TItem Value)>());
                this.Description = initialValue;
                this.InstanceNaming = initialValue;
                this.AttachParentSlots = new MaskItem<TItem, IEnumerable<(int Index, TItem Value)>?>(initialValue, Enumerable.Empty<(int Index, TItem Value)>());
                this.ObjectTemplates = new MaskItem<TItem, IEnumerable<MaskItemIndexed<TItem, ObjectTemplate.Mask<TItem>?>>?>(initialValue, Enumerable.Empty<MaskItemIndexed<TItem, ObjectTemplate.Mask<TItem>?>>());
                this.EmbeddedWeaponMod = initialValue;
                this.FirstPersonModel = new MaskItem<TItem, Model.Mask<TItem>?>(initialValue, new Model.Mask<TItem>(initialValue));
                this.FirstPersonColorRemappingIndex = initialValue;
                this.MO4F = initialValue;
                this.Ammo = initialValue;
                this.Speed = initialValue;
                this.ReloadSpeed = initialValue;
                this.Reach = initialValue;
                this.MinRange = initialValue;
                this.MaxRange = initialValue;
                this.AttackDelay = initialValue;
                this.Unknown = initialValue;
                this.DamageOutOfRangeMult = initialValue;
                this.OnHit = initialValue;
                this.Skill = initialValue;
                this.Resist = initialValue;
                this.Flags = initialValue;
                this.Capacity = initialValue;
                this.AnimationType = initialValue;
                this.SecondaryDamage = initialValue;
                this.Weight = initialValue;
                this.Value = initialValue;
                this.BaseDamage = initialValue;
                this.SoundLevel = initialValue;
                this.AttackSound = initialValue;
                this.Attack2dSound = initialValue;
                this.AttackLoopSound = initialValue;
                this.AttackFailSound = initialValue;
                this.IdleSound = initialValue;
                this.EquipSound = initialValue;
                this.UnequipSound = initialValue;
                this.FastEquipSound = initialValue;
                this.AccuracyBonus = initialValue;
                this.AnimationAttackSeconds = initialValue;
                this.Unknown2 = initialValue;
                this.ActionPointCost = initialValue;
                this.FullPowerSeconds = initialValue;
                this.MinPowerPerShot = initialValue;
                this.Stagger = initialValue;
                this.Unknown3 = initialValue;
                this.ExtraData = new MaskItem<TItem, WeaponExtraData.Mask<TItem>?>(initialValue, new WeaponExtraData.Mask<TItem>(initialValue));
                this.CritDamageMult = initialValue;
                this.CritChargeBonus = initialValue;
                this.CritEffect = initialValue;
                this.ImpactDataSet = initialValue;
                this.NpcAddAmmoList = initialValue;
                this.AimModel = initialValue;
                this.Zoom = initialValue;
                this.Template = initialValue;
                this.DamageType = new MaskItem<TItem, WeaponDamageType.Mask<TItem>?>(initialValue, new WeaponDamageType.Mask<TItem>(initialValue));
                this.Filter = initialValue;
                this.MeleeSpeed = initialValue;
                this.DNAMDataTypeState = initialValue;
                this.CRDTDataTypeState = initialValue;
            }

            public Mask(
                TItem MajorRecordFlagsRaw,
                TItem FormKey,
                TItem VersionControl,
                TItem EditorID,
                TItem FormVersion,
                TItem Version2,
                TItem VirtualMachineAdapter,
                TItem ObjectBounds,
                TItem PreviewTransform,
                TItem AnimationSound,
                TItem Name,
                TItem Model,
                TItem Icons,
                TItem ObjectEffect,
                TItem EnchantmentAmount,
                TItem Destructible,
                TItem EquipmentType,
                TItem BlockBashImpactDataSet,
                TItem AlternateBlockMaterial,
                TItem PickUpSound,
                TItem PutDownSound,
                TItem Keywords,
                TItem Description,
                TItem InstanceNaming,
                TItem AttachParentSlots,
                TItem ObjectTemplates,
                TItem EmbeddedWeaponMod,
                TItem FirstPersonModel,
                TItem FirstPersonColorRemappingIndex,
                TItem MO4F,
                TItem Ammo,
                TItem Speed,
                TItem ReloadSpeed,
                TItem Reach,
                TItem MinRange,
                TItem MaxRange,
                TItem AttackDelay,
                TItem Unknown,
                TItem DamageOutOfRangeMult,
                TItem OnHit,
                TItem Skill,
                TItem Resist,
                TItem Flags,
                TItem Capacity,
                TItem AnimationType,
                TItem SecondaryDamage,
                TItem Weight,
                TItem Value,
                TItem BaseDamage,
                TItem SoundLevel,
                TItem AttackSound,
                TItem Attack2dSound,
                TItem AttackLoopSound,
                TItem AttackFailSound,
                TItem IdleSound,
                TItem EquipSound,
                TItem UnequipSound,
                TItem FastEquipSound,
                TItem AccuracyBonus,
                TItem AnimationAttackSeconds,
                TItem Unknown2,
                TItem ActionPointCost,
                TItem FullPowerSeconds,
                TItem MinPowerPerShot,
                TItem Stagger,
                TItem Unknown3,
                TItem ExtraData,
                TItem CritDamageMult,
                TItem CritChargeBonus,
                TItem CritEffect,
                TItem ImpactDataSet,
                TItem NpcAddAmmoList,
                TItem AimModel,
                TItem Zoom,
                TItem Template,
                TItem DamageType,
                TItem Filter,
                TItem MeleeSpeed,
                TItem DNAMDataTypeState,
                TItem CRDTDataTypeState)
            : base(
                MajorRecordFlagsRaw: MajorRecordFlagsRaw,
                FormKey: FormKey,
                VersionControl: VersionControl,
                EditorID: EditorID,
                FormVersion: FormVersion,
                Version2: Version2)
            {
                this.VirtualMachineAdapter = new MaskItem<TItem, VirtualMachineAdapter.Mask<TItem>?>(VirtualMachineAdapter, new VirtualMachineAdapter.Mask<TItem>(VirtualMachineAdapter));
                this.ObjectBounds = new MaskItem<TItem, ObjectBounds.Mask<TItem>?>(ObjectBounds, new ObjectBounds.Mask<TItem>(ObjectBounds));
                this.PreviewTransform = PreviewTransform;
                this.AnimationSound = AnimationSound;
                this.Name = Name;
                this.Model = new MaskItem<TItem, Model.Mask<TItem>?>(Model, new Model.Mask<TItem>(Model));
                this.Icons = new MaskItem<TItem, Icons.Mask<TItem>?>(Icons, new Icons.Mask<TItem>(Icons));
                this.ObjectEffect = ObjectEffect;
                this.EnchantmentAmount = EnchantmentAmount;
                this.Destructible = new MaskItem<TItem, Destructible.Mask<TItem>?>(Destructible, new Destructible.Mask<TItem>(Destructible));
                this.EquipmentType = EquipmentType;
                this.BlockBashImpactDataSet = BlockBashImpactDataSet;
                this.AlternateBlockMaterial = AlternateBlockMaterial;
                this.PickUpSound = PickUpSound;
                this.PutDownSound = PutDownSound;
                this.Keywords = new MaskItem<TItem, IEnumerable<(int Index, TItem Value)>?>(Keywords, Enumerable.Empty<(int Index, TItem Value)>());
                this.Description = Description;
                this.InstanceNaming = InstanceNaming;
                this.AttachParentSlots = new MaskItem<TItem, IEnumerable<(int Index, TItem Value)>?>(AttachParentSlots, Enumerable.Empty<(int Index, TItem Value)>());
                this.ObjectTemplates = new MaskItem<TItem, IEnumerable<MaskItemIndexed<TItem, ObjectTemplate.Mask<TItem>?>>?>(ObjectTemplates, Enumerable.Empty<MaskItemIndexed<TItem, ObjectTemplate.Mask<TItem>?>>());
                this.EmbeddedWeaponMod = EmbeddedWeaponMod;
                this.FirstPersonModel = new MaskItem<TItem, Model.Mask<TItem>?>(FirstPersonModel, new Model.Mask<TItem>(FirstPersonModel));
                this.FirstPersonColorRemappingIndex = FirstPersonColorRemappingIndex;
                this.MO4F = MO4F;
                this.Ammo = Ammo;
                this.Speed = Speed;
                this.ReloadSpeed = ReloadSpeed;
                this.Reach = Reach;
                this.MinRange = MinRange;
                this.MaxRange = MaxRange;
                this.AttackDelay = AttackDelay;
                this.Unknown = Unknown;
                this.DamageOutOfRangeMult = DamageOutOfRangeMult;
                this.OnHit = OnHit;
                this.Skill = Skill;
                this.Resist = Resist;
                this.Flags = Flags;
                this.Capacity = Capacity;
                this.AnimationType = AnimationType;
                this.SecondaryDamage = SecondaryDamage;
                this.Weight = Weight;
                this.Value = Value;
                this.BaseDamage = BaseDamage;
                this.SoundLevel = SoundLevel;
                this.AttackSound = AttackSound;
                this.Attack2dSound = Attack2dSound;
                this.AttackLoopSound = AttackLoopSound;
                this.AttackFailSound = AttackFailSound;
                this.IdleSound = IdleSound;
                this.EquipSound = EquipSound;
                this.UnequipSound = UnequipSound;
                this.FastEquipSound = FastEquipSound;
                this.AccuracyBonus = AccuracyBonus;
                this.AnimationAttackSeconds = AnimationAttackSeconds;
                this.Unknown2 = Unknown2;
                this.ActionPointCost = ActionPointCost;
                this.FullPowerSeconds = FullPowerSeconds;
                this.MinPowerPerShot = MinPowerPerShot;
                this.Stagger = Stagger;
                this.Unknown3 = Unknown3;
                this.ExtraData = new MaskItem<TItem, WeaponExtraData.Mask<TItem>?>(ExtraData, new WeaponExtraData.Mask<TItem>(ExtraData));
                this.CritDamageMult = CritDamageMult;
                this.CritChargeBonus = CritChargeBonus;
                this.CritEffect = CritEffect;
                this.ImpactDataSet = ImpactDataSet;
                this.NpcAddAmmoList = NpcAddAmmoList;
                this.AimModel = AimModel;
                this.Zoom = Zoom;
                this.Template = Template;
                this.DamageType = new MaskItem<TItem, WeaponDamageType.Mask<TItem>?>(DamageType, new WeaponDamageType.Mask<TItem>(DamageType));
                this.Filter = Filter;
                this.MeleeSpeed = MeleeSpeed;
                this.DNAMDataTypeState = DNAMDataTypeState;
                this.CRDTDataTypeState = CRDTDataTypeState;
            }

            #pragma warning disable CS8618
            protected Mask()
            {
            }
            #pragma warning restore CS8618

            #endregion

            #region Members
            public MaskItem<TItem, VirtualMachineAdapter.Mask<TItem>?>? VirtualMachineAdapter { get; set; }
            public MaskItem<TItem, ObjectBounds.Mask<TItem>?>? ObjectBounds { get; set; }
            public TItem PreviewTransform;
            public TItem AnimationSound;
            public TItem Name;
            public MaskItem<TItem, Model.Mask<TItem>?>? Model { get; set; }
            public MaskItem<TItem, Icons.Mask<TItem>?>? Icons { get; set; }
            public TItem ObjectEffect;
            public TItem EnchantmentAmount;
            public MaskItem<TItem, Destructible.Mask<TItem>?>? Destructible { get; set; }
            public TItem EquipmentType;
            public TItem BlockBashImpactDataSet;
            public TItem AlternateBlockMaterial;
            public TItem PickUpSound;
            public TItem PutDownSound;
            public MaskItem<TItem, IEnumerable<(int Index, TItem Value)>?>? Keywords;
            public TItem Description;
            public TItem InstanceNaming;
            public MaskItem<TItem, IEnumerable<(int Index, TItem Value)>?>? AttachParentSlots;
            public MaskItem<TItem, IEnumerable<MaskItemIndexed<TItem, ObjectTemplate.Mask<TItem>?>>?>? ObjectTemplates;
            public TItem EmbeddedWeaponMod;
            public MaskItem<TItem, Model.Mask<TItem>?>? FirstPersonModel { get; set; }
            public TItem FirstPersonColorRemappingIndex;
            public TItem MO4F;
            public TItem Ammo;
            public TItem Speed;
            public TItem ReloadSpeed;
            public TItem Reach;
            public TItem MinRange;
            public TItem MaxRange;
            public TItem AttackDelay;
            public TItem Unknown;
            public TItem DamageOutOfRangeMult;
            public TItem OnHit;
            public TItem Skill;
            public TItem Resist;
            public TItem Flags;
            public TItem Capacity;
            public TItem AnimationType;
            public TItem SecondaryDamage;
            public TItem Weight;
            public TItem Value;
            public TItem BaseDamage;
            public TItem SoundLevel;
            public TItem AttackSound;
            public TItem Attack2dSound;
            public TItem AttackLoopSound;
            public TItem AttackFailSound;
            public TItem IdleSound;
            public TItem EquipSound;
            public TItem UnequipSound;
            public TItem FastEquipSound;
            public TItem AccuracyBonus;
            public TItem AnimationAttackSeconds;
            public TItem Unknown2;
            public TItem ActionPointCost;
            public TItem FullPowerSeconds;
            public TItem MinPowerPerShot;
            public TItem Stagger;
            public TItem Unknown3;
            public MaskItem<TItem, WeaponExtraData.Mask<TItem>?>? ExtraData { get; set; }
            public TItem CritDamageMult;
            public TItem CritChargeBonus;
            public TItem CritEffect;
            public TItem ImpactDataSet;
            public TItem NpcAddAmmoList;
            public TItem AimModel;
            public TItem Zoom;
            public TItem Template;
            public MaskItem<TItem, WeaponDamageType.Mask<TItem>?>? DamageType { get; set; }
            public TItem Filter;
            public TItem MeleeSpeed;
            public TItem DNAMDataTypeState;
            public TItem CRDTDataTypeState;
            #endregion

            #region Equals
            public override bool Equals(object? obj)
            {
                if (!(obj is Mask<TItem> rhs)) return false;
                return Equals(rhs);
            }

            public bool Equals(Mask<TItem>? rhs)
            {
                if (rhs == null) return false;
                if (!base.Equals(rhs)) return false;
                if (!object.Equals(this.VirtualMachineAdapter, rhs.VirtualMachineAdapter)) return false;
                if (!object.Equals(this.ObjectBounds, rhs.ObjectBounds)) return false;
                if (!object.Equals(this.PreviewTransform, rhs.PreviewTransform)) return false;
                if (!object.Equals(this.AnimationSound, rhs.AnimationSound)) return false;
                if (!object.Equals(this.Name, rhs.Name)) return false;
                if (!object.Equals(this.Model, rhs.Model)) return false;
                if (!object.Equals(this.Icons, rhs.Icons)) return false;
                if (!object.Equals(this.ObjectEffect, rhs.ObjectEffect)) return false;
                if (!object.Equals(this.EnchantmentAmount, rhs.EnchantmentAmount)) return false;
                if (!object.Equals(this.Destructible, rhs.Destructible)) return false;
                if (!object.Equals(this.EquipmentType, rhs.EquipmentType)) return false;
                if (!object.Equals(this.BlockBashImpactDataSet, rhs.BlockBashImpactDataSet)) return false;
                if (!object.Equals(this.AlternateBlockMaterial, rhs.AlternateBlockMaterial)) return false;
                if (!object.Equals(this.PickUpSound, rhs.PickUpSound)) return false;
                if (!object.Equals(this.PutDownSound, rhs.PutDownSound)) return false;
                if (!object.Equals(this.Keywords, rhs.Keywords)) return false;
                if (!object.Equals(this.Description, rhs.Description)) return false;
                if (!object.Equals(this.InstanceNaming, rhs.InstanceNaming)) return false;
                if (!object.Equals(this.AttachParentSlots, rhs.AttachParentSlots)) return false;
                if (!object.Equals(this.ObjectTemplates, rhs.ObjectTemplates)) return false;
                if (!object.Equals(this.EmbeddedWeaponMod, rhs.EmbeddedWeaponMod)) return false;
                if (!object.Equals(this.FirstPersonModel, rhs.FirstPersonModel)) return false;
                if (!object.Equals(this.FirstPersonColorRemappingIndex, rhs.FirstPersonColorRemappingIndex)) return false;
                if (!object.Equals(this.MO4F, rhs.MO4F)) return false;
                if (!object.Equals(this.Ammo, rhs.Ammo)) return false;
                if (!object.Equals(this.Speed, rhs.Speed)) return false;
                if (!object.Equals(this.ReloadSpeed, rhs.ReloadSpeed)) return false;
                if (!object.Equals(this.Reach, rhs.Reach)) return false;
                if (!object.Equals(this.MinRange, rhs.MinRange)) return false;
                if (!object.Equals(this.MaxRange, rhs.MaxRange)) return false;
                if (!object.Equals(this.AttackDelay, rhs.AttackDelay)) return false;
                if (!object.Equals(this.Unknown, rhs.Unknown)) return false;
                if (!object.Equals(this.DamageOutOfRangeMult, rhs.DamageOutOfRangeMult)) return false;
                if (!object.Equals(this.OnHit, rhs.OnHit)) return false;
                if (!object.Equals(this.Skill, rhs.Skill)) return false;
                if (!object.Equals(this.Resist, rhs.Resist)) return false;
                if (!object.Equals(this.Flags, rhs.Flags)) return false;
                if (!object.Equals(this.Capacity, rhs.Capacity)) return false;
                if (!object.Equals(this.AnimationType, rhs.AnimationType)) return false;
                if (!object.Equals(this.SecondaryDamage, rhs.SecondaryDamage)) return false;
                if (!object.Equals(this.Weight, rhs.Weight)) return false;
                if (!object.Equals(this.Value, rhs.Value)) return false;
                if (!object.Equals(this.BaseDamage, rhs.BaseDamage)) return false;
                if (!object.Equals(this.SoundLevel, rhs.SoundLevel)) return false;
                if (!object.Equals(this.AttackSound, rhs.AttackSound)) return false;
                if (!object.Equals(this.Attack2dSound, rhs.Attack2dSound)) return false;
                if (!object.Equals(this.AttackLoopSound, rhs.AttackLoopSound)) return false;
                if (!object.Equals(this.AttackFailSound, rhs.AttackFailSound)) return false;
                if (!object.Equals(this.IdleSound, rhs.IdleSound)) return false;
                if (!object.Equals(this.EquipSound, rhs.EquipSound)) return false;
                if (!object.Equals(this.UnequipSound, rhs.UnequipSound)) return false;
                if (!object.Equals(this.FastEquipSound, rhs.FastEquipSound)) return false;
                if (!object.Equals(this.AccuracyBonus, rhs.AccuracyBonus)) return false;
                if (!object.Equals(this.AnimationAttackSeconds, rhs.AnimationAttackSeconds)) return false;
                if (!object.Equals(this.Unknown2, rhs.Unknown2)) return false;
                if (!object.Equals(this.ActionPointCost, rhs.ActionPointCost)) return false;
                if (!object.Equals(this.FullPowerSeconds, rhs.FullPowerSeconds)) return false;
                if (!object.Equals(this.MinPowerPerShot, rhs.MinPowerPerShot)) return false;
                if (!object.Equals(this.Stagger, rhs.Stagger)) return false;
                if (!object.Equals(this.Unknown3, rhs.Unknown3)) return false;
                if (!object.Equals(this.ExtraData, rhs.ExtraData)) return false;
                if (!object.Equals(this.CritDamageMult, rhs.CritDamageMult)) return false;
                if (!object.Equals(this.CritChargeBonus, rhs.CritChargeBonus)) return false;
                if (!object.Equals(this.CritEffect, rhs.CritEffect)) return false;
                if (!object.Equals(this.ImpactDataSet, rhs.ImpactDataSet)) return false;
                if (!object.Equals(this.NpcAddAmmoList, rhs.NpcAddAmmoList)) return false;
                if (!object.Equals(this.AimModel, rhs.AimModel)) return false;
                if (!object.Equals(this.Zoom, rhs.Zoom)) return false;
                if (!object.Equals(this.Template, rhs.Template)) return false;
                if (!object.Equals(this.DamageType, rhs.DamageType)) return false;
                if (!object.Equals(this.Filter, rhs.Filter)) return false;
                if (!object.Equals(this.MeleeSpeed, rhs.MeleeSpeed)) return false;
                if (!object.Equals(this.DNAMDataTypeState, rhs.DNAMDataTypeState)) return false;
                if (!object.Equals(this.CRDTDataTypeState, rhs.CRDTDataTypeState)) return false;
                return true;
            }
            public override int GetHashCode()
            {
                var hash = new HashCode();
                hash.Add(this.VirtualMachineAdapter);
                hash.Add(this.ObjectBounds);
                hash.Add(this.PreviewTransform);
                hash.Add(this.AnimationSound);
                hash.Add(this.Name);
                hash.Add(this.Model);
                hash.Add(this.Icons);
                hash.Add(this.ObjectEffect);
                hash.Add(this.EnchantmentAmount);
                hash.Add(this.Destructible);
                hash.Add(this.EquipmentType);
                hash.Add(this.BlockBashImpactDataSet);
                hash.Add(this.AlternateBlockMaterial);
                hash.Add(this.PickUpSound);
                hash.Add(this.PutDownSound);
                hash.Add(this.Keywords);
                hash.Add(this.Description);
                hash.Add(this.InstanceNaming);
                hash.Add(this.AttachParentSlots);
                hash.Add(this.ObjectTemplates);
                hash.Add(this.EmbeddedWeaponMod);
                hash.Add(this.FirstPersonModel);
                hash.Add(this.FirstPersonColorRemappingIndex);
                hash.Add(this.MO4F);
                hash.Add(this.Ammo);
                hash.Add(this.Speed);
                hash.Add(this.ReloadSpeed);
                hash.Add(this.Reach);
                hash.Add(this.MinRange);
                hash.Add(this.MaxRange);
                hash.Add(this.AttackDelay);
                hash.Add(this.Unknown);
                hash.Add(this.DamageOutOfRangeMult);
                hash.Add(this.OnHit);
                hash.Add(this.Skill);
                hash.Add(this.Resist);
                hash.Add(this.Flags);
                hash.Add(this.Capacity);
                hash.Add(this.AnimationType);
                hash.Add(this.SecondaryDamage);
                hash.Add(this.Weight);
                hash.Add(this.Value);
                hash.Add(this.BaseDamage);
                hash.Add(this.SoundLevel);
                hash.Add(this.AttackSound);
                hash.Add(this.Attack2dSound);
                hash.Add(this.AttackLoopSound);
                hash.Add(this.AttackFailSound);
                hash.Add(this.IdleSound);
                hash.Add(this.EquipSound);
                hash.Add(this.UnequipSound);
                hash.Add(this.FastEquipSound);
                hash.Add(this.AccuracyBonus);
                hash.Add(this.AnimationAttackSeconds);
                hash.Add(this.Unknown2);
                hash.Add(this.ActionPointCost);
                hash.Add(this.FullPowerSeconds);
                hash.Add(this.MinPowerPerShot);
                hash.Add(this.Stagger);
                hash.Add(this.Unknown3);
                hash.Add(this.ExtraData);
                hash.Add(this.CritDamageMult);
                hash.Add(this.CritChargeBonus);
                hash.Add(this.CritEffect);
                hash.Add(this.ImpactDataSet);
                hash.Add(this.NpcAddAmmoList);
                hash.Add(this.AimModel);
                hash.Add(this.Zoom);
                hash.Add(this.Template);
                hash.Add(this.DamageType);
                hash.Add(this.Filter);
                hash.Add(this.MeleeSpeed);
                hash.Add(this.DNAMDataTypeState);
                hash.Add(this.CRDTDataTypeState);
                hash.Add(base.GetHashCode());
                return hash.ToHashCode();
            }

            #endregion

            #region All
            public override bool All(Func<TItem, bool> eval)
            {
                if (!base.All(eval)) return false;
                if (VirtualMachineAdapter != null)
                {
                    if (!eval(this.VirtualMachineAdapter.Overall)) return false;
                    if (this.VirtualMachineAdapter.Specific != null && !this.VirtualMachineAdapter.Specific.All(eval)) return false;
                }
                if (ObjectBounds != null)
                {
                    if (!eval(this.ObjectBounds.Overall)) return false;
                    if (this.ObjectBounds.Specific != null && !this.ObjectBounds.Specific.All(eval)) return false;
                }
                if (!eval(this.PreviewTransform)) return false;
                if (!eval(this.AnimationSound)) return false;
                if (!eval(this.Name)) return false;
                if (Model != null)
                {
                    if (!eval(this.Model.Overall)) return false;
                    if (this.Model.Specific != null && !this.Model.Specific.All(eval)) return false;
                }
                if (Icons != null)
                {
                    if (!eval(this.Icons.Overall)) return false;
                    if (this.Icons.Specific != null && !this.Icons.Specific.All(eval)) return false;
                }
                if (!eval(this.ObjectEffect)) return false;
                if (!eval(this.EnchantmentAmount)) return false;
                if (Destructible != null)
                {
                    if (!eval(this.Destructible.Overall)) return false;
                    if (this.Destructible.Specific != null && !this.Destructible.Specific.All(eval)) return false;
                }
                if (!eval(this.EquipmentType)) return false;
                if (!eval(this.BlockBashImpactDataSet)) return false;
                if (!eval(this.AlternateBlockMaterial)) return false;
                if (!eval(this.PickUpSound)) return false;
                if (!eval(this.PutDownSound)) return false;
                if (this.Keywords != null)
                {
                    if (!eval(this.Keywords.Overall)) return false;
                    if (this.Keywords.Specific != null)
                    {
                        foreach (var item in this.Keywords.Specific)
                        {
                            if (!eval(item.Value)) return false;
                        }
                    }
                }
                if (!eval(this.Description)) return false;
                if (!eval(this.InstanceNaming)) return false;
                if (this.AttachParentSlots != null)
                {
                    if (!eval(this.AttachParentSlots.Overall)) return false;
                    if (this.AttachParentSlots.Specific != null)
                    {
                        foreach (var item in this.AttachParentSlots.Specific)
                        {
                            if (!eval(item.Value)) return false;
                        }
                    }
                }
                if (this.ObjectTemplates != null)
                {
                    if (!eval(this.ObjectTemplates.Overall)) return false;
                    if (this.ObjectTemplates.Specific != null)
                    {
                        foreach (var item in this.ObjectTemplates.Specific)
                        {
                            if (!eval(item.Overall)) return false;
                            if (item.Specific != null && !item.Specific.All(eval)) return false;
                        }
                    }
                }
                if (!eval(this.EmbeddedWeaponMod)) return false;
                if (FirstPersonModel != null)
                {
                    if (!eval(this.FirstPersonModel.Overall)) return false;
                    if (this.FirstPersonModel.Specific != null && !this.FirstPersonModel.Specific.All(eval)) return false;
                }
                if (!eval(this.FirstPersonColorRemappingIndex)) return false;
                if (!eval(this.MO4F)) return false;
                if (!eval(this.Ammo)) return false;
                if (!eval(this.Speed)) return false;
                if (!eval(this.ReloadSpeed)) return false;
                if (!eval(this.Reach)) return false;
                if (!eval(this.MinRange)) return false;
                if (!eval(this.MaxRange)) return false;
                if (!eval(this.AttackDelay)) return false;
                if (!eval(this.Unknown)) return false;
                if (!eval(this.DamageOutOfRangeMult)) return false;
                if (!eval(this.OnHit)) return false;
                if (!eval(this.Skill)) return false;
                if (!eval(this.Resist)) return false;
                if (!eval(this.Flags)) return false;
                if (!eval(this.Capacity)) return false;
                if (!eval(this.AnimationType)) return false;
                if (!eval(this.SecondaryDamage)) return false;
                if (!eval(this.Weight)) return false;
                if (!eval(this.Value)) return false;
                if (!eval(this.BaseDamage)) return false;
                if (!eval(this.SoundLevel)) return false;
                if (!eval(this.AttackSound)) return false;
                if (!eval(this.Attack2dSound)) return false;
                if (!eval(this.AttackLoopSound)) return false;
                if (!eval(this.AttackFailSound)) return false;
                if (!eval(this.IdleSound)) return false;
                if (!eval(this.EquipSound)) return false;
                if (!eval(this.UnequipSound)) return false;
                if (!eval(this.FastEquipSound)) return false;
                if (!eval(this.AccuracyBonus)) return false;
                if (!eval(this.AnimationAttackSeconds)) return false;
                if (!eval(this.Unknown2)) return false;
                if (!eval(this.ActionPointCost)) return false;
                if (!eval(this.FullPowerSeconds)) return false;
                if (!eval(this.MinPowerPerShot)) return false;
                if (!eval(this.Stagger)) return false;
                if (!eval(this.Unknown3)) return false;
                if (ExtraData != null)
                {
                    if (!eval(this.ExtraData.Overall)) return false;
                    if (this.ExtraData.Specific != null && !this.ExtraData.Specific.All(eval)) return false;
                }
                if (!eval(this.CritDamageMult)) return false;
                if (!eval(this.CritChargeBonus)) return false;
                if (!eval(this.CritEffect)) return false;
                if (!eval(this.ImpactDataSet)) return false;
                if (!eval(this.NpcAddAmmoList)) return false;
                if (!eval(this.AimModel)) return false;
                if (!eval(this.Zoom)) return false;
                if (!eval(this.Template)) return false;
                if (DamageType != null)
                {
                    if (!eval(this.DamageType.Overall)) return false;
                    if (this.DamageType.Specific != null && !this.DamageType.Specific.All(eval)) return false;
                }
                if (!eval(this.Filter)) return false;
                if (!eval(this.MeleeSpeed)) return false;
                if (!eval(this.DNAMDataTypeState)) return false;
                if (!eval(this.CRDTDataTypeState)) return false;
                return true;
            }
            #endregion

            #region Any
            public override bool Any(Func<TItem, bool> eval)
            {
                if (base.Any(eval)) return true;
                if (VirtualMachineAdapter != null)
                {
                    if (eval(this.VirtualMachineAdapter.Overall)) return true;
                    if (this.VirtualMachineAdapter.Specific != null && this.VirtualMachineAdapter.Specific.Any(eval)) return true;
                }
                if (ObjectBounds != null)
                {
                    if (eval(this.ObjectBounds.Overall)) return true;
                    if (this.ObjectBounds.Specific != null && this.ObjectBounds.Specific.Any(eval)) return true;
                }
                if (eval(this.PreviewTransform)) return true;
                if (eval(this.AnimationSound)) return true;
                if (eval(this.Name)) return true;
                if (Model != null)
                {
                    if (eval(this.Model.Overall)) return true;
                    if (this.Model.Specific != null && this.Model.Specific.Any(eval)) return true;
                }
                if (Icons != null)
                {
                    if (eval(this.Icons.Overall)) return true;
                    if (this.Icons.Specific != null && this.Icons.Specific.Any(eval)) return true;
                }
                if (eval(this.ObjectEffect)) return true;
                if (eval(this.EnchantmentAmount)) return true;
                if (Destructible != null)
                {
                    if (eval(this.Destructible.Overall)) return true;
                    if (this.Destructible.Specific != null && this.Destructible.Specific.Any(eval)) return true;
                }
                if (eval(this.EquipmentType)) return true;
                if (eval(this.BlockBashImpactDataSet)) return true;
                if (eval(this.AlternateBlockMaterial)) return true;
                if (eval(this.PickUpSound)) return true;
                if (eval(this.PutDownSound)) return true;
                if (this.Keywords != null)
                {
                    if (eval(this.Keywords.Overall)) return true;
                    if (this.Keywords.Specific != null)
                    {
                        foreach (var item in this.Keywords.Specific)
                        {
                            if (!eval(item.Value)) return false;
                        }
                    }
                }
                if (eval(this.Description)) return true;
                if (eval(this.InstanceNaming)) return true;
                if (this.AttachParentSlots != null)
                {
                    if (eval(this.AttachParentSlots.Overall)) return true;
                    if (this.AttachParentSlots.Specific != null)
                    {
                        foreach (var item in this.AttachParentSlots.Specific)
                        {
                            if (!eval(item.Value)) return false;
                        }
                    }
                }
                if (this.ObjectTemplates != null)
                {
                    if (eval(this.ObjectTemplates.Overall)) return true;
                    if (this.ObjectTemplates.Specific != null)
                    {
                        foreach (var item in this.ObjectTemplates.Specific)
                        {
                            if (!eval(item.Overall)) return false;
                            if (item.Specific != null && !item.Specific.All(eval)) return false;
                        }
                    }
                }
                if (eval(this.EmbeddedWeaponMod)) return true;
                if (FirstPersonModel != null)
                {
                    if (eval(this.FirstPersonModel.Overall)) return true;
                    if (this.FirstPersonModel.Specific != null && this.FirstPersonModel.Specific.Any(eval)) return true;
                }
                if (eval(this.FirstPersonColorRemappingIndex)) return true;
                if (eval(this.MO4F)) return true;
                if (eval(this.Ammo)) return true;
                if (eval(this.Speed)) return true;
                if (eval(this.ReloadSpeed)) return true;
                if (eval(this.Reach)) return true;
                if (eval(this.MinRange)) return true;
                if (eval(this.MaxRange)) return true;
                if (eval(this.AttackDelay)) return true;
                if (eval(this.Unknown)) return true;
                if (eval(this.DamageOutOfRangeMult)) return true;
                if (eval(this.OnHit)) return true;
                if (eval(this.Skill)) return true;
                if (eval(this.Resist)) return true;
                if (eval(this.Flags)) return true;
                if (eval(this.Capacity)) return true;
                if (eval(this.AnimationType)) return true;
                if (eval(this.SecondaryDamage)) return true;
                if (eval(this.Weight)) return true;
                if (eval(this.Value)) return true;
                if (eval(this.BaseDamage)) return true;
                if (eval(this.SoundLevel)) return true;
                if (eval(this.AttackSound)) return true;
                if (eval(this.Attack2dSound)) return true;
                if (eval(this.AttackLoopSound)) return true;
                if (eval(this.AttackFailSound)) return true;
                if (eval(this.IdleSound)) return true;
                if (eval(this.EquipSound)) return true;
                if (eval(this.UnequipSound)) return true;
                if (eval(this.FastEquipSound)) return true;
                if (eval(this.AccuracyBonus)) return true;
                if (eval(this.AnimationAttackSeconds)) return true;
                if (eval(this.Unknown2)) return true;
                if (eval(this.ActionPointCost)) return true;
                if (eval(this.FullPowerSeconds)) return true;
                if (eval(this.MinPowerPerShot)) return true;
                if (eval(this.Stagger)) return true;
                if (eval(this.Unknown3)) return true;
                if (ExtraData != null)
                {
                    if (eval(this.ExtraData.Overall)) return true;
                    if (this.ExtraData.Specific != null && this.ExtraData.Specific.Any(eval)) return true;
                }
                if (eval(this.CritDamageMult)) return true;
                if (eval(this.CritChargeBonus)) return true;
                if (eval(this.CritEffect)) return true;
                if (eval(this.ImpactDataSet)) return true;
                if (eval(this.NpcAddAmmoList)) return true;
                if (eval(this.AimModel)) return true;
                if (eval(this.Zoom)) return true;
                if (eval(this.Template)) return true;
                if (DamageType != null)
                {
                    if (eval(this.DamageType.Overall)) return true;
                    if (this.DamageType.Specific != null && this.DamageType.Specific.Any(eval)) return true;
                }
                if (eval(this.Filter)) return true;
                if (eval(this.MeleeSpeed)) return true;
                if (eval(this.DNAMDataTypeState)) return true;
                if (eval(this.CRDTDataTypeState)) return true;
                return false;
            }
            #endregion

            #region Translate
            public new Mask<R> Translate<R>(Func<TItem, R> eval)
            {
                var ret = new Weapon.Mask<R>();
                this.Translate_InternalFill(ret, eval);
                return ret;
            }

            protected void Translate_InternalFill<R>(Mask<R> obj, Func<TItem, R> eval)
            {
                base.Translate_InternalFill(obj, eval);
                obj.VirtualMachineAdapter = this.VirtualMachineAdapter == null ? null : new MaskItem<R, VirtualMachineAdapter.Mask<R>?>(eval(this.VirtualMachineAdapter.Overall), this.VirtualMachineAdapter.Specific?.Translate(eval));
                obj.ObjectBounds = this.ObjectBounds == null ? null : new MaskItem<R, ObjectBounds.Mask<R>?>(eval(this.ObjectBounds.Overall), this.ObjectBounds.Specific?.Translate(eval));
                obj.PreviewTransform = eval(this.PreviewTransform);
                obj.AnimationSound = eval(this.AnimationSound);
                obj.Name = eval(this.Name);
                obj.Model = this.Model == null ? null : new MaskItem<R, Model.Mask<R>?>(eval(this.Model.Overall), this.Model.Specific?.Translate(eval));
                obj.Icons = this.Icons == null ? null : new MaskItem<R, Icons.Mask<R>?>(eval(this.Icons.Overall), this.Icons.Specific?.Translate(eval));
                obj.ObjectEffect = eval(this.ObjectEffect);
                obj.EnchantmentAmount = eval(this.EnchantmentAmount);
                obj.Destructible = this.Destructible == null ? null : new MaskItem<R, Destructible.Mask<R>?>(eval(this.Destructible.Overall), this.Destructible.Specific?.Translate(eval));
                obj.EquipmentType = eval(this.EquipmentType);
                obj.BlockBashImpactDataSet = eval(this.BlockBashImpactDataSet);
                obj.AlternateBlockMaterial = eval(this.AlternateBlockMaterial);
                obj.PickUpSound = eval(this.PickUpSound);
                obj.PutDownSound = eval(this.PutDownSound);
                if (Keywords != null)
                {
                    obj.Keywords = new MaskItem<R, IEnumerable<(int Index, R Value)>?>(eval(this.Keywords.Overall), Enumerable.Empty<(int Index, R Value)>());
                    if (Keywords.Specific != null)
                    {
                        var l = new List<(int Index, R Item)>();
                        obj.Keywords.Specific = l;
                        foreach (var item in Keywords.Specific)
                        {
                            R mask = eval(item.Value);
                            l.Add((item.Index, mask));
                        }
                    }
                }
                obj.Description = eval(this.Description);
                obj.InstanceNaming = eval(this.InstanceNaming);
                if (AttachParentSlots != null)
                {
                    obj.AttachParentSlots = new MaskItem<R, IEnumerable<(int Index, R Value)>?>(eval(this.AttachParentSlots.Overall), Enumerable.Empty<(int Index, R Value)>());
                    if (AttachParentSlots.Specific != null)
                    {
                        var l = new List<(int Index, R Item)>();
                        obj.AttachParentSlots.Specific = l;
                        foreach (var item in AttachParentSlots.Specific)
                        {
                            R mask = eval(item.Value);
                            l.Add((item.Index, mask));
                        }
                    }
                }
                if (ObjectTemplates != null)
                {
                    obj.ObjectTemplates = new MaskItem<R, IEnumerable<MaskItemIndexed<R, ObjectTemplate.Mask<R>?>>?>(eval(this.ObjectTemplates.Overall), Enumerable.Empty<MaskItemIndexed<R, ObjectTemplate.Mask<R>?>>());
                    if (ObjectTemplates.Specific != null)
                    {
                        var l = new List<MaskItemIndexed<R, ObjectTemplate.Mask<R>?>>();
                        obj.ObjectTemplates.Specific = l;
                        foreach (var item in ObjectTemplates.Specific)
                        {
                            MaskItemIndexed<R, ObjectTemplate.Mask<R>?>? mask = item == null ? null : new MaskItemIndexed<R, ObjectTemplate.Mask<R>?>(item.Index, eval(item.Overall), item.Specific?.Translate(eval));
                            if (mask == null) continue;
                            l.Add(mask);
                        }
                    }
                }
                obj.EmbeddedWeaponMod = eval(this.EmbeddedWeaponMod);
                obj.FirstPersonModel = this.FirstPersonModel == null ? null : new MaskItem<R, Model.Mask<R>?>(eval(this.FirstPersonModel.Overall), this.FirstPersonModel.Specific?.Translate(eval));
                obj.FirstPersonColorRemappingIndex = eval(this.FirstPersonColorRemappingIndex);
                obj.MO4F = eval(this.MO4F);
                obj.Ammo = eval(this.Ammo);
                obj.Speed = eval(this.Speed);
                obj.ReloadSpeed = eval(this.ReloadSpeed);
                obj.Reach = eval(this.Reach);
                obj.MinRange = eval(this.MinRange);
                obj.MaxRange = eval(this.MaxRange);
                obj.AttackDelay = eval(this.AttackDelay);
                obj.Unknown = eval(this.Unknown);
                obj.DamageOutOfRangeMult = eval(this.DamageOutOfRangeMult);
                obj.OnHit = eval(this.OnHit);
                obj.Skill = eval(this.Skill);
                obj.Resist = eval(this.Resist);
                obj.Flags = eval(this.Flags);
                obj.Capacity = eval(this.Capacity);
                obj.AnimationType = eval(this.AnimationType);
                obj.SecondaryDamage = eval(this.SecondaryDamage);
                obj.Weight = eval(this.Weight);
                obj.Value = eval(this.Value);
                obj.BaseDamage = eval(this.BaseDamage);
                obj.SoundLevel = eval(this.SoundLevel);
                obj.AttackSound = eval(this.AttackSound);
                obj.Attack2dSound = eval(this.Attack2dSound);
                obj.AttackLoopSound = eval(this.AttackLoopSound);
                obj.AttackFailSound = eval(this.AttackFailSound);
                obj.IdleSound = eval(this.IdleSound);
                obj.EquipSound = eval(this.EquipSound);
                obj.UnequipSound = eval(this.UnequipSound);
                obj.FastEquipSound = eval(this.FastEquipSound);
                obj.AccuracyBonus = eval(this.AccuracyBonus);
                obj.AnimationAttackSeconds = eval(this.AnimationAttackSeconds);
                obj.Unknown2 = eval(this.Unknown2);
                obj.ActionPointCost = eval(this.ActionPointCost);
                obj.FullPowerSeconds = eval(this.FullPowerSeconds);
                obj.MinPowerPerShot = eval(this.MinPowerPerShot);
                obj.Stagger = eval(this.Stagger);
                obj.Unknown3 = eval(this.Unknown3);
                obj.ExtraData = this.ExtraData == null ? null : new MaskItem<R, WeaponExtraData.Mask<R>?>(eval(this.ExtraData.Overall), this.ExtraData.Specific?.Translate(eval));
                obj.CritDamageMult = eval(this.CritDamageMult);
                obj.CritChargeBonus = eval(this.CritChargeBonus);
                obj.CritEffect = eval(this.CritEffect);
                obj.ImpactDataSet = eval(this.ImpactDataSet);
                obj.NpcAddAmmoList = eval(this.NpcAddAmmoList);
                obj.AimModel = eval(this.AimModel);
                obj.Zoom = eval(this.Zoom);
                obj.Template = eval(this.Template);
                obj.DamageType = this.DamageType == null ? null : new MaskItem<R, WeaponDamageType.Mask<R>?>(eval(this.DamageType.Overall), this.DamageType.Specific?.Translate(eval));
                obj.Filter = eval(this.Filter);
                obj.MeleeSpeed = eval(this.MeleeSpeed);
                obj.DNAMDataTypeState = eval(this.DNAMDataTypeState);
                obj.CRDTDataTypeState = eval(this.CRDTDataTypeState);
            }
            #endregion

            #region To String
            public override string ToString()
            {
                return ToString(printMask: null);
            }

            public string ToString(Weapon.Mask<bool>? printMask = null)
            {
                var sb = new StructuredStringBuilder();
                ToString(sb, printMask);
                return sb.ToString();
            }

            public void ToString(StructuredStringBuilder sb, Weapon.Mask<bool>? printMask = null)
            {
                sb.AppendLine($"{nameof(Weapon.Mask<TItem>)} =>");
                sb.AppendLine("[");
                using (sb.IncreaseDepth())
                {
                    if (printMask?.VirtualMachineAdapter?.Overall ?? true)
                    {
                        VirtualMachineAdapter?.ToString(sb);
                    }
                    if (printMask?.ObjectBounds?.Overall ?? true)
                    {
                        ObjectBounds?.ToString(sb);
                    }
                    if (printMask?.PreviewTransform ?? true)
                    {
                        sb.AppendItem(PreviewTransform, "PreviewTransform");
                    }
                    if (printMask?.AnimationSound ?? true)
                    {
                        sb.AppendItem(AnimationSound, "AnimationSound");
                    }
                    if (printMask?.Name ?? true)
                    {
                        sb.AppendItem(Name, "Name");
                    }
                    if (printMask?.Model?.Overall ?? true)
                    {
                        Model?.ToString(sb);
                    }
                    if (printMask?.Icons?.Overall ?? true)
                    {
                        Icons?.ToString(sb);
                    }
                    if (printMask?.ObjectEffect ?? true)
                    {
                        sb.AppendItem(ObjectEffect, "ObjectEffect");
                    }
                    if (printMask?.EnchantmentAmount ?? true)
                    {
                        sb.AppendItem(EnchantmentAmount, "EnchantmentAmount");
                    }
                    if (printMask?.Destructible?.Overall ?? true)
                    {
                        Destructible?.ToString(sb);
                    }
                    if (printMask?.EquipmentType ?? true)
                    {
                        sb.AppendItem(EquipmentType, "EquipmentType");
                    }
                    if (printMask?.BlockBashImpactDataSet ?? true)
                    {
                        sb.AppendItem(BlockBashImpactDataSet, "BlockBashImpactDataSet");
                    }
                    if (printMask?.AlternateBlockMaterial ?? true)
                    {
                        sb.AppendItem(AlternateBlockMaterial, "AlternateBlockMaterial");
                    }
                    if (printMask?.PickUpSound ?? true)
                    {
                        sb.AppendItem(PickUpSound, "PickUpSound");
                    }
                    if (printMask?.PutDownSound ?? true)
                    {
                        sb.AppendItem(PutDownSound, "PutDownSound");
                    }
                    if ((printMask?.Keywords?.Overall ?? true)
                        && Keywords is {} KeywordsItem)
                    {
                        sb.AppendLine("Keywords =>");
                        sb.AppendLine("[");
                        using (sb.IncreaseDepth())
                        {
                            sb.AppendItem(KeywordsItem.Overall);
                            if (KeywordsItem.Specific != null)
                            {
                                foreach (var subItem in KeywordsItem.Specific)
                                {
                                    sb.AppendLine("[");
                                    using (sb.IncreaseDepth())
                                    {
                                        {
                                            sb.AppendItem(subItem);
                                        }
                                    }
                                    sb.AppendLine("]");
                                }
                            }
                        }
                        sb.AppendLine("]");
                    }
                    if (printMask?.Description ?? true)
                    {
                        sb.AppendItem(Description, "Description");
                    }
                    if (printMask?.InstanceNaming ?? true)
                    {
                        sb.AppendItem(InstanceNaming, "InstanceNaming");
                    }
                    if ((printMask?.AttachParentSlots?.Overall ?? true)
                        && AttachParentSlots is {} AttachParentSlotsItem)
                    {
                        sb.AppendLine("AttachParentSlots =>");
                        sb.AppendLine("[");
                        using (sb.IncreaseDepth())
                        {
                            sb.AppendItem(AttachParentSlotsItem.Overall);
                            if (AttachParentSlotsItem.Specific != null)
                            {
                                foreach (var subItem in AttachParentSlotsItem.Specific)
                                {
                                    sb.AppendLine("[");
                                    using (sb.IncreaseDepth())
                                    {
                                        {
                                            sb.AppendItem(subItem);
                                        }
                                    }
                                    sb.AppendLine("]");
                                }
                            }
                        }
                        sb.AppendLine("]");
                    }
                    if ((printMask?.ObjectTemplates?.Overall ?? true)
                        && ObjectTemplates is {} ObjectTemplatesItem)
                    {
                        sb.AppendLine("ObjectTemplates =>");
                        sb.AppendLine("[");
                        using (sb.IncreaseDepth())
                        {
                            sb.AppendItem(ObjectTemplatesItem.Overall);
                            if (ObjectTemplatesItem.Specific != null)
                            {
                                foreach (var subItem in ObjectTemplatesItem.Specific)
                                {
                                    sb.AppendLine("[");
                                    using (sb.IncreaseDepth())
                                    {
                                        subItem?.ToString(sb);
                                    }
                                    sb.AppendLine("]");
                                }
                            }
                        }
                        sb.AppendLine("]");
                    }
                    if (printMask?.EmbeddedWeaponMod ?? true)
                    {
                        sb.AppendItem(EmbeddedWeaponMod, "EmbeddedWeaponMod");
                    }
                    if (printMask?.FirstPersonModel?.Overall ?? true)
                    {
                        FirstPersonModel?.ToString(sb);
                    }
                    if (printMask?.FirstPersonColorRemappingIndex ?? true)
                    {
                        sb.AppendItem(FirstPersonColorRemappingIndex, "FirstPersonColorRemappingIndex");
                    }
                    if (printMask?.MO4F ?? true)
                    {
                        sb.AppendItem(MO4F, "MO4F");
                    }
                    if (printMask?.Ammo ?? true)
                    {
                        sb.AppendItem(Ammo, "Ammo");
                    }
                    if (printMask?.Speed ?? true)
                    {
                        sb.AppendItem(Speed, "Speed");
                    }
                    if (printMask?.ReloadSpeed ?? true)
                    {
                        sb.AppendItem(ReloadSpeed, "ReloadSpeed");
                    }
                    if (printMask?.Reach ?? true)
                    {
                        sb.AppendItem(Reach, "Reach");
                    }
                    if (printMask?.MinRange ?? true)
                    {
                        sb.AppendItem(MinRange, "MinRange");
                    }
                    if (printMask?.MaxRange ?? true)
                    {
                        sb.AppendItem(MaxRange, "MaxRange");
                    }
                    if (printMask?.AttackDelay ?? true)
                    {
                        sb.AppendItem(AttackDelay, "AttackDelay");
                    }
                    if (printMask?.Unknown ?? true)
                    {
                        sb.AppendItem(Unknown, "Unknown");
                    }
                    if (printMask?.DamageOutOfRangeMult ?? true)
                    {
                        sb.AppendItem(DamageOutOfRangeMult, "DamageOutOfRangeMult");
                    }
                    if (printMask?.OnHit ?? true)
                    {
                        sb.AppendItem(OnHit, "OnHit");
                    }
                    if (printMask?.Skill ?? true)
                    {
                        sb.AppendItem(Skill, "Skill");
                    }
                    if (printMask?.Resist ?? true)
                    {
                        sb.AppendItem(Resist, "Resist");
                    }
                    if (printMask?.Flags ?? true)
                    {
                        sb.AppendItem(Flags, "Flags");
                    }
                    if (printMask?.Capacity ?? true)
                    {
                        sb.AppendItem(Capacity, "Capacity");
                    }
                    if (printMask?.AnimationType ?? true)
                    {
                        sb.AppendItem(AnimationType, "AnimationType");
                    }
                    if (printMask?.SecondaryDamage ?? true)
                    {
                        sb.AppendItem(SecondaryDamage, "SecondaryDamage");
                    }
                    if (printMask?.Weight ?? true)
                    {
                        sb.AppendItem(Weight, "Weight");
                    }
                    if (printMask?.Value ?? true)
                    {
                        sb.AppendItem(Value, "Value");
                    }
                    if (printMask?.BaseDamage ?? true)
                    {
                        sb.AppendItem(BaseDamage, "BaseDamage");
                    }
                    if (printMask?.SoundLevel ?? true)
                    {
                        sb.AppendItem(SoundLevel, "SoundLevel");
                    }
                    if (printMask?.AttackSound ?? true)
                    {
                        sb.AppendItem(AttackSound, "AttackSound");
                    }
                    if (printMask?.Attack2dSound ?? true)
                    {
                        sb.AppendItem(Attack2dSound, "Attack2dSound");
                    }
                    if (printMask?.AttackLoopSound ?? true)
                    {
                        sb.AppendItem(AttackLoopSound, "AttackLoopSound");
                    }
                    if (printMask?.AttackFailSound ?? true)
                    {
                        sb.AppendItem(AttackFailSound, "AttackFailSound");
                    }
                    if (printMask?.IdleSound ?? true)
                    {
                        sb.AppendItem(IdleSound, "IdleSound");
                    }
                    if (printMask?.EquipSound ?? true)
                    {
                        sb.AppendItem(EquipSound, "EquipSound");
                    }
                    if (printMask?.UnequipSound ?? true)
                    {
                        sb.AppendItem(UnequipSound, "UnequipSound");
                    }
                    if (printMask?.FastEquipSound ?? true)
                    {
                        sb.AppendItem(FastEquipSound, "FastEquipSound");
                    }
                    if (printMask?.AccuracyBonus ?? true)
                    {
                        sb.AppendItem(AccuracyBonus, "AccuracyBonus");
                    }
                    if (printMask?.AnimationAttackSeconds ?? true)
                    {
                        sb.AppendItem(AnimationAttackSeconds, "AnimationAttackSeconds");
                    }
                    if (printMask?.Unknown2 ?? true)
                    {
                        sb.AppendItem(Unknown2, "Unknown2");
                    }
                    if (printMask?.ActionPointCost ?? true)
                    {
                        sb.AppendItem(ActionPointCost, "ActionPointCost");
                    }
                    if (printMask?.FullPowerSeconds ?? true)
                    {
                        sb.AppendItem(FullPowerSeconds, "FullPowerSeconds");
                    }
                    if (printMask?.MinPowerPerShot ?? true)
                    {
                        sb.AppendItem(MinPowerPerShot, "MinPowerPerShot");
                    }
                    if (printMask?.Stagger ?? true)
                    {
                        sb.AppendItem(Stagger, "Stagger");
                    }
                    if (printMask?.Unknown3 ?? true)
                    {
                        sb.AppendItem(Unknown3, "Unknown3");
                    }
                    if (printMask?.ExtraData?.Overall ?? true)
                    {
                        ExtraData?.ToString(sb);
                    }
                    if (printMask?.CritDamageMult ?? true)
                    {
                        sb.AppendItem(CritDamageMult, "CritDamageMult");
                    }
                    if (printMask?.CritChargeBonus ?? true)
                    {
                        sb.AppendItem(CritChargeBonus, "CritChargeBonus");
                    }
                    if (printMask?.CritEffect ?? true)
                    {
                        sb.AppendItem(CritEffect, "CritEffect");
                    }
                    if (printMask?.ImpactDataSet ?? true)
                    {
                        sb.AppendItem(ImpactDataSet, "ImpactDataSet");
                    }
                    if (printMask?.NpcAddAmmoList ?? true)
                    {
                        sb.AppendItem(NpcAddAmmoList, "NpcAddAmmoList");
                    }
                    if (printMask?.AimModel ?? true)
                    {
                        sb.AppendItem(AimModel, "AimModel");
                    }
                    if (printMask?.Zoom ?? true)
                    {
                        sb.AppendItem(Zoom, "Zoom");
                    }
                    if (printMask?.Template ?? true)
                    {
                        sb.AppendItem(Template, "Template");
                    }
                    if (printMask?.DamageType?.Overall ?? true)
                    {
                        DamageType?.ToString(sb);
                    }
                    if (printMask?.Filter ?? true)
                    {
                        sb.AppendItem(Filter, "Filter");
                    }
                    if (printMask?.MeleeSpeed ?? true)
                    {
                        sb.AppendItem(MeleeSpeed, "MeleeSpeed");
                    }
                    if (printMask?.DNAMDataTypeState ?? true)
                    {
                        sb.AppendItem(DNAMDataTypeState, "DNAMDataTypeState");
                    }
                    if (printMask?.CRDTDataTypeState ?? true)
                    {
                        sb.AppendItem(CRDTDataTypeState, "CRDTDataTypeState");
                    }
                }
                sb.AppendLine("]");
            }
            #endregion

        }

        public new class ErrorMask :
            Fallout4MajorRecord.ErrorMask,
            IErrorMask<ErrorMask>
        {
            #region Members
            public MaskItem<Exception?, VirtualMachineAdapter.ErrorMask?>? VirtualMachineAdapter;
            public MaskItem<Exception?, ObjectBounds.ErrorMask?>? ObjectBounds;
            public Exception? PreviewTransform;
            public Exception? AnimationSound;
            public Exception? Name;
            public MaskItem<Exception?, Model.ErrorMask?>? Model;
            public MaskItem<Exception?, Icons.ErrorMask?>? Icons;
            public Exception? ObjectEffect;
            public Exception? EnchantmentAmount;
            public MaskItem<Exception?, Destructible.ErrorMask?>? Destructible;
            public Exception? EquipmentType;
            public Exception? BlockBashImpactDataSet;
            public Exception? AlternateBlockMaterial;
            public Exception? PickUpSound;
            public Exception? PutDownSound;
            public MaskItem<Exception?, IEnumerable<(int Index, Exception Value)>?>? Keywords;
            public Exception? Description;
            public Exception? InstanceNaming;
            public MaskItem<Exception?, IEnumerable<(int Index, Exception Value)>?>? AttachParentSlots;
            public MaskItem<Exception?, IEnumerable<MaskItem<Exception?, ObjectTemplate.ErrorMask?>>?>? ObjectTemplates;
            public Exception? EmbeddedWeaponMod;
            public MaskItem<Exception?, Model.ErrorMask?>? FirstPersonModel;
            public Exception? FirstPersonColorRemappingIndex;
            public Exception? MO4F;
            public Exception? Ammo;
            public Exception? Speed;
            public Exception? ReloadSpeed;
            public Exception? Reach;
            public Exception? MinRange;
            public Exception? MaxRange;
            public Exception? AttackDelay;
            public Exception? Unknown;
            public Exception? DamageOutOfRangeMult;
            public Exception? OnHit;
            public Exception? Skill;
            public Exception? Resist;
            public Exception? Flags;
            public Exception? Capacity;
            public Exception? AnimationType;
            public Exception? SecondaryDamage;
            public Exception? Weight;
            public Exception? Value;
            public Exception? BaseDamage;
            public Exception? SoundLevel;
            public Exception? AttackSound;
            public Exception? Attack2dSound;
            public Exception? AttackLoopSound;
            public Exception? AttackFailSound;
            public Exception? IdleSound;
            public Exception? EquipSound;
            public Exception? UnequipSound;
            public Exception? FastEquipSound;
            public Exception? AccuracyBonus;
            public Exception? AnimationAttackSeconds;
            public Exception? Unknown2;
            public Exception? ActionPointCost;
            public Exception? FullPowerSeconds;
            public Exception? MinPowerPerShot;
            public Exception? Stagger;
            public Exception? Unknown3;
            public MaskItem<Exception?, WeaponExtraData.ErrorMask?>? ExtraData;
            public Exception? CritDamageMult;
            public Exception? CritChargeBonus;
            public Exception? CritEffect;
            public Exception? ImpactDataSet;
            public Exception? NpcAddAmmoList;
            public Exception? AimModel;
            public Exception? Zoom;
            public Exception? Template;
            public MaskItem<Exception?, WeaponDamageType.ErrorMask?>? DamageType;
            public Exception? Filter;
            public Exception? MeleeSpeed;
            public Exception? DNAMDataTypeState;
            public Exception? CRDTDataTypeState;
            #endregion

            #region IErrorMask
            public override object? GetNthMask(int index)
            {
                Weapon_FieldIndex enu = (Weapon_FieldIndex)index;
                switch (enu)
                {
                    case Weapon_FieldIndex.VirtualMachineAdapter:
                        return VirtualMachineAdapter;
                    case Weapon_FieldIndex.ObjectBounds:
                        return ObjectBounds;
                    case Weapon_FieldIndex.PreviewTransform:
                        return PreviewTransform;
                    case Weapon_FieldIndex.AnimationSound:
                        return AnimationSound;
                    case Weapon_FieldIndex.Name:
                        return Name;
                    case Weapon_FieldIndex.Model:
                        return Model;
                    case Weapon_FieldIndex.Icons:
                        return Icons;
                    case Weapon_FieldIndex.ObjectEffect:
                        return ObjectEffect;
                    case Weapon_FieldIndex.EnchantmentAmount:
                        return EnchantmentAmount;
                    case Weapon_FieldIndex.Destructible:
                        return Destructible;
                    case Weapon_FieldIndex.EquipmentType:
                        return EquipmentType;
                    case Weapon_FieldIndex.BlockBashImpactDataSet:
                        return BlockBashImpactDataSet;
                    case Weapon_FieldIndex.AlternateBlockMaterial:
                        return AlternateBlockMaterial;
                    case Weapon_FieldIndex.PickUpSound:
                        return PickUpSound;
                    case Weapon_FieldIndex.PutDownSound:
                        return PutDownSound;
                    case Weapon_FieldIndex.Keywords:
                        return Keywords;
                    case Weapon_FieldIndex.Description:
                        return Description;
                    case Weapon_FieldIndex.InstanceNaming:
                        return InstanceNaming;
                    case Weapon_FieldIndex.AttachParentSlots:
                        return AttachParentSlots;
                    case Weapon_FieldIndex.ObjectTemplates:
                        return ObjectTemplates;
                    case Weapon_FieldIndex.EmbeddedWeaponMod:
                        return EmbeddedWeaponMod;
                    case Weapon_FieldIndex.FirstPersonModel:
                        return FirstPersonModel;
                    case Weapon_FieldIndex.FirstPersonColorRemappingIndex:
                        return FirstPersonColorRemappingIndex;
                    case Weapon_FieldIndex.MO4F:
                        return MO4F;
                    case Weapon_FieldIndex.Ammo:
                        return Ammo;
                    case Weapon_FieldIndex.Speed:
                        return Speed;
                    case Weapon_FieldIndex.ReloadSpeed:
                        return ReloadSpeed;
                    case Weapon_FieldIndex.Reach:
                        return Reach;
                    case Weapon_FieldIndex.MinRange:
                        return MinRange;
                    case Weapon_FieldIndex.MaxRange:
                        return MaxRange;
                    case Weapon_FieldIndex.AttackDelay:
                        return AttackDelay;
                    case Weapon_FieldIndex.Unknown:
                        return Unknown;
                    case Weapon_FieldIndex.DamageOutOfRangeMult:
                        return DamageOutOfRangeMult;
                    case Weapon_FieldIndex.OnHit:
                        return OnHit;
                    case Weapon_FieldIndex.Skill:
                        return Skill;
                    case Weapon_FieldIndex.Resist:
                        return Resist;
                    case Weapon_FieldIndex.Flags:
                        return Flags;
                    case Weapon_FieldIndex.Capacity:
                        return Capacity;
                    case Weapon_FieldIndex.AnimationType:
                        return AnimationType;
                    case Weapon_FieldIndex.SecondaryDamage:
                        return SecondaryDamage;
                    case Weapon_FieldIndex.Weight:
                        return Weight;
                    case Weapon_FieldIndex.Value:
                        return Value;
                    case Weapon_FieldIndex.BaseDamage:
                        return BaseDamage;
                    case Weapon_FieldIndex.SoundLevel:
                        return SoundLevel;
                    case Weapon_FieldIndex.AttackSound:
                        return AttackSound;
                    case Weapon_FieldIndex.Attack2dSound:
                        return Attack2dSound;
                    case Weapon_FieldIndex.AttackLoopSound:
                        return AttackLoopSound;
                    case Weapon_FieldIndex.AttackFailSound:
                        return AttackFailSound;
                    case Weapon_FieldIndex.IdleSound:
                        return IdleSound;
                    case Weapon_FieldIndex.EquipSound:
                        return EquipSound;
                    case Weapon_FieldIndex.UnequipSound:
                        return UnequipSound;
                    case Weapon_FieldIndex.FastEquipSound:
                        return FastEquipSound;
                    case Weapon_FieldIndex.AccuracyBonus:
                        return AccuracyBonus;
                    case Weapon_FieldIndex.AnimationAttackSeconds:
                        return AnimationAttackSeconds;
                    case Weapon_FieldIndex.Unknown2:
                        return Unknown2;
                    case Weapon_FieldIndex.ActionPointCost:
                        return ActionPointCost;
                    case Weapon_FieldIndex.FullPowerSeconds:
                        return FullPowerSeconds;
                    case Weapon_FieldIndex.MinPowerPerShot:
                        return MinPowerPerShot;
                    case Weapon_FieldIndex.Stagger:
                        return Stagger;
                    case Weapon_FieldIndex.Unknown3:
                        return Unknown3;
                    case Weapon_FieldIndex.ExtraData:
                        return ExtraData;
                    case Weapon_FieldIndex.CritDamageMult:
                        return CritDamageMult;
                    case Weapon_FieldIndex.CritChargeBonus:
                        return CritChargeBonus;
                    case Weapon_FieldIndex.CritEffect:
                        return CritEffect;
                    case Weapon_FieldIndex.ImpactDataSet:
                        return ImpactDataSet;
                    case Weapon_FieldIndex.NpcAddAmmoList:
                        return NpcAddAmmoList;
                    case Weapon_FieldIndex.AimModel:
                        return AimModel;
                    case Weapon_FieldIndex.Zoom:
                        return Zoom;
                    case Weapon_FieldIndex.Template:
                        return Template;
                    case Weapon_FieldIndex.DamageType:
                        return DamageType;
                    case Weapon_FieldIndex.Filter:
                        return Filter;
                    case Weapon_FieldIndex.MeleeSpeed:
                        return MeleeSpeed;
                    case Weapon_FieldIndex.DNAMDataTypeState:
                        return DNAMDataTypeState;
                    case Weapon_FieldIndex.CRDTDataTypeState:
                        return CRDTDataTypeState;
                    default:
                        return base.GetNthMask(index);
                }
            }

            public override void SetNthException(int index, Exception ex)
            {
                Weapon_FieldIndex enu = (Weapon_FieldIndex)index;
                switch (enu)
                {
                    case Weapon_FieldIndex.VirtualMachineAdapter:
                        this.VirtualMachineAdapter = new MaskItem<Exception?, VirtualMachineAdapter.ErrorMask?>(ex, null);
                        break;
                    case Weapon_FieldIndex.ObjectBounds:
                        this.ObjectBounds = new MaskItem<Exception?, ObjectBounds.ErrorMask?>(ex, null);
                        break;
                    case Weapon_FieldIndex.PreviewTransform:
                        this.PreviewTransform = ex;
                        break;
                    case Weapon_FieldIndex.AnimationSound:
                        this.AnimationSound = ex;
                        break;
                    case Weapon_FieldIndex.Name:
                        this.Name = ex;
                        break;
                    case Weapon_FieldIndex.Model:
                        this.Model = new MaskItem<Exception?, Model.ErrorMask?>(ex, null);
                        break;
                    case Weapon_FieldIndex.Icons:
                        this.Icons = new MaskItem<Exception?, Icons.ErrorMask?>(ex, null);
                        break;
                    case Weapon_FieldIndex.ObjectEffect:
                        this.ObjectEffect = ex;
                        break;
                    case Weapon_FieldIndex.EnchantmentAmount:
                        this.EnchantmentAmount = ex;
                        break;
                    case Weapon_FieldIndex.Destructible:
                        this.Destructible = new MaskItem<Exception?, Destructible.ErrorMask?>(ex, null);
                        break;
                    case Weapon_FieldIndex.EquipmentType:
                        this.EquipmentType = ex;
                        break;
                    case Weapon_FieldIndex.BlockBashImpactDataSet:
                        this.BlockBashImpactDataSet = ex;
                        break;
                    case Weapon_FieldIndex.AlternateBlockMaterial:
                        this.AlternateBlockMaterial = ex;
                        break;
                    case Weapon_FieldIndex.PickUpSound:
                        this.PickUpSound = ex;
                        break;
                    case Weapon_FieldIndex.PutDownSound:
                        this.PutDownSound = ex;
                        break;
                    case Weapon_FieldIndex.Keywords:
                        this.Keywords = new MaskItem<Exception?, IEnumerable<(int Index, Exception Value)>?>(ex, null);
                        break;
                    case Weapon_FieldIndex.Description:
                        this.Description = ex;
                        break;
                    case Weapon_FieldIndex.InstanceNaming:
                        this.InstanceNaming = ex;
                        break;
                    case Weapon_FieldIndex.AttachParentSlots:
                        this.AttachParentSlots = new MaskItem<Exception?, IEnumerable<(int Index, Exception Value)>?>(ex, null);
                        break;
                    case Weapon_FieldIndex.ObjectTemplates:
                        this.ObjectTemplates = new MaskItem<Exception?, IEnumerable<MaskItem<Exception?, ObjectTemplate.ErrorMask?>>?>(ex, null);
                        break;
                    case Weapon_FieldIndex.EmbeddedWeaponMod:
                        this.EmbeddedWeaponMod = ex;
                        break;
                    case Weapon_FieldIndex.FirstPersonModel:
                        this.FirstPersonModel = new MaskItem<Exception?, Model.ErrorMask?>(ex, null);
                        break;
                    case Weapon_FieldIndex.FirstPersonColorRemappingIndex:
                        this.FirstPersonColorRemappingIndex = ex;
                        break;
                    case Weapon_FieldIndex.MO4F:
                        this.MO4F = ex;
                        break;
                    case Weapon_FieldIndex.Ammo:
                        this.Ammo = ex;
                        break;
                    case Weapon_FieldIndex.Speed:
                        this.Speed = ex;
                        break;
                    case Weapon_FieldIndex.ReloadSpeed:
                        this.ReloadSpeed = ex;
                        break;
                    case Weapon_FieldIndex.Reach:
                        this.Reach = ex;
                        break;
                    case Weapon_FieldIndex.MinRange:
                        this.MinRange = ex;
                        break;
                    case Weapon_FieldIndex.MaxRange:
                        this.MaxRange = ex;
                        break;
                    case Weapon_FieldIndex.AttackDelay:
                        this.AttackDelay = ex;
                        break;
                    case Weapon_FieldIndex.Unknown:
                        this.Unknown = ex;
                        break;
                    case Weapon_FieldIndex.DamageOutOfRangeMult:
                        this.DamageOutOfRangeMult = ex;
                        break;
                    case Weapon_FieldIndex.OnHit:
                        this.OnHit = ex;
                        break;
                    case Weapon_FieldIndex.Skill:
                        this.Skill = ex;
                        break;
                    case Weapon_FieldIndex.Resist:
                        this.Resist = ex;
                        break;
                    case Weapon_FieldIndex.Flags:
                        this.Flags = ex;
                        break;
                    case Weapon_FieldIndex.Capacity:
                        this.Capacity = ex;
                        break;
                    case Weapon_FieldIndex.AnimationType:
                        this.AnimationType = ex;
                        break;
                    case Weapon_FieldIndex.SecondaryDamage:
                        this.SecondaryDamage = ex;
                        break;
                    case Weapon_FieldIndex.Weight:
                        this.Weight = ex;
                        break;
                    case Weapon_FieldIndex.Value:
                        this.Value = ex;
                        break;
                    case Weapon_FieldIndex.BaseDamage:
                        this.BaseDamage = ex;
                        break;
                    case Weapon_FieldIndex.SoundLevel:
                        this.SoundLevel = ex;
                        break;
                    case Weapon_FieldIndex.AttackSound:
                        this.AttackSound = ex;
                        break;
                    case Weapon_FieldIndex.Attack2dSound:
                        this.Attack2dSound = ex;
                        break;
                    case Weapon_FieldIndex.AttackLoopSound:
                        this.AttackLoopSound = ex;
                        break;
                    case Weapon_FieldIndex.AttackFailSound:
                        this.AttackFailSound = ex;
                        break;
                    case Weapon_FieldIndex.IdleSound:
                        this.IdleSound = ex;
                        break;
                    case Weapon_FieldIndex.EquipSound:
                        this.EquipSound = ex;
                        break;
                    case Weapon_FieldIndex.UnequipSound:
                        this.UnequipSound = ex;
                        break;
                    case Weapon_FieldIndex.FastEquipSound:
                        this.FastEquipSound = ex;
                        break;
                    case Weapon_FieldIndex.AccuracyBonus:
                        this.AccuracyBonus = ex;
                        break;
                    case Weapon_FieldIndex.AnimationAttackSeconds:
                        this.AnimationAttackSeconds = ex;
                        break;
                    case Weapon_FieldIndex.Unknown2:
                        this.Unknown2 = ex;
                        break;
                    case Weapon_FieldIndex.ActionPointCost:
                        this.ActionPointCost = ex;
                        break;
                    case Weapon_FieldIndex.FullPowerSeconds:
                        this.FullPowerSeconds = ex;
                        break;
                    case Weapon_FieldIndex.MinPowerPerShot:
                        this.MinPowerPerShot = ex;
                        break;
                    case Weapon_FieldIndex.Stagger:
                        this.Stagger = ex;
                        break;
                    case Weapon_FieldIndex.Unknown3:
                        this.Unknown3 = ex;
                        break;
                    case Weapon_FieldIndex.ExtraData:
                        this.ExtraData = new MaskItem<Exception?, WeaponExtraData.ErrorMask?>(ex, null);
                        break;
                    case Weapon_FieldIndex.CritDamageMult:
                        this.CritDamageMult = ex;
                        break;
                    case Weapon_FieldIndex.CritChargeBonus:
                        this.CritChargeBonus = ex;
                        break;
                    case Weapon_FieldIndex.CritEffect:
                        this.CritEffect = ex;
                        break;
                    case Weapon_FieldIndex.ImpactDataSet:
                        this.ImpactDataSet = ex;
                        break;
                    case Weapon_FieldIndex.NpcAddAmmoList:
                        this.NpcAddAmmoList = ex;
                        break;
                    case Weapon_FieldIndex.AimModel:
                        this.AimModel = ex;
                        break;
                    case Weapon_FieldIndex.Zoom:
                        this.Zoom = ex;
                        break;
                    case Weapon_FieldIndex.Template:
                        this.Template = ex;
                        break;
                    case Weapon_FieldIndex.DamageType:
                        this.DamageType = new MaskItem<Exception?, WeaponDamageType.ErrorMask?>(ex, null);
                        break;
                    case Weapon_FieldIndex.Filter:
                        this.Filter = ex;
                        break;
                    case Weapon_FieldIndex.MeleeSpeed:
                        this.MeleeSpeed = ex;
                        break;
                    case Weapon_FieldIndex.DNAMDataTypeState:
                        this.DNAMDataTypeState = ex;
                        break;
                    case Weapon_FieldIndex.CRDTDataTypeState:
                        this.CRDTDataTypeState = ex;
                        break;
                    default:
                        base.SetNthException(index, ex);
                        break;
                }
            }

            public override void SetNthMask(int index, object obj)
            {
                Weapon_FieldIndex enu = (Weapon_FieldIndex)index;
                switch (enu)
                {
                    case Weapon_FieldIndex.VirtualMachineAdapter:
                        this.VirtualMachineAdapter = (MaskItem<Exception?, VirtualMachineAdapter.ErrorMask?>?)obj;
                        break;
                    case Weapon_FieldIndex.ObjectBounds:
                        this.ObjectBounds = (MaskItem<Exception?, ObjectBounds.ErrorMask?>?)obj;
                        break;
                    case Weapon_FieldIndex.PreviewTransform:
                        this.PreviewTransform = (Exception?)obj;
                        break;
                    case Weapon_FieldIndex.AnimationSound:
                        this.AnimationSound = (Exception?)obj;
                        break;
                    case Weapon_FieldIndex.Name:
                        this.Name = (Exception?)obj;
                        break;
                    case Weapon_FieldIndex.Model:
                        this.Model = (MaskItem<Exception?, Model.ErrorMask?>?)obj;
                        break;
                    case Weapon_FieldIndex.Icons:
                        this.Icons = (MaskItem<Exception?, Icons.ErrorMask?>?)obj;
                        break;
                    case Weapon_FieldIndex.ObjectEffect:
                        this.ObjectEffect = (Exception?)obj;
                        break;
                    case Weapon_FieldIndex.EnchantmentAmount:
                        this.EnchantmentAmount = (Exception?)obj;
                        break;
                    case Weapon_FieldIndex.Destructible:
                        this.Destructible = (MaskItem<Exception?, Destructible.ErrorMask?>?)obj;
                        break;
                    case Weapon_FieldIndex.EquipmentType:
                        this.EquipmentType = (Exception?)obj;
                        break;
                    case Weapon_FieldIndex.BlockBashImpactDataSet:
                        this.BlockBashImpactDataSet = (Exception?)obj;
                        break;
                    case Weapon_FieldIndex.AlternateBlockMaterial:
                        this.AlternateBlockMaterial = (Exception?)obj;
                        break;
                    case Weapon_FieldIndex.PickUpSound:
                        this.PickUpSound = (Exception?)obj;
                        break;
                    case Weapon_FieldIndex.PutDownSound:
                        this.PutDownSound = (Exception?)obj;
                        break;
                    case Weapon_FieldIndex.Keywords:
                        this.Keywords = (MaskItem<Exception?, IEnumerable<(int Index, Exception Value)>?>)obj;
                        break;
                    case Weapon_FieldIndex.Description:
                        this.Description = (Exception?)obj;
                        break;
                    case Weapon_FieldIndex.InstanceNaming:
                        this.InstanceNaming = (Exception?)obj;
                        break;
                    case Weapon_FieldIndex.AttachParentSlots:
                        this.AttachParentSlots = (MaskItem<Exception?, IEnumerable<(int Index, Exception Value)>?>)obj;
                        break;
                    case Weapon_FieldIndex.ObjectTemplates:
                        this.ObjectTemplates = (MaskItem<Exception?, IEnumerable<MaskItem<Exception?, ObjectTemplate.ErrorMask?>>?>)obj;
                        break;
                    case Weapon_FieldIndex.EmbeddedWeaponMod:
                        this.EmbeddedWeaponMod = (Exception?)obj;
                        break;
                    case Weapon_FieldIndex.FirstPersonModel:
                        this.FirstPersonModel = (MaskItem<Exception?, Model.ErrorMask?>?)obj;
                        break;
                    case Weapon_FieldIndex.FirstPersonColorRemappingIndex:
                        this.FirstPersonColorRemappingIndex = (Exception?)obj;
                        break;
                    case Weapon_FieldIndex.MO4F:
                        this.MO4F = (Exception?)obj;
                        break;
                    case Weapon_FieldIndex.Ammo:
                        this.Ammo = (Exception?)obj;
                        break;
                    case Weapon_FieldIndex.Speed:
                        this.Speed = (Exception?)obj;
                        break;
                    case Weapon_FieldIndex.ReloadSpeed:
                        this.ReloadSpeed = (Exception?)obj;
                        break;
                    case Weapon_FieldIndex.Reach:
                        this.Reach = (Exception?)obj;
                        break;
                    case Weapon_FieldIndex.MinRange:
                        this.MinRange = (Exception?)obj;
                        break;
                    case Weapon_FieldIndex.MaxRange:
                        this.MaxRange = (Exception?)obj;
                        break;
                    case Weapon_FieldIndex.AttackDelay:
                        this.AttackDelay = (Exception?)obj;
                        break;
                    case Weapon_FieldIndex.Unknown:
                        this.Unknown = (Exception?)obj;
                        break;
                    case Weapon_FieldIndex.DamageOutOfRangeMult:
                        this.DamageOutOfRangeMult = (Exception?)obj;
                        break;
                    case Weapon_FieldIndex.OnHit:
                        this.OnHit = (Exception?)obj;
                        break;
                    case Weapon_FieldIndex.Skill:
                        this.Skill = (Exception?)obj;
                        break;
                    case Weapon_FieldIndex.Resist:
                        this.Resist = (Exception?)obj;
                        break;
                    case Weapon_FieldIndex.Flags:
                        this.Flags = (Exception?)obj;
                        break;
                    case Weapon_FieldIndex.Capacity:
                        this.Capacity = (Exception?)obj;
                        break;
                    case Weapon_FieldIndex.AnimationType:
                        this.AnimationType = (Exception?)obj;
                        break;
                    case Weapon_FieldIndex.SecondaryDamage:
                        this.SecondaryDamage = (Exception?)obj;
                        break;
                    case Weapon_FieldIndex.Weight:
                        this.Weight = (Exception?)obj;
                        break;
                    case Weapon_FieldIndex.Value:
                        this.Value = (Exception?)obj;
                        break;
                    case Weapon_FieldIndex.BaseDamage:
                        this.BaseDamage = (Exception?)obj;
                        break;
                    case Weapon_FieldIndex.SoundLevel:
                        this.SoundLevel = (Exception?)obj;
                        break;
                    case Weapon_FieldIndex.AttackSound:
                        this.AttackSound = (Exception?)obj;
                        break;
                    case Weapon_FieldIndex.Attack2dSound:
                        this.Attack2dSound = (Exception?)obj;
                        break;
                    case Weapon_FieldIndex.AttackLoopSound:
                        this.AttackLoopSound = (Exception?)obj;
                        break;
                    case Weapon_FieldIndex.AttackFailSound:
                        this.AttackFailSound = (Exception?)obj;
                        break;
                    case Weapon_FieldIndex.IdleSound:
                        this.IdleSound = (Exception?)obj;
                        break;
                    case Weapon_FieldIndex.EquipSound:
                        this.EquipSound = (Exception?)obj;
                        break;
                    case Weapon_FieldIndex.UnequipSound:
                        this.UnequipSound = (Exception?)obj;
                        break;
                    case Weapon_FieldIndex.FastEquipSound:
                        this.FastEquipSound = (Exception?)obj;
                        break;
                    case Weapon_FieldIndex.AccuracyBonus:
                        this.AccuracyBonus = (Exception?)obj;
                        break;
                    case Weapon_FieldIndex.AnimationAttackSeconds:
                        this.AnimationAttackSeconds = (Exception?)obj;
                        break;
                    case Weapon_FieldIndex.Unknown2:
                        this.Unknown2 = (Exception?)obj;
                        break;
                    case Weapon_FieldIndex.ActionPointCost:
                        this.ActionPointCost = (Exception?)obj;
                        break;
                    case Weapon_FieldIndex.FullPowerSeconds:
                        this.FullPowerSeconds = (Exception?)obj;
                        break;
                    case Weapon_FieldIndex.MinPowerPerShot:
                        this.MinPowerPerShot = (Exception?)obj;
                        break;
                    case Weapon_FieldIndex.Stagger:
                        this.Stagger = (Exception?)obj;
                        break;
                    case Weapon_FieldIndex.Unknown3:
                        this.Unknown3 = (Exception?)obj;
                        break;
                    case Weapon_FieldIndex.ExtraData:
                        this.ExtraData = (MaskItem<Exception?, WeaponExtraData.ErrorMask?>?)obj;
                        break;
                    case Weapon_FieldIndex.CritDamageMult:
                        this.CritDamageMult = (Exception?)obj;
                        break;
                    case Weapon_FieldIndex.CritChargeBonus:
                        this.CritChargeBonus = (Exception?)obj;
                        break;
                    case Weapon_FieldIndex.CritEffect:
                        this.CritEffect = (Exception?)obj;
                        break;
                    case Weapon_FieldIndex.ImpactDataSet:
                        this.ImpactDataSet = (Exception?)obj;
                        break;
                    case Weapon_FieldIndex.NpcAddAmmoList:
                        this.NpcAddAmmoList = (Exception?)obj;
                        break;
                    case Weapon_FieldIndex.AimModel:
                        this.AimModel = (Exception?)obj;
                        break;
                    case Weapon_FieldIndex.Zoom:
                        this.Zoom = (Exception?)obj;
                        break;
                    case Weapon_FieldIndex.Template:
                        this.Template = (Exception?)obj;
                        break;
                    case Weapon_FieldIndex.DamageType:
                        this.DamageType = (MaskItem<Exception?, WeaponDamageType.ErrorMask?>?)obj;
                        break;
                    case Weapon_FieldIndex.Filter:
                        this.Filter = (Exception?)obj;
                        break;
                    case Weapon_FieldIndex.MeleeSpeed:
                        this.MeleeSpeed = (Exception?)obj;
                        break;
                    case Weapon_FieldIndex.DNAMDataTypeState:
                        this.DNAMDataTypeState = (Exception?)obj;
                        break;
                    case Weapon_FieldIndex.CRDTDataTypeState:
                        this.CRDTDataTypeState = (Exception?)obj;
                        break;
                    default:
                        base.SetNthMask(index, obj);
                        break;
                }
            }

            public override bool IsInError()
            {
                if (Overall != null) return true;
                if (VirtualMachineAdapter != null) return true;
                if (ObjectBounds != null) return true;
                if (PreviewTransform != null) return true;
                if (AnimationSound != null) return true;
                if (Name != null) return true;
                if (Model != null) return true;
                if (Icons != null) return true;
                if (ObjectEffect != null) return true;
                if (EnchantmentAmount != null) return true;
                if (Destructible != null) return true;
                if (EquipmentType != null) return true;
                if (BlockBashImpactDataSet != null) return true;
                if (AlternateBlockMaterial != null) return true;
                if (PickUpSound != null) return true;
                if (PutDownSound != null) return true;
                if (Keywords != null) return true;
                if (Description != null) return true;
                if (InstanceNaming != null) return true;
                if (AttachParentSlots != null) return true;
                if (ObjectTemplates != null) return true;
                if (EmbeddedWeaponMod != null) return true;
                if (FirstPersonModel != null) return true;
                if (FirstPersonColorRemappingIndex != null) return true;
                if (MO4F != null) return true;
                if (Ammo != null) return true;
                if (Speed != null) return true;
                if (ReloadSpeed != null) return true;
                if (Reach != null) return true;
                if (MinRange != null) return true;
                if (MaxRange != null) return true;
                if (AttackDelay != null) return true;
                if (Unknown != null) return true;
                if (DamageOutOfRangeMult != null) return true;
                if (OnHit != null) return true;
                if (Skill != null) return true;
                if (Resist != null) return true;
                if (Flags != null) return true;
                if (Capacity != null) return true;
                if (AnimationType != null) return true;
                if (SecondaryDamage != null) return true;
                if (Weight != null) return true;
                if (Value != null) return true;
                if (BaseDamage != null) return true;
                if (SoundLevel != null) return true;
                if (AttackSound != null) return true;
                if (Attack2dSound != null) return true;
                if (AttackLoopSound != null) return true;
                if (AttackFailSound != null) return true;
                if (IdleSound != null) return true;
                if (EquipSound != null) return true;
                if (UnequipSound != null) return true;
                if (FastEquipSound != null) return true;
                if (AccuracyBonus != null) return true;
                if (AnimationAttackSeconds != null) return true;
                if (Unknown2 != null) return true;
                if (ActionPointCost != null) return true;
                if (FullPowerSeconds != null) return true;
                if (MinPowerPerShot != null) return true;
                if (Stagger != null) return true;
                if (Unknown3 != null) return true;
                if (ExtraData != null) return true;
                if (CritDamageMult != null) return true;
                if (CritChargeBonus != null) return true;
                if (CritEffect != null) return true;
                if (ImpactDataSet != null) return true;
                if (NpcAddAmmoList != null) return true;
                if (AimModel != null) return true;
                if (Zoom != null) return true;
                if (Template != null) return true;
                if (DamageType != null) return true;
                if (Filter != null) return true;
                if (MeleeSpeed != null) return true;
                if (DNAMDataTypeState != null) return true;
                if (CRDTDataTypeState != null) return true;
                return false;
            }
            #endregion

            #region To String
            public override string ToString()
            {
                var sb = new StructuredStringBuilder();
                ToString(sb, null);
                return sb.ToString();
            }

            public override void ToString(StructuredStringBuilder sb, string? name = null)
            {
                sb.AppendLine($"{(name ?? "ErrorMask")} =>");
                sb.AppendLine("[");
                using (sb.IncreaseDepth())
                {
                    if (this.Overall != null)
                    {
                        sb.AppendLine("Overall =>");
                        sb.AppendLine("[");
                        using (sb.IncreaseDepth())
                        {
                            sb.AppendLine($"{this.Overall}");
                        }
                        sb.AppendLine("]");
                    }
                    ToString_FillInternal(sb);
                }
                sb.AppendLine("]");
            }
            protected override void ToString_FillInternal(StructuredStringBuilder sb)
            {
                base.ToString_FillInternal(sb);
                VirtualMachineAdapter?.ToString(sb);
                ObjectBounds?.ToString(sb);
                {
                    sb.AppendItem(PreviewTransform, "PreviewTransform");
                }
                {
                    sb.AppendItem(AnimationSound, "AnimationSound");
                }
                {
                    sb.AppendItem(Name, "Name");
                }
                Model?.ToString(sb);
                Icons?.ToString(sb);
                {
                    sb.AppendItem(ObjectEffect, "ObjectEffect");
                }
                {
                    sb.AppendItem(EnchantmentAmount, "EnchantmentAmount");
                }
                Destructible?.ToString(sb);
                {
                    sb.AppendItem(EquipmentType, "EquipmentType");
                }
                {
                    sb.AppendItem(BlockBashImpactDataSet, "BlockBashImpactDataSet");
                }
                {
                    sb.AppendItem(AlternateBlockMaterial, "AlternateBlockMaterial");
                }
                {
                    sb.AppendItem(PickUpSound, "PickUpSound");
                }
                {
                    sb.AppendItem(PutDownSound, "PutDownSound");
                }
                if (Keywords is {} KeywordsItem)
                {
                    sb.AppendLine("Keywords =>");
                    sb.AppendLine("[");
                    using (sb.IncreaseDepth())
                    {
                        sb.AppendItem(KeywordsItem.Overall);
                        if (KeywordsItem.Specific != null)
                        {
                            foreach (var subItem in KeywordsItem.Specific)
                            {
                                sb.AppendLine("[");
                                using (sb.IncreaseDepth())
                                {
                                    {
                                        sb.AppendItem(subItem);
                                    }
                                }
                                sb.AppendLine("]");
                            }
                        }
                    }
                    sb.AppendLine("]");
                }
                {
                    sb.AppendItem(Description, "Description");
                }
                {
                    sb.AppendItem(InstanceNaming, "InstanceNaming");
                }
                if (AttachParentSlots is {} AttachParentSlotsItem)
                {
                    sb.AppendLine("AttachParentSlots =>");
                    sb.AppendLine("[");
                    using (sb.IncreaseDepth())
                    {
                        sb.AppendItem(AttachParentSlotsItem.Overall);
                        if (AttachParentSlotsItem.Specific != null)
                        {
                            foreach (var subItem in AttachParentSlotsItem.Specific)
                            {
                                sb.AppendLine("[");
                                using (sb.IncreaseDepth())
                                {
                                    {
                                        sb.AppendItem(subItem);
                                    }
                                }
                                sb.AppendLine("]");
                            }
                        }
                    }
                    sb.AppendLine("]");
                }
                if (ObjectTemplates is {} ObjectTemplatesItem)
                {
                    sb.AppendLine("ObjectTemplates =>");
                    sb.AppendLine("[");
                    using (sb.IncreaseDepth())
                    {
                        sb.AppendItem(ObjectTemplatesItem.Overall);
                        if (ObjectTemplatesItem.Specific != null)
                        {
                            foreach (var subItem in ObjectTemplatesItem.Specific)
                            {
                                sb.AppendLine("[");
                                using (sb.IncreaseDepth())
                                {
                                    subItem?.ToString(sb);
                                }
                                sb.AppendLine("]");
                            }
                        }
                    }
                    sb.AppendLine("]");
                }
                {
                    sb.AppendItem(EmbeddedWeaponMod, "EmbeddedWeaponMod");
                }
                FirstPersonModel?.ToString(sb);
                {
                    sb.AppendItem(FirstPersonColorRemappingIndex, "FirstPersonColorRemappingIndex");
                }
                {
                    sb.AppendItem(MO4F, "MO4F");
                }
                {
                    sb.AppendItem(Ammo, "Ammo");
                }
                {
                    sb.AppendItem(Speed, "Speed");
                }
                {
                    sb.AppendItem(ReloadSpeed, "ReloadSpeed");
                }
                {
                    sb.AppendItem(Reach, "Reach");
                }
                {
                    sb.AppendItem(MinRange, "MinRange");
                }
                {
                    sb.AppendItem(MaxRange, "MaxRange");
                }
                {
                    sb.AppendItem(AttackDelay, "AttackDelay");
                }
                {
                    sb.AppendItem(Unknown, "Unknown");
                }
                {
                    sb.AppendItem(DamageOutOfRangeMult, "DamageOutOfRangeMult");
                }
                {
                    sb.AppendItem(OnHit, "OnHit");
                }
                {
                    sb.AppendItem(Skill, "Skill");
                }
                {
                    sb.AppendItem(Resist, "Resist");
                }
                {
                    sb.AppendItem(Flags, "Flags");
                }
                {
                    sb.AppendItem(Capacity, "Capacity");
                }
                {
                    sb.AppendItem(AnimationType, "AnimationType");
                }
                {
                    sb.AppendItem(SecondaryDamage, "SecondaryDamage");
                }
                {
                    sb.AppendItem(Weight, "Weight");
                }
                {
                    sb.AppendItem(Value, "Value");
                }
                {
                    sb.AppendItem(BaseDamage, "BaseDamage");
                }
                {
                    sb.AppendItem(SoundLevel, "SoundLevel");
                }
                {
                    sb.AppendItem(AttackSound, "AttackSound");
                }
                {
                    sb.AppendItem(Attack2dSound, "Attack2dSound");
                }
                {
                    sb.AppendItem(AttackLoopSound, "AttackLoopSound");
                }
                {
                    sb.AppendItem(AttackFailSound, "AttackFailSound");
                }
                {
                    sb.AppendItem(IdleSound, "IdleSound");
                }
                {
                    sb.AppendItem(EquipSound, "EquipSound");
                }
                {
                    sb.AppendItem(UnequipSound, "UnequipSound");
                }
                {
                    sb.AppendItem(FastEquipSound, "FastEquipSound");
                }
                {
                    sb.AppendItem(AccuracyBonus, "AccuracyBonus");
                }
                {
                    sb.AppendItem(AnimationAttackSeconds, "AnimationAttackSeconds");
                }
                {
                    sb.AppendItem(Unknown2, "Unknown2");
                }
                {
                    sb.AppendItem(ActionPointCost, "ActionPointCost");
                }
                {
                    sb.AppendItem(FullPowerSeconds, "FullPowerSeconds");
                }
                {
                    sb.AppendItem(MinPowerPerShot, "MinPowerPerShot");
                }
                {
                    sb.AppendItem(Stagger, "Stagger");
                }
                {
                    sb.AppendItem(Unknown3, "Unknown3");
                }
                ExtraData?.ToString(sb);
                {
                    sb.AppendItem(CritDamageMult, "CritDamageMult");
                }
                {
                    sb.AppendItem(CritChargeBonus, "CritChargeBonus");
                }
                {
                    sb.AppendItem(CritEffect, "CritEffect");
                }
                {
                    sb.AppendItem(ImpactDataSet, "ImpactDataSet");
                }
                {
                    sb.AppendItem(NpcAddAmmoList, "NpcAddAmmoList");
                }
                {
                    sb.AppendItem(AimModel, "AimModel");
                }
                {
                    sb.AppendItem(Zoom, "Zoom");
                }
                {
                    sb.AppendItem(Template, "Template");
                }
                DamageType?.ToString(sb);
                {
                    sb.AppendItem(Filter, "Filter");
                }
                {
                    sb.AppendItem(MeleeSpeed, "MeleeSpeed");
                }
                {
                    sb.AppendItem(DNAMDataTypeState, "DNAMDataTypeState");
                }
                {
                    sb.AppendItem(CRDTDataTypeState, "CRDTDataTypeState");
                }
            }
            #endregion

            #region Combine
            public ErrorMask Combine(ErrorMask? rhs)
            {
                if (rhs == null) return this;
                var ret = new ErrorMask();
                ret.VirtualMachineAdapter = this.VirtualMachineAdapter.Combine(rhs.VirtualMachineAdapter, (l, r) => l.Combine(r));
                ret.ObjectBounds = this.ObjectBounds.Combine(rhs.ObjectBounds, (l, r) => l.Combine(r));
                ret.PreviewTransform = this.PreviewTransform.Combine(rhs.PreviewTransform);
                ret.AnimationSound = this.AnimationSound.Combine(rhs.AnimationSound);
                ret.Name = this.Name.Combine(rhs.Name);
                ret.Model = this.Model.Combine(rhs.Model, (l, r) => l.Combine(r));
                ret.Icons = this.Icons.Combine(rhs.Icons, (l, r) => l.Combine(r));
                ret.ObjectEffect = this.ObjectEffect.Combine(rhs.ObjectEffect);
                ret.EnchantmentAmount = this.EnchantmentAmount.Combine(rhs.EnchantmentAmount);
                ret.Destructible = this.Destructible.Combine(rhs.Destructible, (l, r) => l.Combine(r));
                ret.EquipmentType = this.EquipmentType.Combine(rhs.EquipmentType);
                ret.BlockBashImpactDataSet = this.BlockBashImpactDataSet.Combine(rhs.BlockBashImpactDataSet);
                ret.AlternateBlockMaterial = this.AlternateBlockMaterial.Combine(rhs.AlternateBlockMaterial);
                ret.PickUpSound = this.PickUpSound.Combine(rhs.PickUpSound);
                ret.PutDownSound = this.PutDownSound.Combine(rhs.PutDownSound);
                ret.Keywords = new MaskItem<Exception?, IEnumerable<(int Index, Exception Value)>?>(ExceptionExt.Combine(this.Keywords?.Overall, rhs.Keywords?.Overall), ExceptionExt.Combine(this.Keywords?.Specific, rhs.Keywords?.Specific));
                ret.Description = this.Description.Combine(rhs.Description);
                ret.InstanceNaming = this.InstanceNaming.Combine(rhs.InstanceNaming);
                ret.AttachParentSlots = new MaskItem<Exception?, IEnumerable<(int Index, Exception Value)>?>(ExceptionExt.Combine(this.AttachParentSlots?.Overall, rhs.AttachParentSlots?.Overall), ExceptionExt.Combine(this.AttachParentSlots?.Specific, rhs.AttachParentSlots?.Specific));
                ret.ObjectTemplates = new MaskItem<Exception?, IEnumerable<MaskItem<Exception?, ObjectTemplate.ErrorMask?>>?>(ExceptionExt.Combine(this.ObjectTemplates?.Overall, rhs.ObjectTemplates?.Overall), ExceptionExt.Combine(this.ObjectTemplates?.Specific, rhs.ObjectTemplates?.Specific));
                ret.EmbeddedWeaponMod = this.EmbeddedWeaponMod.Combine(rhs.EmbeddedWeaponMod);
                ret.FirstPersonModel = this.FirstPersonModel.Combine(rhs.FirstPersonModel, (l, r) => l.Combine(r));
                ret.FirstPersonColorRemappingIndex = this.FirstPersonColorRemappingIndex.Combine(rhs.FirstPersonColorRemappingIndex);
                ret.MO4F = this.MO4F.Combine(rhs.MO4F);
                ret.Ammo = this.Ammo.Combine(rhs.Ammo);
                ret.Speed = this.Speed.Combine(rhs.Speed);
                ret.ReloadSpeed = this.ReloadSpeed.Combine(rhs.ReloadSpeed);
                ret.Reach = this.Reach.Combine(rhs.Reach);
                ret.MinRange = this.MinRange.Combine(rhs.MinRange);
                ret.MaxRange = this.MaxRange.Combine(rhs.MaxRange);
                ret.AttackDelay = this.AttackDelay.Combine(rhs.AttackDelay);
                ret.Unknown = this.Unknown.Combine(rhs.Unknown);
                ret.DamageOutOfRangeMult = this.DamageOutOfRangeMult.Combine(rhs.DamageOutOfRangeMult);
                ret.OnHit = this.OnHit.Combine(rhs.OnHit);
                ret.Skill = this.Skill.Combine(rhs.Skill);
                ret.Resist = this.Resist.Combine(rhs.Resist);
                ret.Flags = this.Flags.Combine(rhs.Flags);
                ret.Capacity = this.Capacity.Combine(rhs.Capacity);
                ret.AnimationType = this.AnimationType.Combine(rhs.AnimationType);
                ret.SecondaryDamage = this.SecondaryDamage.Combine(rhs.SecondaryDamage);
                ret.Weight = this.Weight.Combine(rhs.Weight);
                ret.Value = this.Value.Combine(rhs.Value);
                ret.BaseDamage = this.BaseDamage.Combine(rhs.BaseDamage);
                ret.SoundLevel = this.SoundLevel.Combine(rhs.SoundLevel);
                ret.AttackSound = this.AttackSound.Combine(rhs.AttackSound);
                ret.Attack2dSound = this.Attack2dSound.Combine(rhs.Attack2dSound);
                ret.AttackLoopSound = this.AttackLoopSound.Combine(rhs.AttackLoopSound);
                ret.AttackFailSound = this.AttackFailSound.Combine(rhs.AttackFailSound);
                ret.IdleSound = this.IdleSound.Combine(rhs.IdleSound);
                ret.EquipSound = this.EquipSound.Combine(rhs.EquipSound);
                ret.UnequipSound = this.UnequipSound.Combine(rhs.UnequipSound);
                ret.FastEquipSound = this.FastEquipSound.Combine(rhs.FastEquipSound);
                ret.AccuracyBonus = this.AccuracyBonus.Combine(rhs.AccuracyBonus);
                ret.AnimationAttackSeconds = this.AnimationAttackSeconds.Combine(rhs.AnimationAttackSeconds);
                ret.Unknown2 = this.Unknown2.Combine(rhs.Unknown2);
                ret.ActionPointCost = this.ActionPointCost.Combine(rhs.ActionPointCost);
                ret.FullPowerSeconds = this.FullPowerSeconds.Combine(rhs.FullPowerSeconds);
                ret.MinPowerPerShot = this.MinPowerPerShot.Combine(rhs.MinPowerPerShot);
                ret.Stagger = this.Stagger.Combine(rhs.Stagger);
                ret.Unknown3 = this.Unknown3.Combine(rhs.Unknown3);
                ret.ExtraData = this.ExtraData.Combine(rhs.ExtraData, (l, r) => l.Combine(r));
                ret.CritDamageMult = this.CritDamageMult.Combine(rhs.CritDamageMult);
                ret.CritChargeBonus = this.CritChargeBonus.Combine(rhs.CritChargeBonus);
                ret.CritEffect = this.CritEffect.Combine(rhs.CritEffect);
                ret.ImpactDataSet = this.ImpactDataSet.Combine(rhs.ImpactDataSet);
                ret.NpcAddAmmoList = this.NpcAddAmmoList.Combine(rhs.NpcAddAmmoList);
                ret.AimModel = this.AimModel.Combine(rhs.AimModel);
                ret.Zoom = this.Zoom.Combine(rhs.Zoom);
                ret.Template = this.Template.Combine(rhs.Template);
                ret.DamageType = this.DamageType.Combine(rhs.DamageType, (l, r) => l.Combine(r));
                ret.Filter = this.Filter.Combine(rhs.Filter);
                ret.MeleeSpeed = this.MeleeSpeed.Combine(rhs.MeleeSpeed);
                ret.DNAMDataTypeState = this.DNAMDataTypeState.Combine(rhs.DNAMDataTypeState);
                ret.CRDTDataTypeState = this.CRDTDataTypeState.Combine(rhs.CRDTDataTypeState);
                return ret;
            }
            public static ErrorMask? Combine(ErrorMask? lhs, ErrorMask? rhs)
            {
                if (lhs != null && rhs != null) return lhs.Combine(rhs);
                return lhs ?? rhs;
            }
            #endregion

            #region Factory
            public static new ErrorMask Factory(ErrorMaskBuilder errorMask)
            {
                return new ErrorMask();
            }
            #endregion

        }
        public new class TranslationMask :
            Fallout4MajorRecord.TranslationMask,
            ITranslationMask
        {
            #region Members
            public VirtualMachineAdapter.TranslationMask? VirtualMachineAdapter;
            public ObjectBounds.TranslationMask? ObjectBounds;
            public bool PreviewTransform;
            public bool AnimationSound;
            public bool Name;
            public Model.TranslationMask? Model;
            public Icons.TranslationMask? Icons;
            public bool ObjectEffect;
            public bool EnchantmentAmount;
            public Destructible.TranslationMask? Destructible;
            public bool EquipmentType;
            public bool BlockBashImpactDataSet;
            public bool AlternateBlockMaterial;
            public bool PickUpSound;
            public bool PutDownSound;
            public bool Keywords;
            public bool Description;
            public bool InstanceNaming;
            public bool AttachParentSlots;
            public ObjectTemplate.TranslationMask? ObjectTemplates;
            public bool EmbeddedWeaponMod;
            public Model.TranslationMask? FirstPersonModel;
            public bool FirstPersonColorRemappingIndex;
            public bool MO4F;
            public bool Ammo;
            public bool Speed;
            public bool ReloadSpeed;
            public bool Reach;
            public bool MinRange;
            public bool MaxRange;
            public bool AttackDelay;
            public bool Unknown;
            public bool DamageOutOfRangeMult;
            public bool OnHit;
            public bool Skill;
            public bool Resist;
            public bool Flags;
            public bool Capacity;
            public bool AnimationType;
            public bool SecondaryDamage;
            public bool Weight;
            public bool Value;
            public bool BaseDamage;
            public bool SoundLevel;
            public bool AttackSound;
            public bool Attack2dSound;
            public bool AttackLoopSound;
            public bool AttackFailSound;
            public bool IdleSound;
            public bool EquipSound;
            public bool UnequipSound;
            public bool FastEquipSound;
            public bool AccuracyBonus;
            public bool AnimationAttackSeconds;
            public bool Unknown2;
            public bool ActionPointCost;
            public bool FullPowerSeconds;
            public bool MinPowerPerShot;
            public bool Stagger;
            public bool Unknown3;
            public WeaponExtraData.TranslationMask? ExtraData;
            public bool CritDamageMult;
            public bool CritChargeBonus;
            public bool CritEffect;
            public bool ImpactDataSet;
            public bool NpcAddAmmoList;
            public bool AimModel;
            public bool Zoom;
            public bool Template;
            public WeaponDamageType.TranslationMask? DamageType;
            public bool Filter;
            public bool MeleeSpeed;
            public bool DNAMDataTypeState;
            public bool CRDTDataTypeState;
            #endregion

            #region Ctors
            public TranslationMask(
                bool defaultOn,
                bool onOverall = true)
                : base(defaultOn, onOverall)
            {
                this.PreviewTransform = defaultOn;
                this.AnimationSound = defaultOn;
                this.Name = defaultOn;
                this.ObjectEffect = defaultOn;
                this.EnchantmentAmount = defaultOn;
                this.EquipmentType = defaultOn;
                this.BlockBashImpactDataSet = defaultOn;
                this.AlternateBlockMaterial = defaultOn;
                this.PickUpSound = defaultOn;
                this.PutDownSound = defaultOn;
                this.Keywords = defaultOn;
                this.Description = defaultOn;
                this.InstanceNaming = defaultOn;
                this.AttachParentSlots = defaultOn;
                this.EmbeddedWeaponMod = defaultOn;
                this.FirstPersonColorRemappingIndex = defaultOn;
                this.MO4F = defaultOn;
                this.Ammo = defaultOn;
                this.Speed = defaultOn;
                this.ReloadSpeed = defaultOn;
                this.Reach = defaultOn;
                this.MinRange = defaultOn;
                this.MaxRange = defaultOn;
                this.AttackDelay = defaultOn;
                this.Unknown = defaultOn;
                this.DamageOutOfRangeMult = defaultOn;
                this.OnHit = defaultOn;
                this.Skill = defaultOn;
                this.Resist = defaultOn;
                this.Flags = defaultOn;
                this.Capacity = defaultOn;
                this.AnimationType = defaultOn;
                this.SecondaryDamage = defaultOn;
                this.Weight = defaultOn;
                this.Value = defaultOn;
                this.BaseDamage = defaultOn;
                this.SoundLevel = defaultOn;
                this.AttackSound = defaultOn;
                this.Attack2dSound = defaultOn;
                this.AttackLoopSound = defaultOn;
                this.AttackFailSound = defaultOn;
                this.IdleSound = defaultOn;
                this.EquipSound = defaultOn;
                this.UnequipSound = defaultOn;
                this.FastEquipSound = defaultOn;
                this.AccuracyBonus = defaultOn;
                this.AnimationAttackSeconds = defaultOn;
                this.Unknown2 = defaultOn;
                this.ActionPointCost = defaultOn;
                this.FullPowerSeconds = defaultOn;
                this.MinPowerPerShot = defaultOn;
                this.Stagger = defaultOn;
                this.Unknown3 = defaultOn;
                this.CritDamageMult = defaultOn;
                this.CritChargeBonus = defaultOn;
                this.CritEffect = defaultOn;
                this.ImpactDataSet = defaultOn;
                this.NpcAddAmmoList = defaultOn;
                this.AimModel = defaultOn;
                this.Zoom = defaultOn;
                this.Template = defaultOn;
                this.Filter = defaultOn;
                this.MeleeSpeed = defaultOn;
                this.DNAMDataTypeState = defaultOn;
                this.CRDTDataTypeState = defaultOn;
            }

            #endregion

            protected override void GetCrystal(List<(bool On, TranslationCrystal? SubCrystal)> ret)
            {
                base.GetCrystal(ret);
                ret.Add((VirtualMachineAdapter != null ? VirtualMachineAdapter.OnOverall : DefaultOn, VirtualMachineAdapter?.GetCrystal()));
                ret.Add((ObjectBounds != null ? ObjectBounds.OnOverall : DefaultOn, ObjectBounds?.GetCrystal()));
                ret.Add((PreviewTransform, null));
                ret.Add((AnimationSound, null));
                ret.Add((Name, null));
                ret.Add((Model != null ? Model.OnOverall : DefaultOn, Model?.GetCrystal()));
                ret.Add((Icons != null ? Icons.OnOverall : DefaultOn, Icons?.GetCrystal()));
                ret.Add((ObjectEffect, null));
                ret.Add((EnchantmentAmount, null));
                ret.Add((Destructible != null ? Destructible.OnOverall : DefaultOn, Destructible?.GetCrystal()));
                ret.Add((EquipmentType, null));
                ret.Add((BlockBashImpactDataSet, null));
                ret.Add((AlternateBlockMaterial, null));
                ret.Add((PickUpSound, null));
                ret.Add((PutDownSound, null));
                ret.Add((Keywords, null));
                ret.Add((Description, null));
                ret.Add((InstanceNaming, null));
                ret.Add((AttachParentSlots, null));
                ret.Add((ObjectTemplates == null ? DefaultOn : !ObjectTemplates.GetCrystal().CopyNothing, ObjectTemplates?.GetCrystal()));
                ret.Add((EmbeddedWeaponMod, null));
                ret.Add((FirstPersonModel != null ? FirstPersonModel.OnOverall : DefaultOn, FirstPersonModel?.GetCrystal()));
                ret.Add((FirstPersonColorRemappingIndex, null));
                ret.Add((MO4F, null));
                ret.Add((Ammo, null));
                ret.Add((Speed, null));
                ret.Add((ReloadSpeed, null));
                ret.Add((Reach, null));
                ret.Add((MinRange, null));
                ret.Add((MaxRange, null));
                ret.Add((AttackDelay, null));
                ret.Add((Unknown, null));
                ret.Add((DamageOutOfRangeMult, null));
                ret.Add((OnHit, null));
                ret.Add((Skill, null));
                ret.Add((Resist, null));
                ret.Add((Flags, null));
                ret.Add((Capacity, null));
                ret.Add((AnimationType, null));
                ret.Add((SecondaryDamage, null));
                ret.Add((Weight, null));
                ret.Add((Value, null));
                ret.Add((BaseDamage, null));
                ret.Add((SoundLevel, null));
                ret.Add((AttackSound, null));
                ret.Add((Attack2dSound, null));
                ret.Add((AttackLoopSound, null));
                ret.Add((AttackFailSound, null));
                ret.Add((IdleSound, null));
                ret.Add((EquipSound, null));
                ret.Add((UnequipSound, null));
                ret.Add((FastEquipSound, null));
                ret.Add((AccuracyBonus, null));
                ret.Add((AnimationAttackSeconds, null));
                ret.Add((Unknown2, null));
                ret.Add((ActionPointCost, null));
                ret.Add((FullPowerSeconds, null));
                ret.Add((MinPowerPerShot, null));
                ret.Add((Stagger, null));
                ret.Add((Unknown3, null));
                ret.Add((ExtraData != null ? ExtraData.OnOverall : DefaultOn, ExtraData?.GetCrystal()));
                ret.Add((CritDamageMult, null));
                ret.Add((CritChargeBonus, null));
                ret.Add((CritEffect, null));
                ret.Add((ImpactDataSet, null));
                ret.Add((NpcAddAmmoList, null));
                ret.Add((AimModel, null));
                ret.Add((Zoom, null));
                ret.Add((Template, null));
                ret.Add((DamageType != null ? DamageType.OnOverall : DefaultOn, DamageType?.GetCrystal()));
                ret.Add((Filter, null));
                ret.Add((MeleeSpeed, null));
                ret.Add((DNAMDataTypeState, null));
                ret.Add((CRDTDataTypeState, null));
            }

            public static implicit operator TranslationMask(bool defaultOn)
            {
                return new TranslationMask(defaultOn: defaultOn, onOverall: defaultOn);
            }

        }
        #endregion

        #region Mutagen
        public static readonly RecordType GrupRecordType = Weapon_Registration.TriggeringRecordType;
        public override IEnumerable<IFormLinkGetter> ContainedFormLinks => WeaponCommon.Instance.GetContainedFormLinks(this);
        public override void RemapLinks(IReadOnlyDictionary<FormKey, FormKey> mapping) => WeaponSetterCommon.Instance.RemapLinks(this, mapping);
        public Weapon(FormKey formKey)
        {
            this.FormKey = formKey;
            CustomCtor();
        }

        private Weapon(
            FormKey formKey,
            GameRelease gameRelease)
        {
            this.FormKey = formKey;
            this.FormVersion = gameRelease.GetDefaultFormVersion()!.Value;
            CustomCtor();
        }

        internal Weapon(
            FormKey formKey,
            ushort formVersion)
        {
            this.FormKey = formKey;
            this.FormVersion = formVersion;
            CustomCtor();
        }

        public Weapon(IFallout4Mod mod)
            : this(mod.GetNextFormKey())
        {
        }

        public Weapon(IFallout4Mod mod, string editorID)
            : this(mod.GetNextFormKey(editorID))
        {
            this.EditorID = editorID;
        }

        public override string ToString()
        {
            return MajorRecordPrinter<Weapon>.ToString(this);
        }

        protected override Type LinkType => typeof(IWeapon);

        public MajorFlag MajorFlags
        {
            get => (MajorFlag)this.MajorRecordFlagsRaw;
            set => this.MajorRecordFlagsRaw = (int)value;
        }
        [Flags]
        public enum DNAMDataType
        {
        }
        [Flags]
        public enum CRDTDataType
        {
        }
        #region Equals and Hash
        public override bool Equals(object? obj)
        {
            if (obj is IFormLinkGetter formLink)
            {
                return formLink.Equals(this);
            }
            if (obj is not IWeaponGetter rhs) return false;
            return ((WeaponCommon)((IWeaponGetter)this).CommonInstance()!).Equals(this, rhs, crystal: null);
        }

        public bool Equals(IWeaponGetter? obj)
        {
            return ((WeaponCommon)((IWeaponGetter)this).CommonInstance()!).Equals(this, obj, crystal: null);
        }

        public override int GetHashCode() => ((WeaponCommon)((IWeaponGetter)this).CommonInstance()!).GetHashCode(this);

        #endregion

        #endregion

        #region Binary Translation
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected override object BinaryWriteTranslator => WeaponBinaryWriteTranslation.Instance;
        void IBinaryItem.WriteToBinary(
            MutagenWriter writer,
            TypedWriteParams? translationParams = null)
        {
            ((WeaponBinaryWriteTranslation)this.BinaryWriteTranslator).Write(
                item: this,
                writer: writer,
                translationParams: translationParams);
        }
        #region Binary Create
        public new static Weapon CreateFromBinary(
            MutagenFrame frame,
            TypedParseParams? translationParams = null)
        {
            var ret = new Weapon();
            ((WeaponSetterCommon)((IWeaponGetter)ret).CommonSetterInstance()!).CopyInFromBinary(
                item: ret,
                frame: frame,
                translationParams: translationParams);
            return ret;
        }

        #endregion

        public static bool TryCreateFromBinary(
            MutagenFrame frame,
            out Weapon item,
            TypedParseParams? translationParams = null)
        {
            var startPos = frame.Position;
            item = CreateFromBinary(
                frame: frame,
                translationParams: translationParams);
            return startPos != frame.Position;
        }
        #endregion

        void IPrintable.ToString(StructuredStringBuilder sb, string? name) => this.ToString(sb, name);

        void IClearable.Clear()
        {
            ((WeaponSetterCommon)((IWeaponGetter)this).CommonSetterInstance()!).Clear(this);
        }

        internal static new Weapon GetNew()
        {
            return new Weapon();
        }

    }
    #endregion

    #region Interface
    public partial interface IWeapon :
        IFallout4MajorRecordInternal,
        IFormLinkContainer,
        IFurnitureAssociation,
        IHarvestTarget,
        IHasIcons,
        IKeyworded<IKeywordGetter>,
        ILoquiObjectSetter<IWeaponInternal>,
        IModeled,
        INamed,
        INamedRequired,
        IObjectBounded,
        IObjectId,
        IScripted,
        IStaticObject,
        ITranslatedNamed,
        ITranslatedNamedRequired,
        IWeaponGetter,
        IWeightValue
    {
        /// <summary>
        /// Aspects: IScripted
        /// </summary>
        new VirtualMachineAdapter? VirtualMachineAdapter { get; set; }
        /// <summary>
        /// Aspects: IObjectBounded
        /// </summary>
        new ObjectBounds ObjectBounds { get; set; }
        new IFormLinkNullable<ITransformGetter> PreviewTransform { get; set; }
        new IFormLinkNullable<IAnimationSoundTagSetGetter> AnimationSound { get; set; }
        /// <summary>
        /// Aspects: INamed, INamedRequired, ITranslatedNamed, ITranslatedNamedRequired
        /// </summary>
        new TranslatedString? Name { get; set; }
        /// <summary>
        /// Aspects: IModeled
        /// </summary>
        new Model? Model { get; set; }
        /// <summary>
        /// Aspects: IHasIcons
        /// </summary>
        new Icons? Icons { get; set; }
        new IFormLinkNullable<IEffectRecordGetter> ObjectEffect { get; set; }
        new UInt16? EnchantmentAmount { get; set; }
        new Destructible? Destructible { get; set; }
        new IFormLinkNullable<IEquipTypeGetter> EquipmentType { get; set; }
        new IFormLinkNullable<IImpactDataSetGetter> BlockBashImpactDataSet { get; set; }
        new IFormLinkNullable<IMaterialTypeGetter> AlternateBlockMaterial { get; set; }
        new IFormLinkNullable<ISoundDescriptorGetter> PickUpSound { get; set; }
        new IFormLinkNullable<ISoundDescriptorGetter> PutDownSound { get; set; }
        /// <summary>
        /// Aspects: IKeyworded&lt;IKeywordGetter&gt;
        /// </summary>
        new ExtendedList<IFormLinkGetter<IKeywordGetter>>? Keywords { get; set; }
        new TranslatedString? Description { get; set; }
        new IFormLinkNullable<IInstanceNamingRuleGetter> InstanceNaming { get; set; }
        new ExtendedList<IFormLinkGetter<IKeywordGetter>>? AttachParentSlots { get; set; }
        new ExtendedList<ObjectTemplate<Weapon.Property>>? ObjectTemplates { get; set; }
        new IFormLinkNullable<IObjectModificationGetter> EmbeddedWeaponMod { get; set; }
        new Model? FirstPersonModel { get; set; }
        new Single? FirstPersonColorRemappingIndex { get; set; }
        new Int32? MO4F { get; set; }
        new IFormLink<IAmmunitionGetter> Ammo { get; set; }
        new Single Speed { get; set; }
        new Single ReloadSpeed { get; set; }
        new Single Reach { get; set; }
        new Single MinRange { get; set; }
        new Single MaxRange { get; set; }
        new Single AttackDelay { get; set; }
        new Single Unknown { get; set; }
        new Single DamageOutOfRangeMult { get; set; }
        new Weapon.HitBehavior OnHit { get; set; }
        new IFormLink<IActorValueInformationGetter> Skill { get; set; }
        new IFormLink<IActorValueInformationGetter> Resist { get; set; }
        new Weapon.Flag Flags { get; set; }
        new UInt16 Capacity { get; set; }
        new Weapon.AnimationTypes AnimationType { get; set; }
        new Single SecondaryDamage { get; set; }
        new Single Weight { get; set; }
        new UInt32 Value { get; set; }
        new UInt16 BaseDamage { get; set; }
        new SoundLevel SoundLevel { get; set; }
        new IFormLink<ISoundDescriptorGetter> AttackSound { get; set; }
        new IFormLink<ISoundDescriptorGetter> Attack2dSound { get; set; }
        new IFormLink<ISoundDescriptorGetter> AttackLoopSound { get; set; }
        new IFormLink<ISoundDescriptorGetter> AttackFailSound { get; set; }
        new IFormLink<ISoundDescriptorGetter> IdleSound { get; set; }
        new IFormLink<ISoundDescriptorGetter> EquipSound { get; set; }
        new IFormLink<ISoundDescriptorGetter> UnequipSound { get; set; }
        new IFormLink<ISoundDescriptorGetter> FastEquipSound { get; set; }
        new Byte AccuracyBonus { get; set; }
        new Single AnimationAttackSeconds { get; set; }
        new UInt16 Unknown2 { get; set; }
        new Single ActionPointCost { get; set; }
        new Single FullPowerSeconds { get; set; }
        new Single MinPowerPerShot { get; set; }
        new Stagger Stagger { get; set; }
        new Int32 Unknown3 { get; set; }
        new WeaponExtraData? ExtraData { get; set; }
        new Single CritDamageMult { get; set; }
        new Single CritChargeBonus { get; set; }
        new IFormLink<ISpellGetter> CritEffect { get; set; }
        new IFormLinkNullable<IImpactDataSetGetter> ImpactDataSet { get; set; }
        new IFormLinkNullable<ILeveledItemGetter> NpcAddAmmoList { get; set; }
        new IFormLinkNullable<IAimModelGetter> AimModel { get; set; }
        new IFormLinkNullable<IZoomGetter> Zoom { get; set; }
        new IFormLinkNullable<IWeaponGetter> Template { get; set; }
        new WeaponDamageType? DamageType { get; set; }
        new String? Filter { get; set; }
        new Weapon.MeleeSpeeds? MeleeSpeed { get; set; }
        new Weapon.DNAMDataType DNAMDataTypeState { get; set; }
        new Weapon.CRDTDataType CRDTDataTypeState { get; set; }
        #region Mutagen
        new Weapon.MajorFlag MajorFlags { get; set; }
        #endregion

    }

    public partial interface IWeaponInternal :
        IFallout4MajorRecordInternal,
        IWeapon,
        IWeaponGetter
    {
    }

    [AssociatedRecordTypesAttribute(Mutagen.Bethesda.Fallout4.Internals.RecordTypeInts.WEAP)]
    public partial interface IWeaponGetter :
        IFallout4MajorRecordGetter,
        IBinaryItem,
        IFormLinkContainerGetter,
        IFurnitureAssociationGetter,
        IHarvestTargetGetter,
        IHasIconsGetter,
        IKeywordedGetter<IKeywordGetter>,
        ILoquiObject<IWeaponGetter>,
        IMapsToGetter<IWeaponGetter>,
        IModeledGetter,
        INamedGetter,
        INamedRequiredGetter,
        IObjectBoundedGetter,
        IObjectIdGetter,
        IScriptedGetter,
        IStaticObjectGetter,
        ITranslatedNamedGetter,
        ITranslatedNamedRequiredGetter,
        IWeightValueGetter
    {
        static new ILoquiRegistration StaticRegistration => Weapon_Registration.Instance;
        #region VirtualMachineAdapter
        /// <summary>
        /// Aspects: IScriptedGetter
        /// </summary>
        IVirtualMachineAdapterGetter? VirtualMachineAdapter { get; }
        #endregion
        #region ObjectBounds
        /// <summary>
        /// Aspects: IObjectBoundedGetter
        /// </summary>
        IObjectBoundsGetter ObjectBounds { get; }
        #endregion
        IFormLinkNullableGetter<ITransformGetter> PreviewTransform { get; }
        IFormLinkNullableGetter<IAnimationSoundTagSetGetter> AnimationSound { get; }
        #region Name
        /// <summary>
        /// Aspects: INamedGetter, INamedRequiredGetter, ITranslatedNamedGetter, ITranslatedNamedRequiredGetter
        /// </summary>
        ITranslatedStringGetter? Name { get; }
        #endregion
        #region Model
        /// <summary>
        /// Aspects: IModeledGetter
        /// </summary>
        IModelGetter? Model { get; }
        #endregion
        #region Icons
        /// <summary>
        /// Aspects: IHasIconsGetter
        /// </summary>
        IIconsGetter? Icons { get; }
        #endregion
        IFormLinkNullableGetter<IEffectRecordGetter> ObjectEffect { get; }
        UInt16? EnchantmentAmount { get; }
        IDestructibleGetter? Destructible { get; }
        IFormLinkNullableGetter<IEquipTypeGetter> EquipmentType { get; }
        IFormLinkNullableGetter<IImpactDataSetGetter> BlockBashImpactDataSet { get; }
        IFormLinkNullableGetter<IMaterialTypeGetter> AlternateBlockMaterial { get; }
        IFormLinkNullableGetter<ISoundDescriptorGetter> PickUpSound { get; }
        IFormLinkNullableGetter<ISoundDescriptorGetter> PutDownSound { get; }
        #region Keywords
        /// <summary>
        /// Aspects: IKeywordedGetter&lt;IKeywordGetter&gt;
        /// </summary>
        IReadOnlyList<IFormLinkGetter<IKeywordGetter>>? Keywords { get; }
        #endregion
        ITranslatedStringGetter? Description { get; }
        IFormLinkNullableGetter<IInstanceNamingRuleGetter> InstanceNaming { get; }
        IReadOnlyList<IFormLinkGetter<IKeywordGetter>>? AttachParentSlots { get; }
        IReadOnlyList<IObjectTemplateGetter<Weapon.Property>>? ObjectTemplates { get; }
        IFormLinkNullableGetter<IObjectModificationGetter> EmbeddedWeaponMod { get; }
        IModelGetter? FirstPersonModel { get; }
        Single? FirstPersonColorRemappingIndex { get; }
        Int32? MO4F { get; }
        IFormLinkGetter<IAmmunitionGetter> Ammo { get; }
        Single Speed { get; }
        Single ReloadSpeed { get; }
        Single Reach { get; }
        Single MinRange { get; }
        Single MaxRange { get; }
        Single AttackDelay { get; }
        Single Unknown { get; }
        Single DamageOutOfRangeMult { get; }
        Weapon.HitBehavior OnHit { get; }
        IFormLinkGetter<IActorValueInformationGetter> Skill { get; }
        IFormLinkGetter<IActorValueInformationGetter> Resist { get; }
        Weapon.Flag Flags { get; }
        UInt16 Capacity { get; }
        Weapon.AnimationTypes AnimationType { get; }
        Single SecondaryDamage { get; }
        Single Weight { get; }
        UInt32 Value { get; }
        UInt16 BaseDamage { get; }
        SoundLevel SoundLevel { get; }
        IFormLinkGetter<ISoundDescriptorGetter> AttackSound { get; }
        IFormLinkGetter<ISoundDescriptorGetter> Attack2dSound { get; }
        IFormLinkGetter<ISoundDescriptorGetter> AttackLoopSound { get; }
        IFormLinkGetter<ISoundDescriptorGetter> AttackFailSound { get; }
        IFormLinkGetter<ISoundDescriptorGetter> IdleSound { get; }
        IFormLinkGetter<ISoundDescriptorGetter> EquipSound { get; }
        IFormLinkGetter<ISoundDescriptorGetter> UnequipSound { get; }
        IFormLinkGetter<ISoundDescriptorGetter> FastEquipSound { get; }
        Byte AccuracyBonus { get; }
        Single AnimationAttackSeconds { get; }
        UInt16 Unknown2 { get; }
        Single ActionPointCost { get; }
        Single FullPowerSeconds { get; }
        Single MinPowerPerShot { get; }
        Stagger Stagger { get; }
        Int32 Unknown3 { get; }
        IWeaponExtraDataGetter? ExtraData { get; }
        Single CritDamageMult { get; }
        Single CritChargeBonus { get; }
        IFormLinkGetter<ISpellGetter> CritEffect { get; }
        IFormLinkNullableGetter<IImpactDataSetGetter> ImpactDataSet { get; }
        IFormLinkNullableGetter<ILeveledItemGetter> NpcAddAmmoList { get; }
        IFormLinkNullableGetter<IAimModelGetter> AimModel { get; }
        IFormLinkNullableGetter<IZoomGetter> Zoom { get; }
        IFormLinkNullableGetter<IWeaponGetter> Template { get; }
        IWeaponDamageTypeGetter? DamageType { get; }
        String? Filter { get; }
        Weapon.MeleeSpeeds? MeleeSpeed { get; }
        Weapon.DNAMDataType DNAMDataTypeState { get; }
        Weapon.CRDTDataType CRDTDataTypeState { get; }

        #region Mutagen
        Weapon.MajorFlag MajorFlags { get; }
        #endregion

    }

    #endregion

    #region Common MixIn
    public static partial class WeaponMixIn
    {
        public static void Clear(this IWeaponInternal item)
        {
            ((WeaponSetterCommon)((IWeaponGetter)item).CommonSetterInstance()!).Clear(item: item);
        }

        public static Weapon.Mask<bool> GetEqualsMask(
            this IWeaponGetter item,
            IWeaponGetter rhs,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            return ((WeaponCommon)((IWeaponGetter)item).CommonInstance()!).GetEqualsMask(
                item: item,
                rhs: rhs,
                include: include);
        }

        public static string ToString(
            this IWeaponGetter item,
            string? name = null,
            Weapon.Mask<bool>? printMask = null)
        {
            return ((WeaponCommon)((IWeaponGetter)item).CommonInstance()!).ToString(
                item: item,
                name: name,
                printMask: printMask);
        }

        public static void ToString(
            this IWeaponGetter item,
            StructuredStringBuilder sb,
            string? name = null,
            Weapon.Mask<bool>? printMask = null)
        {
            ((WeaponCommon)((IWeaponGetter)item).CommonInstance()!).ToString(
                item: item,
                sb: sb,
                name: name,
                printMask: printMask);
        }

        public static bool Equals(
            this IWeaponGetter item,
            IWeaponGetter rhs,
            Weapon.TranslationMask? equalsMask = null)
        {
            return ((WeaponCommon)((IWeaponGetter)item).CommonInstance()!).Equals(
                lhs: item,
                rhs: rhs,
                crystal: equalsMask?.GetCrystal());
        }

        public static void DeepCopyIn(
            this IWeaponInternal lhs,
            IWeaponGetter rhs,
            out Weapon.ErrorMask errorMask,
            Weapon.TranslationMask? copyMask = null)
        {
            var errorMaskBuilder = new ErrorMaskBuilder();
            ((WeaponSetterTranslationCommon)((IWeaponGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: errorMaskBuilder,
                copyMask: copyMask?.GetCrystal(),
                deepCopy: false);
            errorMask = Weapon.ErrorMask.Factory(errorMaskBuilder);
        }

        public static void DeepCopyIn(
            this IWeaponInternal lhs,
            IWeaponGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask)
        {
            ((WeaponSetterTranslationCommon)((IWeaponGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: false);
        }

        public static Weapon DeepCopy(
            this IWeaponGetter item,
            Weapon.TranslationMask? copyMask = null)
        {
            return ((WeaponSetterTranslationCommon)((IWeaponGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask);
        }

        public static Weapon DeepCopy(
            this IWeaponGetter item,
            out Weapon.ErrorMask errorMask,
            Weapon.TranslationMask? copyMask = null)
        {
            return ((WeaponSetterTranslationCommon)((IWeaponGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask,
                errorMask: out errorMask);
        }

        public static Weapon DeepCopy(
            this IWeaponGetter item,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask = null)
        {
            return ((WeaponSetterTranslationCommon)((IWeaponGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask,
                errorMask: errorMask);
        }

        #region Mutagen
        public static Weapon Duplicate(
            this IWeaponGetter item,
            FormKey formKey,
            Weapon.TranslationMask? copyMask = null)
        {
            return ((WeaponCommon)((IWeaponGetter)item).CommonInstance()!).Duplicate(
                item: item,
                formKey: formKey,
                copyMask: copyMask?.GetCrystal());
        }

        #endregion

        #region Binary Translation
        public static void CopyInFromBinary(
            this IWeaponInternal item,
            MutagenFrame frame,
            TypedParseParams? translationParams = null)
        {
            ((WeaponSetterCommon)((IWeaponGetter)item).CommonSetterInstance()!).CopyInFromBinary(
                item: item,
                frame: frame,
                translationParams: translationParams);
        }

        #endregion

    }
    #endregion

}

namespace Mutagen.Bethesda.Fallout4
{
    #region Field Index
    internal enum Weapon_FieldIndex
    {
        MajorRecordFlagsRaw = 0,
        FormKey = 1,
        VersionControl = 2,
        EditorID = 3,
        FormVersion = 4,
        Version2 = 5,
        VirtualMachineAdapter = 6,
        ObjectBounds = 7,
        PreviewTransform = 8,
        AnimationSound = 9,
        Name = 10,
        Model = 11,
        Icons = 12,
        ObjectEffect = 13,
        EnchantmentAmount = 14,
        Destructible = 15,
        EquipmentType = 16,
        BlockBashImpactDataSet = 17,
        AlternateBlockMaterial = 18,
        PickUpSound = 19,
        PutDownSound = 20,
        Keywords = 21,
        Description = 22,
        InstanceNaming = 23,
        AttachParentSlots = 24,
        ObjectTemplates = 25,
        EmbeddedWeaponMod = 26,
        FirstPersonModel = 27,
        FirstPersonColorRemappingIndex = 28,
        MO4F = 29,
        Ammo = 30,
        Speed = 31,
        ReloadSpeed = 32,
        Reach = 33,
        MinRange = 34,
        MaxRange = 35,
        AttackDelay = 36,
        Unknown = 37,
        DamageOutOfRangeMult = 38,
        OnHit = 39,
        Skill = 40,
        Resist = 41,
        Flags = 42,
        Capacity = 43,
        AnimationType = 44,
        SecondaryDamage = 45,
        Weight = 46,
        Value = 47,
        BaseDamage = 48,
        SoundLevel = 49,
        AttackSound = 50,
        Attack2dSound = 51,
        AttackLoopSound = 52,
        AttackFailSound = 53,
        IdleSound = 54,
        EquipSound = 55,
        UnequipSound = 56,
        FastEquipSound = 57,
        AccuracyBonus = 58,
        AnimationAttackSeconds = 59,
        Unknown2 = 60,
        ActionPointCost = 61,
        FullPowerSeconds = 62,
        MinPowerPerShot = 63,
        Stagger = 64,
        Unknown3 = 65,
        ExtraData = 66,
        CritDamageMult = 67,
        CritChargeBonus = 68,
        CritEffect = 69,
        ImpactDataSet = 70,
        NpcAddAmmoList = 71,
        AimModel = 72,
        Zoom = 73,
        Template = 74,
        DamageType = 75,
        Filter = 76,
        MeleeSpeed = 77,
        DNAMDataTypeState = 78,
        CRDTDataTypeState = 79,
    }
    #endregion

    #region Registration
    internal partial class Weapon_Registration : ILoquiRegistration
    {
        public static readonly Weapon_Registration Instance = new Weapon_Registration();

        public static ProtocolKey ProtocolKey => ProtocolDefinition_Fallout4.ProtocolKey;

        public static readonly ObjectKey ObjectKey = new ObjectKey(
            protocolKey: ProtocolDefinition_Fallout4.ProtocolKey,
            msgID: 286,
            version: 0);

        public const string GUID = "ea1189a0-716d-4099-ad06-721ccd313caa";

        public const ushort AdditionalFieldCount = 74;

        public const ushort FieldCount = 80;

        public static readonly Type MaskType = typeof(Weapon.Mask<>);

        public static readonly Type ErrorMaskType = typeof(Weapon.ErrorMask);

        public static readonly Type ClassType = typeof(Weapon);

        public static readonly Type GetterType = typeof(IWeaponGetter);

        public static readonly Type? InternalGetterType = null;

        public static readonly Type SetterType = typeof(IWeapon);

        public static readonly Type? InternalSetterType = typeof(IWeaponInternal);

        public const string FullName = "Mutagen.Bethesda.Fallout4.Weapon";

        public const string Name = "Weapon";

        public const string Namespace = "Mutagen.Bethesda.Fallout4";

        public const byte GenericCount = 0;

        public static readonly Type? GenericRegistrationType = null;

        public static readonly RecordType TriggeringRecordType = RecordTypes.WEAP;
        public static RecordTriggerSpecs TriggerSpecs => _recordSpecs.Value;
        private static readonly Lazy<RecordTriggerSpecs> _recordSpecs = new Lazy<RecordTriggerSpecs>(() =>
        {
            var triggers = RecordCollection.Factory(RecordTypes.WEAP);
            var all = RecordCollection.Factory(
                RecordTypes.WEAP,
                RecordTypes.VMAD,
                RecordTypes.OBND,
                RecordTypes.PTRN,
                RecordTypes.STCP,
                RecordTypes.FULL,
                RecordTypes.MODL,
                RecordTypes.ICON,
                RecordTypes.MICO,
                RecordTypes.EITM,
                RecordTypes.EAMT,
                RecordTypes.DEST,
                RecordTypes.DAMC,
                RecordTypes.DSTD,
                RecordTypes.DSTA,
                RecordTypes.DMDL,
                RecordTypes.ETYP,
                RecordTypes.BIDS,
                RecordTypes.BAMT,
                RecordTypes.YNAM,
                RecordTypes.ZNAM,
                RecordTypes.KWDA,
                RecordTypes.KSIZ,
                RecordTypes.DESC,
                RecordTypes.INRD,
                RecordTypes.APPR,
                RecordTypes.OBTE,
                RecordTypes.OBTF,
                RecordTypes.OBTS,
                RecordTypes.STOP,
                RecordTypes.NNAM,
                RecordTypes.MOD4,
                RecordTypes.MO4T,
                RecordTypes.MO4S,
                RecordTypes.MO4C,
                RecordTypes.MO4F,
                RecordTypes.DNAM,
                RecordTypes.FNAM,
                RecordTypes.CRDT,
                RecordTypes.INAM,
                RecordTypes.LNAM,
                RecordTypes.WAMD,
                RecordTypes.WZMD,
                RecordTypes.CNAM,
                RecordTypes.DAMA,
                RecordTypes.FLTR,
                RecordTypes.MASE);
            return new RecordTriggerSpecs(allRecordTypes: all, triggeringRecordTypes: triggers);
        });
        public static RecordTypeConverter FirstPersonModelConverter = new RecordTypeConverter(
            new KeyValuePair<RecordType, RecordType>(
                RecordTypes.MODL,
                RecordTypes.MOD4),
            new KeyValuePair<RecordType, RecordType>(
                RecordTypes.MODT,
                RecordTypes.MO4T),
            new KeyValuePair<RecordType, RecordType>(
                RecordTypes.MODS,
                RecordTypes.MO4S));
        public static readonly Type BinaryWriteTranslation = typeof(WeaponBinaryWriteTranslation);
        #region Interface
        ProtocolKey ILoquiRegistration.ProtocolKey => ProtocolKey;
        ObjectKey ILoquiRegistration.ObjectKey => ObjectKey;
        string ILoquiRegistration.GUID => GUID;
        ushort ILoquiRegistration.FieldCount => FieldCount;
        ushort ILoquiRegistration.AdditionalFieldCount => AdditionalFieldCount;
        Type ILoquiRegistration.MaskType => MaskType;
        Type ILoquiRegistration.ErrorMaskType => ErrorMaskType;
        Type ILoquiRegistration.ClassType => ClassType;
        Type ILoquiRegistration.SetterType => SetterType;
        Type? ILoquiRegistration.InternalSetterType => InternalSetterType;
        Type ILoquiRegistration.GetterType => GetterType;
        Type? ILoquiRegistration.InternalGetterType => InternalGetterType;
        string ILoquiRegistration.FullName => FullName;
        string ILoquiRegistration.Name => Name;
        string ILoquiRegistration.Namespace => Namespace;
        byte ILoquiRegistration.GenericCount => GenericCount;
        Type? ILoquiRegistration.GenericRegistrationType => GenericRegistrationType;
        ushort? ILoquiRegistration.GetNameIndex(StringCaseAgnostic name) => throw new NotImplementedException();
        bool ILoquiRegistration.GetNthIsEnumerable(ushort index) => throw new NotImplementedException();
        bool ILoquiRegistration.GetNthIsLoqui(ushort index) => throw new NotImplementedException();
        bool ILoquiRegistration.GetNthIsSingleton(ushort index) => throw new NotImplementedException();
        string ILoquiRegistration.GetNthName(ushort index) => throw new NotImplementedException();
        bool ILoquiRegistration.IsNthDerivative(ushort index) => throw new NotImplementedException();
        bool ILoquiRegistration.IsProtected(ushort index) => throw new NotImplementedException();
        Type ILoquiRegistration.GetNthType(ushort index) => throw new NotImplementedException();
        #endregion

    }
    #endregion

    #region Common
    internal partial class WeaponSetterCommon : Fallout4MajorRecordSetterCommon
    {
        public new static readonly WeaponSetterCommon Instance = new WeaponSetterCommon();

        partial void ClearPartial();
        
        public void Clear(IWeaponInternal item)
        {
            ClearPartial();
            item.VirtualMachineAdapter = null;
            item.ObjectBounds.Clear();
            item.PreviewTransform.Clear();
            item.AnimationSound.Clear();
            item.Name = default;
            item.Model = null;
            item.Icons = null;
            item.ObjectEffect.Clear();
            item.EnchantmentAmount = default;
            item.Destructible = null;
            item.EquipmentType.Clear();
            item.BlockBashImpactDataSet.Clear();
            item.AlternateBlockMaterial.Clear();
            item.PickUpSound.Clear();
            item.PutDownSound.Clear();
            item.Keywords = null;
            item.Description = default;
            item.InstanceNaming.Clear();
            item.AttachParentSlots = null;
            item.ObjectTemplates = null;
            item.EmbeddedWeaponMod.Clear();
            item.FirstPersonModel = null;
            item.FirstPersonColorRemappingIndex = default;
            item.MO4F = default;
            item.Ammo.Clear();
            item.Speed = default;
            item.ReloadSpeed = default;
            item.Reach = default;
            item.MinRange = default;
            item.MaxRange = default;
            item.AttackDelay = default;
            item.Unknown = default;
            item.DamageOutOfRangeMult = default;
            item.OnHit = default;
            item.Skill.Clear();
            item.Resist.Clear();
            item.Flags = default;
            item.Capacity = default;
            item.AnimationType = default;
            item.SecondaryDamage = default;
            item.Weight = default;
            item.Value = default;
            item.BaseDamage = default;
            item.SoundLevel = default;
            item.AttackSound.Clear();
            item.Attack2dSound.Clear();
            item.AttackLoopSound.Clear();
            item.AttackFailSound.Clear();
            item.IdleSound.Clear();
            item.EquipSound.Clear();
            item.UnequipSound.Clear();
            item.FastEquipSound.Clear();
            item.AccuracyBonus = default;
            item.AnimationAttackSeconds = default;
            item.Unknown2 = default;
            item.ActionPointCost = default;
            item.FullPowerSeconds = default;
            item.MinPowerPerShot = default;
            item.Stagger = default;
            item.Unknown3 = default;
            item.ExtraData = null;
            item.CritDamageMult = default;
            item.CritChargeBonus = default;
            item.CritEffect.Clear();
            item.ImpactDataSet.Clear();
            item.NpcAddAmmoList.Clear();
            item.AimModel.Clear();
            item.Zoom.Clear();
            item.Template.Clear();
            item.DamageType = null;
            item.Filter = default;
            item.MeleeSpeed = default;
            item.DNAMDataTypeState = default;
            item.CRDTDataTypeState = default;
            base.Clear(item);
        }
        
        public override void Clear(IFallout4MajorRecordInternal item)
        {
            Clear(item: (IWeaponInternal)item);
        }
        
        public override void Clear(IMajorRecordInternal item)
        {
            Clear(item: (IWeaponInternal)item);
        }
        
        #region Mutagen
        public void RemapLinks(IWeapon obj, IReadOnlyDictionary<FormKey, FormKey> mapping)
        {
            base.RemapLinks(obj, mapping);
            obj.VirtualMachineAdapter?.RemapLinks(mapping);
            obj.PreviewTransform.Relink(mapping);
            obj.AnimationSound.Relink(mapping);
            obj.Model?.RemapLinks(mapping);
            obj.ObjectEffect.Relink(mapping);
            obj.Destructible?.RemapLinks(mapping);
            obj.EquipmentType.Relink(mapping);
            obj.BlockBashImpactDataSet.Relink(mapping);
            obj.AlternateBlockMaterial.Relink(mapping);
            obj.PickUpSound.Relink(mapping);
            obj.PutDownSound.Relink(mapping);
            obj.Keywords?.RemapLinks(mapping);
            obj.InstanceNaming.Relink(mapping);
            obj.AttachParentSlots?.RemapLinks(mapping);
            obj.ObjectTemplates?.RemapLinks(mapping);
            obj.EmbeddedWeaponMod.Relink(mapping);
            obj.FirstPersonModel?.RemapLinks(mapping);
            obj.Ammo.Relink(mapping);
            obj.Skill.Relink(mapping);
            obj.Resist.Relink(mapping);
            obj.AttackSound.Relink(mapping);
            obj.Attack2dSound.Relink(mapping);
            obj.AttackLoopSound.Relink(mapping);
            obj.AttackFailSound.Relink(mapping);
            obj.IdleSound.Relink(mapping);
            obj.EquipSound.Relink(mapping);
            obj.UnequipSound.Relink(mapping);
            obj.FastEquipSound.Relink(mapping);
            obj.ExtraData?.RemapLinks(mapping);
            obj.CritEffect.Relink(mapping);
            obj.ImpactDataSet.Relink(mapping);
            obj.NpcAddAmmoList.Relink(mapping);
            obj.AimModel.Relink(mapping);
            obj.Zoom.Relink(mapping);
            obj.Template.Relink(mapping);
            obj.DamageType?.RemapLinks(mapping);
        }
        
        #endregion
        
        #region Binary Translation
        public virtual void CopyInFromBinary(
            IWeaponInternal item,
            MutagenFrame frame,
            TypedParseParams? translationParams = null)
        {
            PluginUtilityTranslation.MajorRecordParse<IWeaponInternal>(
                record: item,
                frame: frame,
                translationParams: translationParams,
                fillStructs: WeaponBinaryCreateTranslation.FillBinaryStructs,
                fillTyped: WeaponBinaryCreateTranslation.FillBinaryRecordTypes);
        }
        
        public override void CopyInFromBinary(
            IFallout4MajorRecordInternal item,
            MutagenFrame frame,
            TypedParseParams? translationParams = null)
        {
            CopyInFromBinary(
                item: (Weapon)item,
                frame: frame,
                translationParams: translationParams);
        }
        
        public override void CopyInFromBinary(
            IMajorRecordInternal item,
            MutagenFrame frame,
            TypedParseParams? translationParams = null)
        {
            CopyInFromBinary(
                item: (Weapon)item,
                frame: frame,
                translationParams: translationParams);
        }
        
        #endregion
        
    }
    internal partial class WeaponCommon : Fallout4MajorRecordCommon
    {
        public new static readonly WeaponCommon Instance = new WeaponCommon();

        public Weapon.Mask<bool> GetEqualsMask(
            IWeaponGetter item,
            IWeaponGetter rhs,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            var ret = new Weapon.Mask<bool>(false);
            ((WeaponCommon)((IWeaponGetter)item).CommonInstance()!).FillEqualsMask(
                item: item,
                rhs: rhs,
                ret: ret,
                include: include);
            return ret;
        }
        
        public void FillEqualsMask(
            IWeaponGetter item,
            IWeaponGetter rhs,
            Weapon.Mask<bool> ret,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            if (rhs == null) return;
            ret.VirtualMachineAdapter = EqualsMaskHelper.EqualsHelper(
                item.VirtualMachineAdapter,
                rhs.VirtualMachineAdapter,
                (loqLhs, loqRhs, incl) => loqLhs.GetEqualsMask(loqRhs, incl),
                include);
            ret.ObjectBounds = MaskItemExt.Factory(item.ObjectBounds.GetEqualsMask(rhs.ObjectBounds, include), include);
            ret.PreviewTransform = item.PreviewTransform.Equals(rhs.PreviewTransform);
            ret.AnimationSound = item.AnimationSound.Equals(rhs.AnimationSound);
            ret.Name = object.Equals(item.Name, rhs.Name);
            ret.Model = EqualsMaskHelper.EqualsHelper(
                item.Model,
                rhs.Model,
                (loqLhs, loqRhs, incl) => loqLhs.GetEqualsMask(loqRhs, incl),
                include);
            ret.Icons = EqualsMaskHelper.EqualsHelper(
                item.Icons,
                rhs.Icons,
                (loqLhs, loqRhs, incl) => loqLhs.GetEqualsMask(loqRhs, incl),
                include);
            ret.ObjectEffect = item.ObjectEffect.Equals(rhs.ObjectEffect);
            ret.EnchantmentAmount = item.EnchantmentAmount == rhs.EnchantmentAmount;
            ret.Destructible = EqualsMaskHelper.EqualsHelper(
                item.Destructible,
                rhs.Destructible,
                (loqLhs, loqRhs, incl) => loqLhs.GetEqualsMask(loqRhs, incl),
                include);
            ret.EquipmentType = item.EquipmentType.Equals(rhs.EquipmentType);
            ret.BlockBashImpactDataSet = item.BlockBashImpactDataSet.Equals(rhs.BlockBashImpactDataSet);
            ret.AlternateBlockMaterial = item.AlternateBlockMaterial.Equals(rhs.AlternateBlockMaterial);
            ret.PickUpSound = item.PickUpSound.Equals(rhs.PickUpSound);
            ret.PutDownSound = item.PutDownSound.Equals(rhs.PutDownSound);
            ret.Keywords = item.Keywords.CollectionEqualsHelper(
                rhs.Keywords,
                (l, r) => object.Equals(l, r),
                include);
            ret.Description = object.Equals(item.Description, rhs.Description);
            ret.InstanceNaming = item.InstanceNaming.Equals(rhs.InstanceNaming);
            ret.AttachParentSlots = item.AttachParentSlots.CollectionEqualsHelper(
                rhs.AttachParentSlots,
                (l, r) => object.Equals(l, r),
                include);
            ret.ObjectTemplates = item.ObjectTemplates.CollectionEqualsHelper(
                rhs.ObjectTemplates,
                (loqLhs, loqRhs) => loqLhs.GetEqualsMask(loqRhs, include),
                include);
            ret.EmbeddedWeaponMod = item.EmbeddedWeaponMod.Equals(rhs.EmbeddedWeaponMod);
            ret.FirstPersonModel = EqualsMaskHelper.EqualsHelper(
                item.FirstPersonModel,
                rhs.FirstPersonModel,
                (loqLhs, loqRhs, incl) => loqLhs.GetEqualsMask(loqRhs, incl),
                include);
            ret.FirstPersonColorRemappingIndex = item.FirstPersonColorRemappingIndex.EqualsWithin(rhs.FirstPersonColorRemappingIndex);
            ret.MO4F = item.MO4F == rhs.MO4F;
            ret.Ammo = item.Ammo.Equals(rhs.Ammo);
            ret.Speed = item.Speed.EqualsWithin(rhs.Speed);
            ret.ReloadSpeed = item.ReloadSpeed.EqualsWithin(rhs.ReloadSpeed);
            ret.Reach = item.Reach.EqualsWithin(rhs.Reach);
            ret.MinRange = item.MinRange.EqualsWithin(rhs.MinRange);
            ret.MaxRange = item.MaxRange.EqualsWithin(rhs.MaxRange);
            ret.AttackDelay = item.AttackDelay.EqualsWithin(rhs.AttackDelay);
            ret.Unknown = item.Unknown.EqualsWithin(rhs.Unknown);
            ret.DamageOutOfRangeMult = item.DamageOutOfRangeMult.EqualsWithin(rhs.DamageOutOfRangeMult);
            ret.OnHit = item.OnHit == rhs.OnHit;
            ret.Skill = item.Skill.Equals(rhs.Skill);
            ret.Resist = item.Resist.Equals(rhs.Resist);
            ret.Flags = item.Flags == rhs.Flags;
            ret.Capacity = item.Capacity == rhs.Capacity;
            ret.AnimationType = item.AnimationType == rhs.AnimationType;
            ret.SecondaryDamage = item.SecondaryDamage.EqualsWithin(rhs.SecondaryDamage);
            ret.Weight = item.Weight.EqualsWithin(rhs.Weight);
            ret.Value = item.Value == rhs.Value;
            ret.BaseDamage = item.BaseDamage == rhs.BaseDamage;
            ret.SoundLevel = item.SoundLevel == rhs.SoundLevel;
            ret.AttackSound = item.AttackSound.Equals(rhs.AttackSound);
            ret.Attack2dSound = item.Attack2dSound.Equals(rhs.Attack2dSound);
            ret.AttackLoopSound = item.AttackLoopSound.Equals(rhs.AttackLoopSound);
            ret.AttackFailSound = item.AttackFailSound.Equals(rhs.AttackFailSound);
            ret.IdleSound = item.IdleSound.Equals(rhs.IdleSound);
            ret.EquipSound = item.EquipSound.Equals(rhs.EquipSound);
            ret.UnequipSound = item.UnequipSound.Equals(rhs.UnequipSound);
            ret.FastEquipSound = item.FastEquipSound.Equals(rhs.FastEquipSound);
            ret.AccuracyBonus = item.AccuracyBonus == rhs.AccuracyBonus;
            ret.AnimationAttackSeconds = item.AnimationAttackSeconds.EqualsWithin(rhs.AnimationAttackSeconds);
            ret.Unknown2 = item.Unknown2 == rhs.Unknown2;
            ret.ActionPointCost = item.ActionPointCost.EqualsWithin(rhs.ActionPointCost);
            ret.FullPowerSeconds = item.FullPowerSeconds.EqualsWithin(rhs.FullPowerSeconds);
            ret.MinPowerPerShot = item.MinPowerPerShot.EqualsWithin(rhs.MinPowerPerShot);
            ret.Stagger = item.Stagger == rhs.Stagger;
            ret.Unknown3 = item.Unknown3 == rhs.Unknown3;
            ret.ExtraData = EqualsMaskHelper.EqualsHelper(
                item.ExtraData,
                rhs.ExtraData,
                (loqLhs, loqRhs, incl) => loqLhs.GetEqualsMask(loqRhs, incl),
                include);
            ret.CritDamageMult = item.CritDamageMult.EqualsWithin(rhs.CritDamageMult);
            ret.CritChargeBonus = item.CritChargeBonus.EqualsWithin(rhs.CritChargeBonus);
            ret.CritEffect = item.CritEffect.Equals(rhs.CritEffect);
            ret.ImpactDataSet = item.ImpactDataSet.Equals(rhs.ImpactDataSet);
            ret.NpcAddAmmoList = item.NpcAddAmmoList.Equals(rhs.NpcAddAmmoList);
            ret.AimModel = item.AimModel.Equals(rhs.AimModel);
            ret.Zoom = item.Zoom.Equals(rhs.Zoom);
            ret.Template = item.Template.Equals(rhs.Template);
            ret.DamageType = EqualsMaskHelper.EqualsHelper(
                item.DamageType,
                rhs.DamageType,
                (loqLhs, loqRhs, incl) => loqLhs.GetEqualsMask(loqRhs, incl),
                include);
            ret.Filter = string.Equals(item.Filter, rhs.Filter);
            ret.MeleeSpeed = item.MeleeSpeed == rhs.MeleeSpeed;
            ret.DNAMDataTypeState = item.DNAMDataTypeState == rhs.DNAMDataTypeState;
            ret.CRDTDataTypeState = item.CRDTDataTypeState == rhs.CRDTDataTypeState;
            base.FillEqualsMask(item, rhs, ret, include);
        }
        
        public string ToString(
            IWeaponGetter item,
            string? name = null,
            Weapon.Mask<bool>? printMask = null)
        {
            var sb = new StructuredStringBuilder();
            ToString(
                item: item,
                sb: sb,
                name: name,
                printMask: printMask);
            return sb.ToString();
        }
        
        public void ToString(
            IWeaponGetter item,
            StructuredStringBuilder sb,
            string? name = null,
            Weapon.Mask<bool>? printMask = null)
        {
            if (name == null)
            {
                sb.AppendLine($"Weapon =>");
            }
            else
            {
                sb.AppendLine($"{name} (Weapon) =>");
            }
            sb.AppendLine("[");
            using (sb.IncreaseDepth())
            {
                ToStringFields(
                    item: item,
                    sb: sb,
                    printMask: printMask);
            }
            sb.AppendLine("]");
        }
        
        protected static void ToStringFields(
            IWeaponGetter item,
            StructuredStringBuilder sb,
            Weapon.Mask<bool>? printMask = null)
        {
            Fallout4MajorRecordCommon.ToStringFields(
                item: item,
                sb: sb,
                printMask: printMask);
            if ((printMask?.VirtualMachineAdapter?.Overall ?? true)
                && item.VirtualMachineAdapter is {} VirtualMachineAdapterItem)
            {
                VirtualMachineAdapterItem?.ToString(sb, "VirtualMachineAdapter");
            }
            if (printMask?.ObjectBounds?.Overall ?? true)
            {
                item.ObjectBounds?.ToString(sb, "ObjectBounds");
            }
            if (printMask?.PreviewTransform ?? true)
            {
                sb.AppendItem(item.PreviewTransform.FormKeyNullable, "PreviewTransform");
            }
            if (printMask?.AnimationSound ?? true)
            {
                sb.AppendItem(item.AnimationSound.FormKeyNullable, "AnimationSound");
            }
            if ((printMask?.Name ?? true)
                && item.Name is {} NameItem)
            {
                sb.AppendItem(NameItem, "Name");
            }
            if ((printMask?.Model?.Overall ?? true)
                && item.Model is {} ModelItem)
            {
                ModelItem?.ToString(sb, "Model");
            }
            if ((printMask?.Icons?.Overall ?? true)
                && item.Icons is {} IconsItem)
            {
                IconsItem?.ToString(sb, "Icons");
            }
            if (printMask?.ObjectEffect ?? true)
            {
                sb.AppendItem(item.ObjectEffect.FormKeyNullable, "ObjectEffect");
            }
            if ((printMask?.EnchantmentAmount ?? true)
                && item.EnchantmentAmount is {} EnchantmentAmountItem)
            {
                sb.AppendItem(EnchantmentAmountItem, "EnchantmentAmount");
            }
            if ((printMask?.Destructible?.Overall ?? true)
                && item.Destructible is {} DestructibleItem)
            {
                DestructibleItem?.ToString(sb, "Destructible");
            }
            if (printMask?.EquipmentType ?? true)
            {
                sb.AppendItem(item.EquipmentType.FormKeyNullable, "EquipmentType");
            }
            if (printMask?.BlockBashImpactDataSet ?? true)
            {
                sb.AppendItem(item.BlockBashImpactDataSet.FormKeyNullable, "BlockBashImpactDataSet");
            }
            if (printMask?.AlternateBlockMaterial ?? true)
            {
                sb.AppendItem(item.AlternateBlockMaterial.FormKeyNullable, "AlternateBlockMaterial");
            }
            if (printMask?.PickUpSound ?? true)
            {
                sb.AppendItem(item.PickUpSound.FormKeyNullable, "PickUpSound");
            }
            if (printMask?.PutDownSound ?? true)
            {
                sb.AppendItem(item.PutDownSound.FormKeyNullable, "PutDownSound");
            }
            if ((printMask?.Keywords?.Overall ?? true)
                && item.Keywords is {} KeywordsItem)
            {
                sb.AppendLine("Keywords =>");
                sb.AppendLine("[");
                using (sb.IncreaseDepth())
                {
                    foreach (var subItem in KeywordsItem)
                    {
                        sb.AppendLine("[");
                        using (sb.IncreaseDepth())
                        {
                            sb.AppendItem(subItem.FormKey);
                        }
                        sb.AppendLine("]");
                    }
                }
                sb.AppendLine("]");
            }
            if ((printMask?.Description ?? true)
                && item.Description is {} DescriptionItem)
            {
                sb.AppendItem(DescriptionItem, "Description");
            }
            if (printMask?.InstanceNaming ?? true)
            {
                sb.AppendItem(item.InstanceNaming.FormKeyNullable, "InstanceNaming");
            }
            if ((printMask?.AttachParentSlots?.Overall ?? true)
                && item.AttachParentSlots is {} AttachParentSlotsItem)
            {
                sb.AppendLine("AttachParentSlots =>");
                sb.AppendLine("[");
                using (sb.IncreaseDepth())
                {
                    foreach (var subItem in AttachParentSlotsItem)
                    {
                        sb.AppendLine("[");
                        using (sb.IncreaseDepth())
                        {
                            sb.AppendItem(subItem.FormKey);
                        }
                        sb.AppendLine("]");
                    }
                }
                sb.AppendLine("]");
            }
            if ((printMask?.ObjectTemplates?.Overall ?? true)
                && item.ObjectTemplates is {} ObjectTemplatesItem)
            {
                sb.AppendLine("ObjectTemplates =>");
                sb.AppendLine("[");
                using (sb.IncreaseDepth())
                {
                    foreach (var subItem in ObjectTemplatesItem)
                    {
                        sb.AppendLine("[");
                        using (sb.IncreaseDepth())
                        {
                            subItem?.ToString(sb, "Item");
                        }
                        sb.AppendLine("]");
                    }
                }
                sb.AppendLine("]");
            }
            if (printMask?.EmbeddedWeaponMod ?? true)
            {
                sb.AppendItem(item.EmbeddedWeaponMod.FormKeyNullable, "EmbeddedWeaponMod");
            }
            if ((printMask?.FirstPersonModel?.Overall ?? true)
                && item.FirstPersonModel is {} FirstPersonModelItem)
            {
                FirstPersonModelItem?.ToString(sb, "FirstPersonModel");
            }
            if ((printMask?.FirstPersonColorRemappingIndex ?? true)
                && item.FirstPersonColorRemappingIndex is {} FirstPersonColorRemappingIndexItem)
            {
                sb.AppendItem(FirstPersonColorRemappingIndexItem, "FirstPersonColorRemappingIndex");
            }
            if ((printMask?.MO4F ?? true)
                && item.MO4F is {} MO4FItem)
            {
                sb.AppendItem(MO4FItem, "MO4F");
            }
            if (printMask?.Ammo ?? true)
            {
                sb.AppendItem(item.Ammo.FormKey, "Ammo");
            }
            if (printMask?.Speed ?? true)
            {
                sb.AppendItem(item.Speed, "Speed");
            }
            if (printMask?.ReloadSpeed ?? true)
            {
                sb.AppendItem(item.ReloadSpeed, "ReloadSpeed");
            }
            if (printMask?.Reach ?? true)
            {
                sb.AppendItem(item.Reach, "Reach");
            }
            if (printMask?.MinRange ?? true)
            {
                sb.AppendItem(item.MinRange, "MinRange");
            }
            if (printMask?.MaxRange ?? true)
            {
                sb.AppendItem(item.MaxRange, "MaxRange");
            }
            if (printMask?.AttackDelay ?? true)
            {
                sb.AppendItem(item.AttackDelay, "AttackDelay");
            }
            if (printMask?.Unknown ?? true)
            {
                sb.AppendItem(item.Unknown, "Unknown");
            }
            if (printMask?.DamageOutOfRangeMult ?? true)
            {
                sb.AppendItem(item.DamageOutOfRangeMult, "DamageOutOfRangeMult");
            }
            if (printMask?.OnHit ?? true)
            {
                sb.AppendItem(item.OnHit, "OnHit");
            }
            if (printMask?.Skill ?? true)
            {
                sb.AppendItem(item.Skill.FormKey, "Skill");
            }
            if (printMask?.Resist ?? true)
            {
                sb.AppendItem(item.Resist.FormKey, "Resist");
            }
            if (printMask?.Flags ?? true)
            {
                sb.AppendItem(item.Flags, "Flags");
            }
            if (printMask?.Capacity ?? true)
            {
                sb.AppendItem(item.Capacity, "Capacity");
            }
            if (printMask?.AnimationType ?? true)
            {
                sb.AppendItem(item.AnimationType, "AnimationType");
            }
            if (printMask?.SecondaryDamage ?? true)
            {
                sb.AppendItem(item.SecondaryDamage, "SecondaryDamage");
            }
            if (printMask?.Weight ?? true)
            {
                sb.AppendItem(item.Weight, "Weight");
            }
            if (printMask?.Value ?? true)
            {
                sb.AppendItem(item.Value, "Value");
            }
            if (printMask?.BaseDamage ?? true)
            {
                sb.AppendItem(item.BaseDamage, "BaseDamage");
            }
            if (printMask?.SoundLevel ?? true)
            {
                sb.AppendItem(item.SoundLevel, "SoundLevel");
            }
            if (printMask?.AttackSound ?? true)
            {
                sb.AppendItem(item.AttackSound.FormKey, "AttackSound");
            }
            if (printMask?.Attack2dSound ?? true)
            {
                sb.AppendItem(item.Attack2dSound.FormKey, "Attack2dSound");
            }
            if (printMask?.AttackLoopSound ?? true)
            {
                sb.AppendItem(item.AttackLoopSound.FormKey, "AttackLoopSound");
            }
            if (printMask?.AttackFailSound ?? true)
            {
                sb.AppendItem(item.AttackFailSound.FormKey, "AttackFailSound");
            }
            if (printMask?.IdleSound ?? true)
            {
                sb.AppendItem(item.IdleSound.FormKey, "IdleSound");
            }
            if (printMask?.EquipSound ?? true)
            {
                sb.AppendItem(item.EquipSound.FormKey, "EquipSound");
            }
            if (printMask?.UnequipSound ?? true)
            {
                sb.AppendItem(item.UnequipSound.FormKey, "UnequipSound");
            }
            if (printMask?.FastEquipSound ?? true)
            {
                sb.AppendItem(item.FastEquipSound.FormKey, "FastEquipSound");
            }
            if (printMask?.AccuracyBonus ?? true)
            {
                sb.AppendItem(item.AccuracyBonus, "AccuracyBonus");
            }
            if (printMask?.AnimationAttackSeconds ?? true)
            {
                sb.AppendItem(item.AnimationAttackSeconds, "AnimationAttackSeconds");
            }
            if (printMask?.Unknown2 ?? true)
            {
                sb.AppendItem(item.Unknown2, "Unknown2");
            }
            if (printMask?.ActionPointCost ?? true)
            {
                sb.AppendItem(item.ActionPointCost, "ActionPointCost");
            }
            if (printMask?.FullPowerSeconds ?? true)
            {
                sb.AppendItem(item.FullPowerSeconds, "FullPowerSeconds");
            }
            if (printMask?.MinPowerPerShot ?? true)
            {
                sb.AppendItem(item.MinPowerPerShot, "MinPowerPerShot");
            }
            if (printMask?.Stagger ?? true)
            {
                sb.AppendItem(item.Stagger, "Stagger");
            }
            if (printMask?.Unknown3 ?? true)
            {
                sb.AppendItem(item.Unknown3, "Unknown3");
            }
            if ((printMask?.ExtraData?.Overall ?? true)
                && item.ExtraData is {} ExtraDataItem)
            {
                ExtraDataItem?.ToString(sb, "ExtraData");
            }
            if (printMask?.CritDamageMult ?? true)
            {
                sb.AppendItem(item.CritDamageMult, "CritDamageMult");
            }
            if (printMask?.CritChargeBonus ?? true)
            {
                sb.AppendItem(item.CritChargeBonus, "CritChargeBonus");
            }
            if (printMask?.CritEffect ?? true)
            {
                sb.AppendItem(item.CritEffect.FormKey, "CritEffect");
            }
            if (printMask?.ImpactDataSet ?? true)
            {
                sb.AppendItem(item.ImpactDataSet.FormKeyNullable, "ImpactDataSet");
            }
            if (printMask?.NpcAddAmmoList ?? true)
            {
                sb.AppendItem(item.NpcAddAmmoList.FormKeyNullable, "NpcAddAmmoList");
            }
            if (printMask?.AimModel ?? true)
            {
                sb.AppendItem(item.AimModel.FormKeyNullable, "AimModel");
            }
            if (printMask?.Zoom ?? true)
            {
                sb.AppendItem(item.Zoom.FormKeyNullable, "Zoom");
            }
            if (printMask?.Template ?? true)
            {
                sb.AppendItem(item.Template.FormKeyNullable, "Template");
            }
            if ((printMask?.DamageType?.Overall ?? true)
                && item.DamageType is {} DamageTypeItem)
            {
                DamageTypeItem?.ToString(sb, "DamageType");
            }
            if ((printMask?.Filter ?? true)
                && item.Filter is {} FilterItem)
            {
                sb.AppendItem(FilterItem, "Filter");
            }
            if ((printMask?.MeleeSpeed ?? true)
                && item.MeleeSpeed is {} MeleeSpeedItem)
            {
                sb.AppendItem(MeleeSpeedItem, "MeleeSpeed");
            }
            if (printMask?.DNAMDataTypeState ?? true)
            {
                sb.AppendItem(item.DNAMDataTypeState, "DNAMDataTypeState");
            }
            if (printMask?.CRDTDataTypeState ?? true)
            {
                sb.AppendItem(item.CRDTDataTypeState, "CRDTDataTypeState");
            }
        }
        
        public static Weapon_FieldIndex ConvertFieldIndex(Fallout4MajorRecord_FieldIndex index)
        {
            switch (index)
            {
                case Fallout4MajorRecord_FieldIndex.MajorRecordFlagsRaw:
                    return (Weapon_FieldIndex)((int)index);
                case Fallout4MajorRecord_FieldIndex.FormKey:
                    return (Weapon_FieldIndex)((int)index);
                case Fallout4MajorRecord_FieldIndex.VersionControl:
                    return (Weapon_FieldIndex)((int)index);
                case Fallout4MajorRecord_FieldIndex.EditorID:
                    return (Weapon_FieldIndex)((int)index);
                case Fallout4MajorRecord_FieldIndex.FormVersion:
                    return (Weapon_FieldIndex)((int)index);
                case Fallout4MajorRecord_FieldIndex.Version2:
                    return (Weapon_FieldIndex)((int)index);
                default:
                    throw new ArgumentException($"Index is out of range: {index.ToStringFast_Enum_Only()}");
            }
        }
        
        public static new Weapon_FieldIndex ConvertFieldIndex(MajorRecord_FieldIndex index)
        {
            switch (index)
            {
                case MajorRecord_FieldIndex.MajorRecordFlagsRaw:
                    return (Weapon_FieldIndex)((int)index);
                case MajorRecord_FieldIndex.FormKey:
                    return (Weapon_FieldIndex)((int)index);
                case MajorRecord_FieldIndex.VersionControl:
                    return (Weapon_FieldIndex)((int)index);
                case MajorRecord_FieldIndex.EditorID:
                    return (Weapon_FieldIndex)((int)index);
                default:
                    throw new ArgumentException($"Index is out of range: {index.ToStringFast_Enum_Only()}");
            }
        }
        
        #region Equals and Hash
        public virtual bool Equals(
            IWeaponGetter? lhs,
            IWeaponGetter? rhs,
            TranslationCrystal? crystal)
        {
            if (!EqualsMaskHelper.RefEquality(lhs, rhs, out var isEqual)) return isEqual;
            if (!base.Equals((IFallout4MajorRecordGetter)lhs, (IFallout4MajorRecordGetter)rhs, crystal)) return false;
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.VirtualMachineAdapter) ?? true))
            {
                if (EqualsMaskHelper.RefEquality(lhs.VirtualMachineAdapter, rhs.VirtualMachineAdapter, out var lhsVirtualMachineAdapter, out var rhsVirtualMachineAdapter, out var isVirtualMachineAdapterEqual))
                {
                    if (!((VirtualMachineAdapterCommon)((IVirtualMachineAdapterGetter)lhsVirtualMachineAdapter).CommonInstance()!).Equals(lhsVirtualMachineAdapter, rhsVirtualMachineAdapter, crystal?.GetSubCrystal((int)Weapon_FieldIndex.VirtualMachineAdapter))) return false;
                }
                else if (!isVirtualMachineAdapterEqual) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.ObjectBounds) ?? true))
            {
                if (EqualsMaskHelper.RefEquality(lhs.ObjectBounds, rhs.ObjectBounds, out var lhsObjectBounds, out var rhsObjectBounds, out var isObjectBoundsEqual))
                {
                    if (!((ObjectBoundsCommon)((IObjectBoundsGetter)lhsObjectBounds).CommonInstance()!).Equals(lhsObjectBounds, rhsObjectBounds, crystal?.GetSubCrystal((int)Weapon_FieldIndex.ObjectBounds))) return false;
                }
                else if (!isObjectBoundsEqual) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.PreviewTransform) ?? true))
            {
                if (!lhs.PreviewTransform.Equals(rhs.PreviewTransform)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.AnimationSound) ?? true))
            {
                if (!lhs.AnimationSound.Equals(rhs.AnimationSound)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.Name) ?? true))
            {
                if (!object.Equals(lhs.Name, rhs.Name)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.Model) ?? true))
            {
                if (EqualsMaskHelper.RefEquality(lhs.Model, rhs.Model, out var lhsModel, out var rhsModel, out var isModelEqual))
                {
                    if (!((ModelCommon)((IModelGetter)lhsModel).CommonInstance()!).Equals(lhsModel, rhsModel, crystal?.GetSubCrystal((int)Weapon_FieldIndex.Model))) return false;
                }
                else if (!isModelEqual) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.Icons) ?? true))
            {
                if (EqualsMaskHelper.RefEquality(lhs.Icons, rhs.Icons, out var lhsIcons, out var rhsIcons, out var isIconsEqual))
                {
                    if (!((IconsCommon)((IIconsGetter)lhsIcons).CommonInstance()!).Equals(lhsIcons, rhsIcons, crystal?.GetSubCrystal((int)Weapon_FieldIndex.Icons))) return false;
                }
                else if (!isIconsEqual) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.ObjectEffect) ?? true))
            {
                if (!lhs.ObjectEffect.Equals(rhs.ObjectEffect)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.EnchantmentAmount) ?? true))
            {
                if (lhs.EnchantmentAmount != rhs.EnchantmentAmount) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.Destructible) ?? true))
            {
                if (EqualsMaskHelper.RefEquality(lhs.Destructible, rhs.Destructible, out var lhsDestructible, out var rhsDestructible, out var isDestructibleEqual))
                {
                    if (!((DestructibleCommon)((IDestructibleGetter)lhsDestructible).CommonInstance()!).Equals(lhsDestructible, rhsDestructible, crystal?.GetSubCrystal((int)Weapon_FieldIndex.Destructible))) return false;
                }
                else if (!isDestructibleEqual) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.EquipmentType) ?? true))
            {
                if (!lhs.EquipmentType.Equals(rhs.EquipmentType)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.BlockBashImpactDataSet) ?? true))
            {
                if (!lhs.BlockBashImpactDataSet.Equals(rhs.BlockBashImpactDataSet)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.AlternateBlockMaterial) ?? true))
            {
                if (!lhs.AlternateBlockMaterial.Equals(rhs.AlternateBlockMaterial)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.PickUpSound) ?? true))
            {
                if (!lhs.PickUpSound.Equals(rhs.PickUpSound)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.PutDownSound) ?? true))
            {
                if (!lhs.PutDownSound.Equals(rhs.PutDownSound)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.Keywords) ?? true))
            {
                if (!lhs.Keywords.SequenceEqualNullable(rhs.Keywords)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.Description) ?? true))
            {
                if (!object.Equals(lhs.Description, rhs.Description)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.InstanceNaming) ?? true))
            {
                if (!lhs.InstanceNaming.Equals(rhs.InstanceNaming)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.AttachParentSlots) ?? true))
            {
                if (!lhs.AttachParentSlots.SequenceEqualNullable(rhs.AttachParentSlots)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.ObjectTemplates) ?? true))
            {
                if (!lhs.ObjectTemplates.SequenceEqualNullable(rhs.ObjectTemplates, (l, r) => ((ObjectTemplateCommon<Weapon.Property>)((IObjectTemplateGetter<Weapon.Property>)l).CommonInstance(typeof(Weapon.Property))!).Equals(l, r, crystal?.GetSubCrystal((int)Weapon_FieldIndex.ObjectTemplates)))) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.EmbeddedWeaponMod) ?? true))
            {
                if (!lhs.EmbeddedWeaponMod.Equals(rhs.EmbeddedWeaponMod)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.FirstPersonModel) ?? true))
            {
                if (EqualsMaskHelper.RefEquality(lhs.FirstPersonModel, rhs.FirstPersonModel, out var lhsFirstPersonModel, out var rhsFirstPersonModel, out var isFirstPersonModelEqual))
                {
                    if (!((ModelCommon)((IModelGetter)lhsFirstPersonModel).CommonInstance()!).Equals(lhsFirstPersonModel, rhsFirstPersonModel, crystal?.GetSubCrystal((int)Weapon_FieldIndex.FirstPersonModel))) return false;
                }
                else if (!isFirstPersonModelEqual) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.FirstPersonColorRemappingIndex) ?? true))
            {
                if (!lhs.FirstPersonColorRemappingIndex.EqualsWithin(rhs.FirstPersonColorRemappingIndex)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.MO4F) ?? true))
            {
                if (lhs.MO4F != rhs.MO4F) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.Ammo) ?? true))
            {
                if (!lhs.Ammo.Equals(rhs.Ammo)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.Speed) ?? true))
            {
                if (!lhs.Speed.EqualsWithin(rhs.Speed)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.ReloadSpeed) ?? true))
            {
                if (!lhs.ReloadSpeed.EqualsWithin(rhs.ReloadSpeed)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.Reach) ?? true))
            {
                if (!lhs.Reach.EqualsWithin(rhs.Reach)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.MinRange) ?? true))
            {
                if (!lhs.MinRange.EqualsWithin(rhs.MinRange)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.MaxRange) ?? true))
            {
                if (!lhs.MaxRange.EqualsWithin(rhs.MaxRange)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.AttackDelay) ?? true))
            {
                if (!lhs.AttackDelay.EqualsWithin(rhs.AttackDelay)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.Unknown) ?? true))
            {
                if (!lhs.Unknown.EqualsWithin(rhs.Unknown)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.DamageOutOfRangeMult) ?? true))
            {
                if (!lhs.DamageOutOfRangeMult.EqualsWithin(rhs.DamageOutOfRangeMult)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.OnHit) ?? true))
            {
                if (lhs.OnHit != rhs.OnHit) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.Skill) ?? true))
            {
                if (!lhs.Skill.Equals(rhs.Skill)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.Resist) ?? true))
            {
                if (!lhs.Resist.Equals(rhs.Resist)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.Flags) ?? true))
            {
                if (lhs.Flags != rhs.Flags) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.Capacity) ?? true))
            {
                if (lhs.Capacity != rhs.Capacity) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.AnimationType) ?? true))
            {
                if (lhs.AnimationType != rhs.AnimationType) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.SecondaryDamage) ?? true))
            {
                if (!lhs.SecondaryDamage.EqualsWithin(rhs.SecondaryDamage)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.Weight) ?? true))
            {
                if (!lhs.Weight.EqualsWithin(rhs.Weight)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.Value) ?? true))
            {
                if (lhs.Value != rhs.Value) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.BaseDamage) ?? true))
            {
                if (lhs.BaseDamage != rhs.BaseDamage) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.SoundLevel) ?? true))
            {
                if (lhs.SoundLevel != rhs.SoundLevel) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.AttackSound) ?? true))
            {
                if (!lhs.AttackSound.Equals(rhs.AttackSound)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.Attack2dSound) ?? true))
            {
                if (!lhs.Attack2dSound.Equals(rhs.Attack2dSound)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.AttackLoopSound) ?? true))
            {
                if (!lhs.AttackLoopSound.Equals(rhs.AttackLoopSound)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.AttackFailSound) ?? true))
            {
                if (!lhs.AttackFailSound.Equals(rhs.AttackFailSound)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.IdleSound) ?? true))
            {
                if (!lhs.IdleSound.Equals(rhs.IdleSound)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.EquipSound) ?? true))
            {
                if (!lhs.EquipSound.Equals(rhs.EquipSound)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.UnequipSound) ?? true))
            {
                if (!lhs.UnequipSound.Equals(rhs.UnequipSound)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.FastEquipSound) ?? true))
            {
                if (!lhs.FastEquipSound.Equals(rhs.FastEquipSound)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.AccuracyBonus) ?? true))
            {
                if (lhs.AccuracyBonus != rhs.AccuracyBonus) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.AnimationAttackSeconds) ?? true))
            {
                if (!lhs.AnimationAttackSeconds.EqualsWithin(rhs.AnimationAttackSeconds)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.Unknown2) ?? true))
            {
                if (lhs.Unknown2 != rhs.Unknown2) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.ActionPointCost) ?? true))
            {
                if (!lhs.ActionPointCost.EqualsWithin(rhs.ActionPointCost)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.FullPowerSeconds) ?? true))
            {
                if (!lhs.FullPowerSeconds.EqualsWithin(rhs.FullPowerSeconds)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.MinPowerPerShot) ?? true))
            {
                if (!lhs.MinPowerPerShot.EqualsWithin(rhs.MinPowerPerShot)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.Stagger) ?? true))
            {
                if (lhs.Stagger != rhs.Stagger) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.Unknown3) ?? true))
            {
                if (lhs.Unknown3 != rhs.Unknown3) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.ExtraData) ?? true))
            {
                if (EqualsMaskHelper.RefEquality(lhs.ExtraData, rhs.ExtraData, out var lhsExtraData, out var rhsExtraData, out var isExtraDataEqual))
                {
                    if (!((WeaponExtraDataCommon)((IWeaponExtraDataGetter)lhsExtraData).CommonInstance()!).Equals(lhsExtraData, rhsExtraData, crystal?.GetSubCrystal((int)Weapon_FieldIndex.ExtraData))) return false;
                }
                else if (!isExtraDataEqual) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.CritDamageMult) ?? true))
            {
                if (!lhs.CritDamageMult.EqualsWithin(rhs.CritDamageMult)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.CritChargeBonus) ?? true))
            {
                if (!lhs.CritChargeBonus.EqualsWithin(rhs.CritChargeBonus)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.CritEffect) ?? true))
            {
                if (!lhs.CritEffect.Equals(rhs.CritEffect)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.ImpactDataSet) ?? true))
            {
                if (!lhs.ImpactDataSet.Equals(rhs.ImpactDataSet)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.NpcAddAmmoList) ?? true))
            {
                if (!lhs.NpcAddAmmoList.Equals(rhs.NpcAddAmmoList)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.AimModel) ?? true))
            {
                if (!lhs.AimModel.Equals(rhs.AimModel)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.Zoom) ?? true))
            {
                if (!lhs.Zoom.Equals(rhs.Zoom)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.Template) ?? true))
            {
                if (!lhs.Template.Equals(rhs.Template)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.DamageType) ?? true))
            {
                if (EqualsMaskHelper.RefEquality(lhs.DamageType, rhs.DamageType, out var lhsDamageType, out var rhsDamageType, out var isDamageTypeEqual))
                {
                    if (!((WeaponDamageTypeCommon)((IWeaponDamageTypeGetter)lhsDamageType).CommonInstance()!).Equals(lhsDamageType, rhsDamageType, crystal?.GetSubCrystal((int)Weapon_FieldIndex.DamageType))) return false;
                }
                else if (!isDamageTypeEqual) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.Filter) ?? true))
            {
                if (!string.Equals(lhs.Filter, rhs.Filter)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.MeleeSpeed) ?? true))
            {
                if (lhs.MeleeSpeed != rhs.MeleeSpeed) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.DNAMDataTypeState) ?? true))
            {
                if (lhs.DNAMDataTypeState != rhs.DNAMDataTypeState) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Weapon_FieldIndex.CRDTDataTypeState) ?? true))
            {
                if (lhs.CRDTDataTypeState != rhs.CRDTDataTypeState) return false;
            }
            return true;
        }
        
        public override bool Equals(
            IFallout4MajorRecordGetter? lhs,
            IFallout4MajorRecordGetter? rhs,
            TranslationCrystal? crystal)
        {
            return Equals(
                lhs: (IWeaponGetter?)lhs,
                rhs: rhs as IWeaponGetter,
                crystal: crystal);
        }
        
        public override bool Equals(
            IMajorRecordGetter? lhs,
            IMajorRecordGetter? rhs,
            TranslationCrystal? crystal)
        {
            return Equals(
                lhs: (IWeaponGetter?)lhs,
                rhs: rhs as IWeaponGetter,
                crystal: crystal);
        }
        
        public virtual int GetHashCode(IWeaponGetter item)
        {
            var hash = new HashCode();
            if (item.VirtualMachineAdapter is {} VirtualMachineAdapteritem)
            {
                hash.Add(VirtualMachineAdapteritem);
            }
            hash.Add(item.ObjectBounds);
            hash.Add(item.PreviewTransform);
            hash.Add(item.AnimationSound);
            if (item.Name is {} Nameitem)
            {
                hash.Add(Nameitem);
            }
            if (item.Model is {} Modelitem)
            {
                hash.Add(Modelitem);
            }
            if (item.Icons is {} Iconsitem)
            {
                hash.Add(Iconsitem);
            }
            hash.Add(item.ObjectEffect);
            if (item.EnchantmentAmount is {} EnchantmentAmountitem)
            {
                hash.Add(EnchantmentAmountitem);
            }
            if (item.Destructible is {} Destructibleitem)
            {
                hash.Add(Destructibleitem);
            }
            hash.Add(item.EquipmentType);
            hash.Add(item.BlockBashImpactDataSet);
            hash.Add(item.AlternateBlockMaterial);
            hash.Add(item.PickUpSound);
            hash.Add(item.PutDownSound);
            hash.Add(item.Keywords);
            if (item.Description is {} Descriptionitem)
            {
                hash.Add(Descriptionitem);
            }
            hash.Add(item.InstanceNaming);
            hash.Add(item.AttachParentSlots);
            hash.Add(item.ObjectTemplates);
            hash.Add(item.EmbeddedWeaponMod);
            if (item.FirstPersonModel is {} FirstPersonModelitem)
            {
                hash.Add(FirstPersonModelitem);
            }
            if (item.FirstPersonColorRemappingIndex is {} FirstPersonColorRemappingIndexitem)
            {
                hash.Add(FirstPersonColorRemappingIndexitem);
            }
            if (item.MO4F is {} MO4Fitem)
            {
                hash.Add(MO4Fitem);
            }
            hash.Add(item.Ammo);
            hash.Add(item.Speed);
            hash.Add(item.ReloadSpeed);
            hash.Add(item.Reach);
            hash.Add(item.MinRange);
            hash.Add(item.MaxRange);
            hash.Add(item.AttackDelay);
            hash.Add(item.Unknown);
            hash.Add(item.DamageOutOfRangeMult);
            hash.Add(item.OnHit);
            hash.Add(item.Skill);
            hash.Add(item.Resist);
            hash.Add(item.Flags);
            hash.Add(item.Capacity);
            hash.Add(item.AnimationType);
            hash.Add(item.SecondaryDamage);
            hash.Add(item.Weight);
            hash.Add(item.Value);
            hash.Add(item.BaseDamage);
            hash.Add(item.SoundLevel);
            hash.Add(item.AttackSound);
            hash.Add(item.Attack2dSound);
            hash.Add(item.AttackLoopSound);
            hash.Add(item.AttackFailSound);
            hash.Add(item.IdleSound);
            hash.Add(item.EquipSound);
            hash.Add(item.UnequipSound);
            hash.Add(item.FastEquipSound);
            hash.Add(item.AccuracyBonus);
            hash.Add(item.AnimationAttackSeconds);
            hash.Add(item.Unknown2);
            hash.Add(item.ActionPointCost);
            hash.Add(item.FullPowerSeconds);
            hash.Add(item.MinPowerPerShot);
            hash.Add(item.Stagger);
            hash.Add(item.Unknown3);
            if (item.ExtraData is {} ExtraDataitem)
            {
                hash.Add(ExtraDataitem);
            }
            hash.Add(item.CritDamageMult);
            hash.Add(item.CritChargeBonus);
            hash.Add(item.CritEffect);
            hash.Add(item.ImpactDataSet);
            hash.Add(item.NpcAddAmmoList);
            hash.Add(item.AimModel);
            hash.Add(item.Zoom);
            hash.Add(item.Template);
            if (item.DamageType is {} DamageTypeitem)
            {
                hash.Add(DamageTypeitem);
            }
            if (item.Filter is {} Filteritem)
            {
                hash.Add(Filteritem);
            }
            if (item.MeleeSpeed is {} MeleeSpeeditem)
            {
                hash.Add(MeleeSpeeditem);
            }
            hash.Add(item.DNAMDataTypeState);
            hash.Add(item.CRDTDataTypeState);
            hash.Add(base.GetHashCode());
            return hash.ToHashCode();
        }
        
        public override int GetHashCode(IFallout4MajorRecordGetter item)
        {
            return GetHashCode(item: (IWeaponGetter)item);
        }
        
        public override int GetHashCode(IMajorRecordGetter item)
        {
            return GetHashCode(item: (IWeaponGetter)item);
        }
        
        #endregion
        
        
        public override object GetNew()
        {
            return Weapon.GetNew();
        }
        
        #region Mutagen
        public IEnumerable<IFormLinkGetter> GetContainedFormLinks(IWeaponGetter obj)
        {
            foreach (var item in base.GetContainedFormLinks(obj))
            {
                yield return item;
            }
            if (obj.VirtualMachineAdapter is IFormLinkContainerGetter VirtualMachineAdapterlinkCont)
            {
                foreach (var item in VirtualMachineAdapterlinkCont.ContainedFormLinks)
                {
                    yield return item;
                }
            }
            if (FormLinkInformation.TryFactory(obj.PreviewTransform, out var PreviewTransformInfo))
            {
                yield return PreviewTransformInfo;
            }
            if (FormLinkInformation.TryFactory(obj.AnimationSound, out var AnimationSoundInfo))
            {
                yield return AnimationSoundInfo;
            }
            if (obj.Model is {} ModelItems)
            {
                foreach (var item in ModelItems.ContainedFormLinks)
                {
                    yield return item;
                }
            }
            if (FormLinkInformation.TryFactory(obj.ObjectEffect, out var ObjectEffectInfo))
            {
                yield return ObjectEffectInfo;
            }
            if (obj.Destructible is {} DestructibleItems)
            {
                foreach (var item in DestructibleItems.ContainedFormLinks)
                {
                    yield return item;
                }
            }
            if (FormLinkInformation.TryFactory(obj.EquipmentType, out var EquipmentTypeInfo))
            {
                yield return EquipmentTypeInfo;
            }
            if (FormLinkInformation.TryFactory(obj.BlockBashImpactDataSet, out var BlockBashImpactDataSetInfo))
            {
                yield return BlockBashImpactDataSetInfo;
            }
            if (FormLinkInformation.TryFactory(obj.AlternateBlockMaterial, out var AlternateBlockMaterialInfo))
            {
                yield return AlternateBlockMaterialInfo;
            }
            if (FormLinkInformation.TryFactory(obj.PickUpSound, out var PickUpSoundInfo))
            {
                yield return PickUpSoundInfo;
            }
            if (FormLinkInformation.TryFactory(obj.PutDownSound, out var PutDownSoundInfo))
            {
                yield return PutDownSoundInfo;
            }
            if (obj.Keywords is {} KeywordsItem)
            {
                foreach (var item in KeywordsItem)
                {
                    yield return FormLinkInformation.Factory(item);
                }
            }
            if (FormLinkInformation.TryFactory(obj.InstanceNaming, out var InstanceNamingInfo))
            {
                yield return InstanceNamingInfo;
            }
            if (obj.AttachParentSlots is {} AttachParentSlotsItem)
            {
                foreach (var item in AttachParentSlotsItem)
                {
                    yield return FormLinkInformation.Factory(item);
                }
            }
            if (obj.ObjectTemplates is {} ObjectTemplatesItem)
            {
                foreach (var item in ObjectTemplatesItem.SelectMany(f => f.ContainedFormLinks))
                {
                    yield return FormLinkInformation.Factory(item);
                }
            }
            if (FormLinkInformation.TryFactory(obj.EmbeddedWeaponMod, out var EmbeddedWeaponModInfo))
            {
                yield return EmbeddedWeaponModInfo;
            }
            if (obj.FirstPersonModel is {} FirstPersonModelItems)
            {
                foreach (var item in FirstPersonModelItems.ContainedFormLinks)
                {
                    yield return item;
                }
            }
            yield return FormLinkInformation.Factory(obj.Ammo);
            yield return FormLinkInformation.Factory(obj.Skill);
            yield return FormLinkInformation.Factory(obj.Resist);
            yield return FormLinkInformation.Factory(obj.AttackSound);
            yield return FormLinkInformation.Factory(obj.Attack2dSound);
            yield return FormLinkInformation.Factory(obj.AttackLoopSound);
            yield return FormLinkInformation.Factory(obj.AttackFailSound);
            yield return FormLinkInformation.Factory(obj.IdleSound);
            yield return FormLinkInformation.Factory(obj.EquipSound);
            yield return FormLinkInformation.Factory(obj.UnequipSound);
            yield return FormLinkInformation.Factory(obj.FastEquipSound);
            if (obj.ExtraData is {} ExtraDataItems)
            {
                foreach (var item in ExtraDataItems.ContainedFormLinks)
                {
                    yield return item;
                }
            }
            yield return FormLinkInformation.Factory(obj.CritEffect);
            if (FormLinkInformation.TryFactory(obj.ImpactDataSet, out var ImpactDataSetInfo))
            {
                yield return ImpactDataSetInfo;
            }
            if (FormLinkInformation.TryFactory(obj.NpcAddAmmoList, out var NpcAddAmmoListInfo))
            {
                yield return NpcAddAmmoListInfo;
            }
            if (FormLinkInformation.TryFactory(obj.AimModel, out var AimModelInfo))
            {
                yield return AimModelInfo;
            }
            if (FormLinkInformation.TryFactory(obj.Zoom, out var ZoomInfo))
            {
                yield return ZoomInfo;
            }
            if (FormLinkInformation.TryFactory(obj.Template, out var TemplateInfo))
            {
                yield return TemplateInfo;
            }
            if (obj.DamageType is {} DamageTypeItems)
            {
                foreach (var item in DamageTypeItems.ContainedFormLinks)
                {
                    yield return item;
                }
            }
            yield break;
        }
        
        #region Duplicate
        public Weapon Duplicate(
            IWeaponGetter item,
            FormKey formKey,
            TranslationCrystal? copyMask)
        {
            var newRec = new Weapon(formKey);
            newRec.DeepCopyIn(item, default(ErrorMaskBuilder?), copyMask);
            return newRec;
        }
        
        public override Fallout4MajorRecord Duplicate(
            IFallout4MajorRecordGetter item,
            FormKey formKey,
            TranslationCrystal? copyMask)
        {
            return this.Duplicate(
                item: (IWeaponGetter)item,
                formKey: formKey,
                copyMask: copyMask);
        }
        
        public override MajorRecord Duplicate(
            IMajorRecordGetter item,
            FormKey formKey,
            TranslationCrystal? copyMask)
        {
            return this.Duplicate(
                item: (IWeaponGetter)item,
                formKey: formKey,
                copyMask: copyMask);
        }
        
        #endregion
        
        #endregion
        
    }
    internal partial class WeaponSetterTranslationCommon : Fallout4MajorRecordSetterTranslationCommon
    {
        public new static readonly WeaponSetterTranslationCommon Instance = new WeaponSetterTranslationCommon();

        #region DeepCopyIn
        public void DeepCopyIn(
            IWeaponInternal item,
            IWeaponGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask,
            bool deepCopy)
        {
            base.DeepCopyIn(
                item,
                rhs,
                errorMask,
                copyMask,
                deepCopy: deepCopy);
        }
        
        public void DeepCopyIn(
            IWeapon item,
            IWeaponGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask,
            bool deepCopy)
        {
            base.DeepCopyIn(
                (IFallout4MajorRecord)item,
                (IFallout4MajorRecordGetter)rhs,
                errorMask,
                copyMask,
                deepCopy: deepCopy);
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.VirtualMachineAdapter) ?? true))
            {
                errorMask?.PushIndex((int)Weapon_FieldIndex.VirtualMachineAdapter);
                try
                {
                    if(rhs.VirtualMachineAdapter is {} rhsVirtualMachineAdapter)
                    {
                        item.VirtualMachineAdapter = rhsVirtualMachineAdapter.DeepCopy(
                            errorMask: errorMask,
                            copyMask?.GetSubCrystal((int)Weapon_FieldIndex.VirtualMachineAdapter));
                    }
                    else
                    {
                        item.VirtualMachineAdapter = default;
                    }
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.ObjectBounds) ?? true))
            {
                errorMask?.PushIndex((int)Weapon_FieldIndex.ObjectBounds);
                try
                {
                    if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.ObjectBounds) ?? true))
                    {
                        item.ObjectBounds = rhs.ObjectBounds.DeepCopy(
                            copyMask: copyMask?.GetSubCrystal((int)Weapon_FieldIndex.ObjectBounds),
                            errorMask: errorMask);
                    }
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.PreviewTransform) ?? true))
            {
                item.PreviewTransform.SetTo(rhs.PreviewTransform.FormKeyNullable);
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.AnimationSound) ?? true))
            {
                item.AnimationSound.SetTo(rhs.AnimationSound.FormKeyNullable);
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.Name) ?? true))
            {
                item.Name = rhs.Name?.DeepCopy();
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.Model) ?? true))
            {
                errorMask?.PushIndex((int)Weapon_FieldIndex.Model);
                try
                {
                    if(rhs.Model is {} rhsModel)
                    {
                        item.Model = rhsModel.DeepCopy(
                            errorMask: errorMask,
                            copyMask?.GetSubCrystal((int)Weapon_FieldIndex.Model));
                    }
                    else
                    {
                        item.Model = default;
                    }
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.Icons) ?? true))
            {
                errorMask?.PushIndex((int)Weapon_FieldIndex.Icons);
                try
                {
                    if(rhs.Icons is {} rhsIcons)
                    {
                        item.Icons = rhsIcons.DeepCopy(
                            errorMask: errorMask,
                            copyMask?.GetSubCrystal((int)Weapon_FieldIndex.Icons));
                    }
                    else
                    {
                        item.Icons = default;
                    }
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.ObjectEffect) ?? true))
            {
                item.ObjectEffect.SetTo(rhs.ObjectEffect.FormKeyNullable);
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.EnchantmentAmount) ?? true))
            {
                item.EnchantmentAmount = rhs.EnchantmentAmount;
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.Destructible) ?? true))
            {
                errorMask?.PushIndex((int)Weapon_FieldIndex.Destructible);
                try
                {
                    if(rhs.Destructible is {} rhsDestructible)
                    {
                        item.Destructible = rhsDestructible.DeepCopy(
                            errorMask: errorMask,
                            copyMask?.GetSubCrystal((int)Weapon_FieldIndex.Destructible));
                    }
                    else
                    {
                        item.Destructible = default;
                    }
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.EquipmentType) ?? true))
            {
                item.EquipmentType.SetTo(rhs.EquipmentType.FormKeyNullable);
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.BlockBashImpactDataSet) ?? true))
            {
                item.BlockBashImpactDataSet.SetTo(rhs.BlockBashImpactDataSet.FormKeyNullable);
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.AlternateBlockMaterial) ?? true))
            {
                item.AlternateBlockMaterial.SetTo(rhs.AlternateBlockMaterial.FormKeyNullable);
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.PickUpSound) ?? true))
            {
                item.PickUpSound.SetTo(rhs.PickUpSound.FormKeyNullable);
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.PutDownSound) ?? true))
            {
                item.PutDownSound.SetTo(rhs.PutDownSound.FormKeyNullable);
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.Keywords) ?? true))
            {
                errorMask?.PushIndex((int)Weapon_FieldIndex.Keywords);
                try
                {
                    if ((rhs.Keywords != null))
                    {
                        item.Keywords = 
                            rhs.Keywords
                            .Select(r => (IFormLinkGetter<IKeywordGetter>)new FormLink<IKeywordGetter>(r.FormKey))
                            .ToExtendedList<IFormLinkGetter<IKeywordGetter>>();
                    }
                    else
                    {
                        item.Keywords = null;
                    }
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.Description) ?? true))
            {
                item.Description = rhs.Description?.DeepCopy();
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.InstanceNaming) ?? true))
            {
                item.InstanceNaming.SetTo(rhs.InstanceNaming.FormKeyNullable);
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.AttachParentSlots) ?? true))
            {
                errorMask?.PushIndex((int)Weapon_FieldIndex.AttachParentSlots);
                try
                {
                    if ((rhs.AttachParentSlots != null))
                    {
                        item.AttachParentSlots = 
                            rhs.AttachParentSlots
                            .Select(r => (IFormLinkGetter<IKeywordGetter>)new FormLink<IKeywordGetter>(r.FormKey))
                            .ToExtendedList<IFormLinkGetter<IKeywordGetter>>();
                    }
                    else
                    {
                        item.AttachParentSlots = null;
                    }
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.ObjectTemplates) ?? true))
            {
                errorMask?.PushIndex((int)Weapon_FieldIndex.ObjectTemplates);
                try
                {
                    if ((rhs.ObjectTemplates != null))
                    {
                        item.ObjectTemplates = 
                            rhs.ObjectTemplates
                            .Select(r =>
                            {
                                return r.DeepCopy<Weapon.Property>(
                                    errorMask: errorMask,
                                    default(TranslationCrystal));
                            })
                            .ToExtendedList<ObjectTemplate<Weapon.Property>>();
                    }
                    else
                    {
                        item.ObjectTemplates = null;
                    }
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.EmbeddedWeaponMod) ?? true))
            {
                item.EmbeddedWeaponMod.SetTo(rhs.EmbeddedWeaponMod.FormKeyNullable);
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.FirstPersonModel) ?? true))
            {
                errorMask?.PushIndex((int)Weapon_FieldIndex.FirstPersonModel);
                try
                {
                    if(rhs.FirstPersonModel is {} rhsFirstPersonModel)
                    {
                        item.FirstPersonModel = rhsFirstPersonModel.DeepCopy(
                            errorMask: errorMask,
                            copyMask?.GetSubCrystal((int)Weapon_FieldIndex.FirstPersonModel));
                    }
                    else
                    {
                        item.FirstPersonModel = default;
                    }
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.FirstPersonColorRemappingIndex) ?? true))
            {
                item.FirstPersonColorRemappingIndex = rhs.FirstPersonColorRemappingIndex;
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.MO4F) ?? true))
            {
                item.MO4F = rhs.MO4F;
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.Ammo) ?? true))
            {
                item.Ammo.SetTo(rhs.Ammo.FormKey);
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.Speed) ?? true))
            {
                item.Speed = rhs.Speed;
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.ReloadSpeed) ?? true))
            {
                item.ReloadSpeed = rhs.ReloadSpeed;
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.Reach) ?? true))
            {
                item.Reach = rhs.Reach;
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.MinRange) ?? true))
            {
                item.MinRange = rhs.MinRange;
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.MaxRange) ?? true))
            {
                item.MaxRange = rhs.MaxRange;
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.AttackDelay) ?? true))
            {
                item.AttackDelay = rhs.AttackDelay;
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.Unknown) ?? true))
            {
                item.Unknown = rhs.Unknown;
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.DamageOutOfRangeMult) ?? true))
            {
                item.DamageOutOfRangeMult = rhs.DamageOutOfRangeMult;
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.OnHit) ?? true))
            {
                item.OnHit = rhs.OnHit;
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.Skill) ?? true))
            {
                item.Skill.SetTo(rhs.Skill.FormKey);
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.Resist) ?? true))
            {
                item.Resist.SetTo(rhs.Resist.FormKey);
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.Flags) ?? true))
            {
                item.Flags = rhs.Flags;
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.Capacity) ?? true))
            {
                item.Capacity = rhs.Capacity;
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.AnimationType) ?? true))
            {
                item.AnimationType = rhs.AnimationType;
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.SecondaryDamage) ?? true))
            {
                item.SecondaryDamage = rhs.SecondaryDamage;
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.Weight) ?? true))
            {
                item.Weight = rhs.Weight;
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.Value) ?? true))
            {
                item.Value = rhs.Value;
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.BaseDamage) ?? true))
            {
                item.BaseDamage = rhs.BaseDamage;
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.SoundLevel) ?? true))
            {
                item.SoundLevel = rhs.SoundLevel;
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.AttackSound) ?? true))
            {
                item.AttackSound.SetTo(rhs.AttackSound.FormKey);
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.Attack2dSound) ?? true))
            {
                item.Attack2dSound.SetTo(rhs.Attack2dSound.FormKey);
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.AttackLoopSound) ?? true))
            {
                item.AttackLoopSound.SetTo(rhs.AttackLoopSound.FormKey);
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.AttackFailSound) ?? true))
            {
                item.AttackFailSound.SetTo(rhs.AttackFailSound.FormKey);
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.IdleSound) ?? true))
            {
                item.IdleSound.SetTo(rhs.IdleSound.FormKey);
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.EquipSound) ?? true))
            {
                item.EquipSound.SetTo(rhs.EquipSound.FormKey);
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.UnequipSound) ?? true))
            {
                item.UnequipSound.SetTo(rhs.UnequipSound.FormKey);
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.FastEquipSound) ?? true))
            {
                item.FastEquipSound.SetTo(rhs.FastEquipSound.FormKey);
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.AccuracyBonus) ?? true))
            {
                item.AccuracyBonus = rhs.AccuracyBonus;
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.AnimationAttackSeconds) ?? true))
            {
                item.AnimationAttackSeconds = rhs.AnimationAttackSeconds;
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.Unknown2) ?? true))
            {
                item.Unknown2 = rhs.Unknown2;
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.ActionPointCost) ?? true))
            {
                item.ActionPointCost = rhs.ActionPointCost;
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.FullPowerSeconds) ?? true))
            {
                item.FullPowerSeconds = rhs.FullPowerSeconds;
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.MinPowerPerShot) ?? true))
            {
                item.MinPowerPerShot = rhs.MinPowerPerShot;
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.Stagger) ?? true))
            {
                item.Stagger = rhs.Stagger;
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.Unknown3) ?? true))
            {
                item.Unknown3 = rhs.Unknown3;
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.ExtraData) ?? true))
            {
                errorMask?.PushIndex((int)Weapon_FieldIndex.ExtraData);
                try
                {
                    if(rhs.ExtraData is {} rhsExtraData)
                    {
                        item.ExtraData = rhsExtraData.DeepCopy(
                            errorMask: errorMask,
                            copyMask?.GetSubCrystal((int)Weapon_FieldIndex.ExtraData));
                    }
                    else
                    {
                        item.ExtraData = default;
                    }
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.CritDamageMult) ?? true))
            {
                item.CritDamageMult = rhs.CritDamageMult;
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.CritChargeBonus) ?? true))
            {
                item.CritChargeBonus = rhs.CritChargeBonus;
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.CritEffect) ?? true))
            {
                item.CritEffect.SetTo(rhs.CritEffect.FormKey);
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.ImpactDataSet) ?? true))
            {
                item.ImpactDataSet.SetTo(rhs.ImpactDataSet.FormKeyNullable);
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.NpcAddAmmoList) ?? true))
            {
                item.NpcAddAmmoList.SetTo(rhs.NpcAddAmmoList.FormKeyNullable);
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.AimModel) ?? true))
            {
                item.AimModel.SetTo(rhs.AimModel.FormKeyNullable);
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.Zoom) ?? true))
            {
                item.Zoom.SetTo(rhs.Zoom.FormKeyNullable);
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.Template) ?? true))
            {
                item.Template.SetTo(rhs.Template.FormKeyNullable);
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.DamageType) ?? true))
            {
                errorMask?.PushIndex((int)Weapon_FieldIndex.DamageType);
                try
                {
                    if(rhs.DamageType is {} rhsDamageType)
                    {
                        item.DamageType = rhsDamageType.DeepCopy(
                            errorMask: errorMask,
                            copyMask?.GetSubCrystal((int)Weapon_FieldIndex.DamageType));
                    }
                    else
                    {
                        item.DamageType = default;
                    }
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.Filter) ?? true))
            {
                item.Filter = rhs.Filter;
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.MeleeSpeed) ?? true))
            {
                item.MeleeSpeed = rhs.MeleeSpeed;
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.DNAMDataTypeState) ?? true))
            {
                item.DNAMDataTypeState = rhs.DNAMDataTypeState;
            }
            if ((copyMask?.GetShouldTranslate((int)Weapon_FieldIndex.CRDTDataTypeState) ?? true))
            {
                item.CRDTDataTypeState = rhs.CRDTDataTypeState;
            }
        }
        
        public override void DeepCopyIn(
            IFallout4MajorRecordInternal item,
            IFallout4MajorRecordGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask,
            bool deepCopy)
        {
            this.DeepCopyIn(
                item: (IWeaponInternal)item,
                rhs: (IWeaponGetter)rhs,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: deepCopy);
        }
        
        public override void DeepCopyIn(
            IFallout4MajorRecord item,
            IFallout4MajorRecordGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask,
            bool deepCopy)
        {
            this.DeepCopyIn(
                item: (IWeapon)item,
                rhs: (IWeaponGetter)rhs,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: deepCopy);
        }
        
        public override void DeepCopyIn(
            IMajorRecordInternal item,
            IMajorRecordGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask,
            bool deepCopy)
        {
            this.DeepCopyIn(
                item: (IWeaponInternal)item,
                rhs: (IWeaponGetter)rhs,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: deepCopy);
        }
        
        public override void DeepCopyIn(
            IMajorRecord item,
            IMajorRecordGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask,
            bool deepCopy)
        {
            this.DeepCopyIn(
                item: (IWeapon)item,
                rhs: (IWeaponGetter)rhs,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: deepCopy);
        }
        
        #endregion
        
        public Weapon DeepCopy(
            IWeaponGetter item,
            Weapon.TranslationMask? copyMask = null)
        {
            Weapon ret = (Weapon)((WeaponCommon)((IWeaponGetter)item).CommonInstance()!).GetNew();
            ((WeaponSetterTranslationCommon)((IWeaponGetter)ret).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: ret,
                rhs: item,
                errorMask: null,
                copyMask: copyMask?.GetCrystal(),
                deepCopy: true);
            return ret;
        }
        
        public Weapon DeepCopy(
            IWeaponGetter item,
            out Weapon.ErrorMask errorMask,
            Weapon.TranslationMask? copyMask = null)
        {
            var errorMaskBuilder = new ErrorMaskBuilder();
            Weapon ret = (Weapon)((WeaponCommon)((IWeaponGetter)item).CommonInstance()!).GetNew();
            ((WeaponSetterTranslationCommon)((IWeaponGetter)ret).CommonSetterTranslationInstance()!).DeepCopyIn(
                ret,
                item,
                errorMask: errorMaskBuilder,
                copyMask: copyMask?.GetCrystal(),
                deepCopy: true);
            errorMask = Weapon.ErrorMask.Factory(errorMaskBuilder);
            return ret;
        }
        
        public Weapon DeepCopy(
            IWeaponGetter item,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask = null)
        {
            Weapon ret = (Weapon)((WeaponCommon)((IWeaponGetter)item).CommonInstance()!).GetNew();
            ((WeaponSetterTranslationCommon)((IWeaponGetter)ret).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: ret,
                rhs: item,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: true);
            return ret;
        }
        
    }
    #endregion

}

namespace Mutagen.Bethesda.Fallout4
{
    public partial class Weapon
    {
        #region Common Routing
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILoquiRegistration ILoquiObject.Registration => Weapon_Registration.Instance;
        public new static ILoquiRegistration StaticRegistration => Weapon_Registration.Instance;
        [DebuggerStepThrough]
        protected override object CommonInstance() => WeaponCommon.Instance;
        [DebuggerStepThrough]
        protected override object CommonSetterInstance()
        {
            return WeaponSetterCommon.Instance;
        }
        [DebuggerStepThrough]
        protected override object CommonSetterTranslationInstance() => WeaponSetterTranslationCommon.Instance;

        #endregion

    }
}

#region Modules
#region Binary Translation
namespace Mutagen.Bethesda.Fallout4
{
    public partial class WeaponBinaryWriteTranslation :
        Fallout4MajorRecordBinaryWriteTranslation,
        IBinaryWriteTranslator
    {
        public new readonly static WeaponBinaryWriteTranslation Instance = new WeaponBinaryWriteTranslation();

        public static void WriteEmbedded(
            IWeaponGetter item,
            MutagenWriter writer)
        {
            Fallout4MajorRecordBinaryWriteTranslation.WriteEmbedded(
                item: item,
                writer: writer);
        }

        public static void WriteRecordTypes(
            IWeaponGetter item,
            MutagenWriter writer,
            TypedWriteParams? translationParams)
        {
            MajorRecordBinaryWriteTranslation.WriteRecordTypes(
                item: item,
                writer: writer,
                translationParams: translationParams);
            if (item.VirtualMachineAdapter is {} VirtualMachineAdapterItem)
            {
                ((VirtualMachineAdapterBinaryWriteTranslation)((IBinaryItem)VirtualMachineAdapterItem).BinaryWriteTranslator).Write(
                    item: VirtualMachineAdapterItem,
                    writer: writer,
                    translationParams: translationParams);
            }
            var ObjectBoundsItem = item.ObjectBounds;
            ((ObjectBoundsBinaryWriteTranslation)((IBinaryItem)ObjectBoundsItem).BinaryWriteTranslator).Write(
                item: ObjectBoundsItem,
                writer: writer,
                translationParams: translationParams);
            FormLinkBinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.PreviewTransform,
                header: translationParams.ConvertToCustom(RecordTypes.PTRN));
            FormLinkBinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.AnimationSound,
                header: translationParams.ConvertToCustom(RecordTypes.STCP));
            StringBinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.Name,
                header: translationParams.ConvertToCustom(RecordTypes.FULL),
                binaryType: StringBinaryType.NullTerminate,
                source: StringsSource.Normal);
            if (item.Model is {} ModelItem)
            {
                ((ModelBinaryWriteTranslation)((IBinaryItem)ModelItem).BinaryWriteTranslator).Write(
                    item: ModelItem,
                    writer: writer,
                    translationParams: translationParams);
            }
            if (item.Icons is {} IconsItem)
            {
                ((IconsBinaryWriteTranslation)((IBinaryItem)IconsItem).BinaryWriteTranslator).Write(
                    item: IconsItem,
                    writer: writer,
                    translationParams: translationParams);
            }
            FormLinkBinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.ObjectEffect,
                header: translationParams.ConvertToCustom(RecordTypes.EITM));
            UInt16BinaryTranslation<MutagenFrame, MutagenWriter>.Instance.WriteNullable(
                writer: writer,
                item: item.EnchantmentAmount,
                header: translationParams.ConvertToCustom(RecordTypes.EAMT));
            if (item.Destructible is {} DestructibleItem)
            {
                ((DestructibleBinaryWriteTranslation)((IBinaryItem)DestructibleItem).BinaryWriteTranslator).Write(
                    item: DestructibleItem,
                    writer: writer,
                    translationParams: translationParams);
            }
            FormLinkBinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.EquipmentType,
                header: translationParams.ConvertToCustom(RecordTypes.ETYP));
            FormLinkBinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.BlockBashImpactDataSet,
                header: translationParams.ConvertToCustom(RecordTypes.BIDS));
            FormLinkBinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.AlternateBlockMaterial,
                header: translationParams.ConvertToCustom(RecordTypes.BAMT));
            FormLinkBinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.PickUpSound,
                header: translationParams.ConvertToCustom(RecordTypes.YNAM));
            FormLinkBinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.PutDownSound,
                header: translationParams.ConvertToCustom(RecordTypes.ZNAM));
            Mutagen.Bethesda.Plugins.Binary.Translations.ListBinaryTranslation<IFormLinkGetter<IKeywordGetter>>.Instance.WriteWithCounter(
                writer: writer,
                items: item.Keywords,
                counterType: RecordTypes.KSIZ,
                counterLength: 4,
                recordType: translationParams.ConvertToCustom(RecordTypes.KWDA),
                transl: (MutagenWriter subWriter, IFormLinkGetter<IKeywordGetter> subItem, TypedWriteParams? conv) =>
                {
                    FormLinkBinaryTranslation.Instance.Write(
                        writer: subWriter,
                        item: subItem);
                });
            StringBinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.Description,
                header: translationParams.ConvertToCustom(RecordTypes.DESC),
                binaryType: StringBinaryType.NullTerminate,
                source: StringsSource.Normal);
            FormLinkBinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.InstanceNaming,
                header: translationParams.ConvertToCustom(RecordTypes.INRD));
            Mutagen.Bethesda.Plugins.Binary.Translations.ListBinaryTranslation<IFormLinkGetter<IKeywordGetter>>.Instance.Write(
                writer: writer,
                items: item.AttachParentSlots,
                recordType: translationParams.ConvertToCustom(RecordTypes.APPR),
                transl: (MutagenWriter subWriter, IFormLinkGetter<IKeywordGetter> subItem, TypedWriteParams? conv) =>
                {
                    FormLinkBinaryTranslation.Instance.Write(
                        writer: subWriter,
                        item: subItem);
                });
            Mutagen.Bethesda.Plugins.Binary.Translations.ListBinaryTranslation<IObjectTemplateGetter<Weapon.Property>>.Instance.WriteWithCounter(
                writer: writer,
                items: item.ObjectTemplates,
                counterType: RecordTypes.OBTE,
                counterLength: 4,
                endMarker: RecordTypes.STOP,
                transl: (MutagenWriter subWriter, IObjectTemplateGetter<Weapon.Property> subItem, TypedWriteParams? conv) =>
                {
                    var Item = subItem;
                    ((ObjectTemplateBinaryWriteTranslation)((IBinaryItem)Item).BinaryWriteTranslator).Write<Weapon.Property>(
                        item: Item,
                        writer: subWriter,
                        translationParams: conv);
                });
            FormLinkBinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.EmbeddedWeaponMod,
                header: translationParams.ConvertToCustom(RecordTypes.NNAM));
            if (item.FirstPersonModel is {} FirstPersonModelItem)
            {
                ((ModelBinaryWriteTranslation)((IBinaryItem)FirstPersonModelItem).BinaryWriteTranslator).Write(
                    item: FirstPersonModelItem,
                    writer: writer,
                    translationParams: translationParams.With(Weapon_Registration.FirstPersonModelConverter));
            }
            FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.WriteNullable(
                writer: writer,
                item: item.FirstPersonColorRemappingIndex,
                header: translationParams.ConvertToCustom(RecordTypes.MO4C));
            Int32BinaryTranslation<MutagenFrame, MutagenWriter>.Instance.WriteNullable(
                writer: writer,
                item: item.MO4F,
                header: translationParams.ConvertToCustom(RecordTypes.MO4F));
            using (HeaderExport.Subrecord(writer, translationParams.ConvertToCustom(RecordTypes.DNAM)))
            {
                FormLinkBinaryTranslation.Instance.Write(
                    writer: writer,
                    item: item.Ammo);
                FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Write(
                    writer: writer,
                    item: item.Speed);
                FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Write(
                    writer: writer,
                    item: item.ReloadSpeed);
                FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Write(
                    writer: writer,
                    item: item.Reach);
                FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Write(
                    writer: writer,
                    item: item.MinRange);
                FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Write(
                    writer: writer,
                    item: item.MaxRange);
                FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Write(
                    writer: writer,
                    item: item.AttackDelay);
                FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Write(
                    writer: writer,
                    item: item.Unknown);
                FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Write(
                    writer: writer,
                    item: item.DamageOutOfRangeMult);
                EnumBinaryTranslation<Weapon.HitBehavior, MutagenFrame, MutagenWriter>.Instance.Write(
                    writer,
                    item.OnHit,
                    length: 4);
                FormLinkBinaryTranslation.Instance.Write(
                    writer: writer,
                    item: item.Skill);
                FormLinkBinaryTranslation.Instance.Write(
                    writer: writer,
                    item: item.Resist);
                EnumBinaryTranslation<Weapon.Flag, MutagenFrame, MutagenWriter>.Instance.Write(
                    writer,
                    item.Flags,
                    length: 4);
                writer.Write(item.Capacity);
                EnumBinaryTranslation<Weapon.AnimationTypes, MutagenFrame, MutagenWriter>.Instance.Write(
                    writer,
                    item.AnimationType,
                    length: 1);
                FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Write(
                    writer: writer,
                    item: item.SecondaryDamage);
                FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Write(
                    writer: writer,
                    item: item.Weight);
                writer.Write(item.Value);
                writer.Write(item.BaseDamage);
                EnumBinaryTranslation<SoundLevel, MutagenFrame, MutagenWriter>.Instance.Write(
                    writer,
                    item.SoundLevel,
                    length: 4);
                FormLinkBinaryTranslation.Instance.Write(
                    writer: writer,
                    item: item.AttackSound);
                FormLinkBinaryTranslation.Instance.Write(
                    writer: writer,
                    item: item.Attack2dSound);
                FormLinkBinaryTranslation.Instance.Write(
                    writer: writer,
                    item: item.AttackLoopSound);
                FormLinkBinaryTranslation.Instance.Write(
                    writer: writer,
                    item: item.AttackFailSound);
                FormLinkBinaryTranslation.Instance.Write(
                    writer: writer,
                    item: item.IdleSound);
                FormLinkBinaryTranslation.Instance.Write(
                    writer: writer,
                    item: item.EquipSound);
                FormLinkBinaryTranslation.Instance.Write(
                    writer: writer,
                    item: item.UnequipSound);
                FormLinkBinaryTranslation.Instance.Write(
                    writer: writer,
                    item: item.FastEquipSound);
                writer.Write(item.AccuracyBonus);
                FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Write(
                    writer: writer,
                    item: item.AnimationAttackSeconds);
                writer.Write(item.Unknown2);
                FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Write(
                    writer: writer,
                    item: item.ActionPointCost);
                FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Write(
                    writer: writer,
                    item: item.FullPowerSeconds);
                FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Write(
                    writer: writer,
                    item: item.MinPowerPerShot);
                EnumBinaryTranslation<Stagger, MutagenFrame, MutagenWriter>.Instance.Write(
                    writer,
                    item.Stagger,
                    length: 4);
                writer.Write(item.Unknown3);
            }
            if (item.ExtraData is {} ExtraDataItem)
            {
                ((WeaponExtraDataBinaryWriteTranslation)((IBinaryItem)ExtraDataItem).BinaryWriteTranslator).Write(
                    item: ExtraDataItem,
                    writer: writer,
                    translationParams: translationParams);
            }
            using (HeaderExport.Subrecord(writer, translationParams.ConvertToCustom(RecordTypes.CRDT)))
            {
                FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Write(
                    writer: writer,
                    item: item.CritDamageMult);
                FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Write(
                    writer: writer,
                    item: item.CritChargeBonus);
                FormLinkBinaryTranslation.Instance.Write(
                    writer: writer,
                    item: item.CritEffect);
            }
            FormLinkBinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.ImpactDataSet,
                header: translationParams.ConvertToCustom(RecordTypes.INAM));
            FormLinkBinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.NpcAddAmmoList,
                header: translationParams.ConvertToCustom(RecordTypes.LNAM));
            FormLinkBinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.AimModel,
                header: translationParams.ConvertToCustom(RecordTypes.WAMD));
            FormLinkBinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.Zoom,
                header: translationParams.ConvertToCustom(RecordTypes.WZMD));
            FormLinkBinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.Template,
                header: translationParams.ConvertToCustom(RecordTypes.CNAM));
            if (item.DamageType is {} DamageTypeItem)
            {
                ((WeaponDamageTypeBinaryWriteTranslation)((IBinaryItem)DamageTypeItem).BinaryWriteTranslator).Write(
                    item: DamageTypeItem,
                    writer: writer,
                    translationParams: translationParams);
            }
            StringBinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.Filter,
                header: translationParams.ConvertToCustom(RecordTypes.FLTR),
                binaryType: StringBinaryType.NullTerminate);
            EnumBinaryTranslation<Weapon.MeleeSpeeds, MutagenFrame, MutagenWriter>.Instance.WriteNullable(
                writer,
                item.MeleeSpeed,
                length: 4,
                header: translationParams.ConvertToCustom(RecordTypes.MASE));
        }

        public void Write(
            MutagenWriter writer,
            IWeaponGetter item,
            TypedWriteParams? translationParams = null)
        {
            using (HeaderExport.Record(
                writer: writer,
                record: translationParams.ConvertToCustom(RecordTypes.WEAP)))
            {
                try
                {
                    WriteEmbedded(
                        item: item,
                        writer: writer);
                    writer.MetaData.FormVersion = item.FormVersion;
                    WriteRecordTypes(
                        item: item,
                        writer: writer,
                        translationParams: translationParams);
                    writer.MetaData.FormVersion = null;
                }
                catch (Exception ex)
                {
                    throw RecordException.Enrich(ex, item);
                }
            }
        }

        public override void Write(
            MutagenWriter writer,
            object item,
            TypedWriteParams? translationParams = null)
        {
            Write(
                item: (IWeaponGetter)item,
                writer: writer,
                translationParams: translationParams);
        }

        public override void Write(
            MutagenWriter writer,
            IFallout4MajorRecordGetter item,
            TypedWriteParams? translationParams = null)
        {
            Write(
                item: (IWeaponGetter)item,
                writer: writer,
                translationParams: translationParams);
        }

        public override void Write(
            MutagenWriter writer,
            IMajorRecordGetter item,
            TypedWriteParams? translationParams = null)
        {
            Write(
                item: (IWeaponGetter)item,
                writer: writer,
                translationParams: translationParams);
        }

    }

    internal partial class WeaponBinaryCreateTranslation : Fallout4MajorRecordBinaryCreateTranslation
    {
        public new readonly static WeaponBinaryCreateTranslation Instance = new WeaponBinaryCreateTranslation();

        public override RecordType RecordType => RecordTypes.WEAP;
        public static void FillBinaryStructs(
            IWeaponInternal item,
            MutagenFrame frame)
        {
            Fallout4MajorRecordBinaryCreateTranslation.FillBinaryStructs(
                item: item,
                frame: frame);
        }

        public static ParseResult FillBinaryRecordTypes(
            IWeaponInternal item,
            MutagenFrame frame,
            PreviousParse lastParsed,
            Dictionary<RecordType, int>? recordParseCount,
            RecordType nextRecordType,
            int contentLength,
            TypedParseParams? translationParams = null)
        {
            nextRecordType = translationParams.ConvertToStandard(nextRecordType);
            switch (nextRecordType.TypeInt)
            {
                case RecordTypeInts.VMAD:
                {
                    item.VirtualMachineAdapter = Mutagen.Bethesda.Fallout4.VirtualMachineAdapter.CreateFromBinary(frame: frame);
                    return (int)Weapon_FieldIndex.VirtualMachineAdapter;
                }
                case RecordTypeInts.OBND:
                {
                    item.ObjectBounds = Mutagen.Bethesda.Fallout4.ObjectBounds.CreateFromBinary(frame: frame);
                    return (int)Weapon_FieldIndex.ObjectBounds;
                }
                case RecordTypeInts.PTRN:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.PreviewTransform.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                    return (int)Weapon_FieldIndex.PreviewTransform;
                }
                case RecordTypeInts.STCP:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.AnimationSound.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                    return (int)Weapon_FieldIndex.AnimationSound;
                }
                case RecordTypeInts.FULL:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.Name = StringBinaryTranslation.Instance.Parse(
                        reader: frame.SpawnWithLength(contentLength),
                        source: StringsSource.Normal,
                        stringBinaryType: StringBinaryType.NullTerminate);
                    return (int)Weapon_FieldIndex.Name;
                }
                case RecordTypeInts.MODL:
                {
                    item.Model = Mutagen.Bethesda.Fallout4.Model.CreateFromBinary(
                        frame: frame,
                        translationParams: translationParams);
                    return (int)Weapon_FieldIndex.Model;
                }
                case RecordTypeInts.ICON:
                case RecordTypeInts.MICO:
                {
                    item.Icons = Mutagen.Bethesda.Fallout4.Icons.CreateFromBinary(
                        frame: frame,
                        translationParams: translationParams);
                    return (int)Weapon_FieldIndex.Icons;
                }
                case RecordTypeInts.EITM:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.ObjectEffect.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                    return (int)Weapon_FieldIndex.ObjectEffect;
                }
                case RecordTypeInts.EAMT:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.EnchantmentAmount = frame.ReadUInt16();
                    return (int)Weapon_FieldIndex.EnchantmentAmount;
                }
                case RecordTypeInts.DEST:
                case RecordTypeInts.DAMC:
                case RecordTypeInts.DSTD:
                case RecordTypeInts.DSTA:
                case RecordTypeInts.DMDL:
                {
                    item.Destructible = Mutagen.Bethesda.Fallout4.Destructible.CreateFromBinary(
                        frame: frame,
                        translationParams: translationParams);
                    return (int)Weapon_FieldIndex.Destructible;
                }
                case RecordTypeInts.ETYP:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.EquipmentType.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                    return (int)Weapon_FieldIndex.EquipmentType;
                }
                case RecordTypeInts.BIDS:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.BlockBashImpactDataSet.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                    return (int)Weapon_FieldIndex.BlockBashImpactDataSet;
                }
                case RecordTypeInts.BAMT:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.AlternateBlockMaterial.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                    return (int)Weapon_FieldIndex.AlternateBlockMaterial;
                }
                case RecordTypeInts.YNAM:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.PickUpSound.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                    return (int)Weapon_FieldIndex.PickUpSound;
                }
                case RecordTypeInts.ZNAM:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.PutDownSound.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                    return (int)Weapon_FieldIndex.PutDownSound;
                }
                case RecordTypeInts.KWDA:
                case RecordTypeInts.KSIZ:
                {
                    item.Keywords = 
                        Mutagen.Bethesda.Plugins.Binary.Translations.ListBinaryTranslation<IFormLinkGetter<IKeywordGetter>>.Instance.Parse(
                            reader: frame,
                            countLengthLength: 4,
                            countRecord: translationParams.ConvertToCustom(RecordTypes.KSIZ),
                            triggeringRecord: translationParams.ConvertToCustom(RecordTypes.KWDA),
                            transl: FormLinkBinaryTranslation.Instance.Parse)
                        .CastExtendedList<IFormLinkGetter<IKeywordGetter>>();
                    return (int)Weapon_FieldIndex.Keywords;
                }
                case RecordTypeInts.DESC:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.Description = StringBinaryTranslation.Instance.Parse(
                        reader: frame.SpawnWithLength(contentLength),
                        source: StringsSource.Normal,
                        stringBinaryType: StringBinaryType.NullTerminate);
                    return (int)Weapon_FieldIndex.Description;
                }
                case RecordTypeInts.INRD:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.InstanceNaming.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                    return (int)Weapon_FieldIndex.InstanceNaming;
                }
                case RecordTypeInts.APPR:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.AttachParentSlots = 
                        Mutagen.Bethesda.Plugins.Binary.Translations.ListBinaryTranslation<IFormLinkGetter<IKeywordGetter>>.Instance.Parse(
                            reader: frame.SpawnWithLength(contentLength),
                            transl: FormLinkBinaryTranslation.Instance.Parse)
                        .CastExtendedList<IFormLinkGetter<IKeywordGetter>>();
                    return (int)Weapon_FieldIndex.AttachParentSlots;
                }
                case RecordTypeInts.OBTE:
                {
                    item.ObjectTemplates = 
                        Mutagen.Bethesda.Plugins.Binary.Translations.ListBinaryTranslation<ObjectTemplate<Weapon.Property>>.Instance.ParsePerItem(
                            reader: frame,
                            countLengthLength: 4,
                            countRecord: RecordTypes.OBTE,
                            triggeringRecord: ObjectTemplate_Registration.TriggerSpecs,
                            translationParams: translationParams,
                            transl: ObjectTemplate<Weapon.Property>.TryCreateFromBinary)
                        .CastExtendedList<ObjectTemplate<Weapon.Property>>();
                    return (int)Weapon_FieldIndex.ObjectTemplates;
                }
                case RecordTypeInts.NNAM:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.EmbeddedWeaponMod.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                    return (int)Weapon_FieldIndex.EmbeddedWeaponMod;
                }
                case RecordTypeInts.MOD4:
                {
                    item.FirstPersonModel = Mutagen.Bethesda.Fallout4.Model.CreateFromBinary(
                        frame: frame,
                        translationParams: translationParams.With(Weapon_Registration.FirstPersonModelConverter));
                    return (int)Weapon_FieldIndex.FirstPersonModel;
                }
                case RecordTypeInts.MO4C:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.FirstPersonColorRemappingIndex = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: frame.SpawnWithLength(contentLength));
                    return (int)Weapon_FieldIndex.FirstPersonColorRemappingIndex;
                }
                case RecordTypeInts.MO4F:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.MO4F = frame.ReadInt32();
                    return (int)Weapon_FieldIndex.MO4F;
                }
                case RecordTypeInts.DNAM:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    var dataFrame = frame.SpawnWithLength(contentLength);
                    item.Ammo.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                    item.Speed = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: dataFrame);
                    item.ReloadSpeed = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: dataFrame);
                    item.Reach = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: dataFrame);
                    item.MinRange = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: dataFrame);
                    item.MaxRange = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: dataFrame);
                    item.AttackDelay = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: dataFrame);
                    item.Unknown = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: dataFrame);
                    item.DamageOutOfRangeMult = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: dataFrame);
                    item.OnHit = EnumBinaryTranslation<Weapon.HitBehavior, MutagenFrame, MutagenWriter>.Instance.Parse(
                        reader: dataFrame,
                        length: 4);
                    item.Skill.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                    item.Resist.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                    item.Flags = EnumBinaryTranslation<Weapon.Flag, MutagenFrame, MutagenWriter>.Instance.Parse(
                        reader: dataFrame,
                        length: 4);
                    item.Capacity = dataFrame.ReadUInt16();
                    item.AnimationType = EnumBinaryTranslation<Weapon.AnimationTypes, MutagenFrame, MutagenWriter>.Instance.Parse(
                        reader: dataFrame,
                        length: 1);
                    item.SecondaryDamage = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: dataFrame);
                    item.Weight = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: dataFrame);
                    item.Value = dataFrame.ReadUInt32();
                    item.BaseDamage = dataFrame.ReadUInt16();
                    item.SoundLevel = EnumBinaryTranslation<SoundLevel, MutagenFrame, MutagenWriter>.Instance.Parse(
                        reader: dataFrame,
                        length: 4);
                    item.AttackSound.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                    item.Attack2dSound.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                    item.AttackLoopSound.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                    item.AttackFailSound.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                    item.IdleSound.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                    item.EquipSound.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                    item.UnequipSound.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                    item.FastEquipSound.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                    item.AccuracyBonus = dataFrame.ReadUInt8();
                    item.AnimationAttackSeconds = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: dataFrame);
                    item.Unknown2 = dataFrame.ReadUInt16();
                    item.ActionPointCost = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: dataFrame);
                    item.FullPowerSeconds = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: dataFrame);
                    item.MinPowerPerShot = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: dataFrame);
                    item.Stagger = EnumBinaryTranslation<Stagger, MutagenFrame, MutagenWriter>.Instance.Parse(
                        reader: dataFrame,
                        length: 4);
                    item.Unknown3 = dataFrame.ReadInt32();
                    return (int)Weapon_FieldIndex.Unknown3;
                }
                case RecordTypeInts.FNAM:
                {
                    item.ExtraData = Mutagen.Bethesda.Fallout4.WeaponExtraData.CreateFromBinary(frame: frame);
                    return (int)Weapon_FieldIndex.ExtraData;
                }
                case RecordTypeInts.CRDT:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    var dataFrame = frame.SpawnWithLength(contentLength);
                    item.CritDamageMult = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: dataFrame);
                    item.CritChargeBonus = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: dataFrame);
                    item.CritEffect.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                    return (int)Weapon_FieldIndex.CritEffect;
                }
                case RecordTypeInts.INAM:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.ImpactDataSet.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                    return (int)Weapon_FieldIndex.ImpactDataSet;
                }
                case RecordTypeInts.LNAM:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.NpcAddAmmoList.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                    return (int)Weapon_FieldIndex.NpcAddAmmoList;
                }
                case RecordTypeInts.WAMD:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.AimModel.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                    return (int)Weapon_FieldIndex.AimModel;
                }
                case RecordTypeInts.WZMD:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.Zoom.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                    return (int)Weapon_FieldIndex.Zoom;
                }
                case RecordTypeInts.CNAM:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.Template.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                    return (int)Weapon_FieldIndex.Template;
                }
                case RecordTypeInts.DAMA:
                {
                    item.DamageType = Mutagen.Bethesda.Fallout4.WeaponDamageType.CreateFromBinary(frame: frame);
                    return (int)Weapon_FieldIndex.DamageType;
                }
                case RecordTypeInts.FLTR:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.Filter = StringBinaryTranslation.Instance.Parse(
                        reader: frame.SpawnWithLength(contentLength),
                        stringBinaryType: StringBinaryType.NullTerminate);
                    return (int)Weapon_FieldIndex.Filter;
                }
                case RecordTypeInts.MASE:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.MeleeSpeed = EnumBinaryTranslation<Weapon.MeleeSpeeds, MutagenFrame, MutagenWriter>.Instance.Parse(
                        reader: frame,
                        length: contentLength);
                    return (int)Weapon_FieldIndex.MeleeSpeed;
                }
                default:
                    return Fallout4MajorRecordBinaryCreateTranslation.FillBinaryRecordTypes(
                        item: item,
                        frame: frame,
                        lastParsed: lastParsed,
                        recordParseCount: recordParseCount,
                        nextRecordType: nextRecordType,
                        contentLength: contentLength);
            }
        }

    }

}
namespace Mutagen.Bethesda.Fallout4
{
    #region Binary Write Mixins
    public static class WeaponBinaryTranslationMixIn
    {
    }
    #endregion


}
namespace Mutagen.Bethesda.Fallout4
{
    internal partial class WeaponBinaryOverlay :
        Fallout4MajorRecordBinaryOverlay,
        IWeaponGetter
    {
        #region Common Routing
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILoquiRegistration ILoquiObject.Registration => Weapon_Registration.Instance;
        public new static ILoquiRegistration StaticRegistration => Weapon_Registration.Instance;
        [DebuggerStepThrough]
        protected override object CommonInstance() => WeaponCommon.Instance;
        [DebuggerStepThrough]
        protected override object CommonSetterTranslationInstance() => WeaponSetterTranslationCommon.Instance;

        #endregion

        void IPrintable.ToString(StructuredStringBuilder sb, string? name) => this.ToString(sb, name);

        public override IEnumerable<IFormLinkGetter> ContainedFormLinks => WeaponCommon.Instance.GetContainedFormLinks(this);
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected override object BinaryWriteTranslator => WeaponBinaryWriteTranslation.Instance;
        void IBinaryItem.WriteToBinary(
            MutagenWriter writer,
            TypedWriteParams? translationParams = null)
        {
            ((WeaponBinaryWriteTranslation)this.BinaryWriteTranslator).Write(
                item: this,
                writer: writer,
                translationParams: translationParams);
        }
        protected override Type LinkType => typeof(IWeapon);

        public Weapon.MajorFlag MajorFlags => (Weapon.MajorFlag)this.MajorRecordFlagsRaw;

        #region VirtualMachineAdapter
        private RangeInt32? _VirtualMachineAdapterLocation;
        public IVirtualMachineAdapterGetter? VirtualMachineAdapter => _VirtualMachineAdapterLocation.HasValue ? VirtualMachineAdapterBinaryOverlay.VirtualMachineAdapterFactory(new OverlayStream(_data.Slice(_VirtualMachineAdapterLocation!.Value.Min), _package), _package) : default;
        #endregion
        #region ObjectBounds
        private RangeInt32? _ObjectBoundsLocation;
        private IObjectBoundsGetter? _ObjectBounds => _ObjectBoundsLocation.HasValue ? ObjectBoundsBinaryOverlay.ObjectBoundsFactory(new OverlayStream(_data.Slice(_ObjectBoundsLocation!.Value.Min), _package), _package) : default;
        public IObjectBoundsGetter ObjectBounds => _ObjectBounds ?? new ObjectBounds();
        #endregion
        #region PreviewTransform
        private int? _PreviewTransformLocation;
        public IFormLinkNullableGetter<ITransformGetter> PreviewTransform => _PreviewTransformLocation.HasValue ? new FormLinkNullable<ITransformGetter>(FormKey.Factory(_package.MetaData.MasterReferences!, BinaryPrimitives.ReadUInt32LittleEndian(HeaderTranslation.ExtractSubrecordMemory(_data, _PreviewTransformLocation.Value, _package.MetaData.Constants)))) : FormLinkNullable<ITransformGetter>.Null;
        #endregion
        #region AnimationSound
        private int? _AnimationSoundLocation;
        public IFormLinkNullableGetter<IAnimationSoundTagSetGetter> AnimationSound => _AnimationSoundLocation.HasValue ? new FormLinkNullable<IAnimationSoundTagSetGetter>(FormKey.Factory(_package.MetaData.MasterReferences!, BinaryPrimitives.ReadUInt32LittleEndian(HeaderTranslation.ExtractSubrecordMemory(_data, _AnimationSoundLocation.Value, _package.MetaData.Constants)))) : FormLinkNullable<IAnimationSoundTagSetGetter>.Null;
        #endregion
        #region Name
        private int? _NameLocation;
        public ITranslatedStringGetter? Name => _NameLocation.HasValue ? StringBinaryTranslation.Instance.Parse(HeaderTranslation.ExtractSubrecordMemory(_data, _NameLocation.Value, _package.MetaData.Constants), StringsSource.Normal, parsingBundle: _package.MetaData) : default(TranslatedString?);
        #region Aspects
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        string INamedRequiredGetter.Name => this.Name?.String ?? string.Empty;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        string? INamedGetter.Name => this.Name?.String;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ITranslatedStringGetter ITranslatedNamedRequiredGetter.Name => this.Name ?? TranslatedString.Empty;
        #endregion
        #endregion
        public IModelGetter? Model { get; private set; }
        public IIconsGetter? Icons { get; private set; }
        #region ObjectEffect
        private int? _ObjectEffectLocation;
        public IFormLinkNullableGetter<IEffectRecordGetter> ObjectEffect => _ObjectEffectLocation.HasValue ? new FormLinkNullable<IEffectRecordGetter>(FormKey.Factory(_package.MetaData.MasterReferences!, BinaryPrimitives.ReadUInt32LittleEndian(HeaderTranslation.ExtractSubrecordMemory(_data, _ObjectEffectLocation.Value, _package.MetaData.Constants)))) : FormLinkNullable<IEffectRecordGetter>.Null;
        #endregion
        #region EnchantmentAmount
        private int? _EnchantmentAmountLocation;
        public UInt16? EnchantmentAmount => _EnchantmentAmountLocation.HasValue ? BinaryPrimitives.ReadUInt16LittleEndian(HeaderTranslation.ExtractSubrecordMemory(_data, _EnchantmentAmountLocation.Value, _package.MetaData.Constants)) : default(UInt16?);
        #endregion
        public IDestructibleGetter? Destructible { get; private set; }
        #region EquipmentType
        private int? _EquipmentTypeLocation;
        public IFormLinkNullableGetter<IEquipTypeGetter> EquipmentType => _EquipmentTypeLocation.HasValue ? new FormLinkNullable<IEquipTypeGetter>(FormKey.Factory(_package.MetaData.MasterReferences!, BinaryPrimitives.ReadUInt32LittleEndian(HeaderTranslation.ExtractSubrecordMemory(_data, _EquipmentTypeLocation.Value, _package.MetaData.Constants)))) : FormLinkNullable<IEquipTypeGetter>.Null;
        #endregion
        #region BlockBashImpactDataSet
        private int? _BlockBashImpactDataSetLocation;
        public IFormLinkNullableGetter<IImpactDataSetGetter> BlockBashImpactDataSet => _BlockBashImpactDataSetLocation.HasValue ? new FormLinkNullable<IImpactDataSetGetter>(FormKey.Factory(_package.MetaData.MasterReferences!, BinaryPrimitives.ReadUInt32LittleEndian(HeaderTranslation.ExtractSubrecordMemory(_data, _BlockBashImpactDataSetLocation.Value, _package.MetaData.Constants)))) : FormLinkNullable<IImpactDataSetGetter>.Null;
        #endregion
        #region AlternateBlockMaterial
        private int? _AlternateBlockMaterialLocation;
        public IFormLinkNullableGetter<IMaterialTypeGetter> AlternateBlockMaterial => _AlternateBlockMaterialLocation.HasValue ? new FormLinkNullable<IMaterialTypeGetter>(FormKey.Factory(_package.MetaData.MasterReferences!, BinaryPrimitives.ReadUInt32LittleEndian(HeaderTranslation.ExtractSubrecordMemory(_data, _AlternateBlockMaterialLocation.Value, _package.MetaData.Constants)))) : FormLinkNullable<IMaterialTypeGetter>.Null;
        #endregion
        #region PickUpSound
        private int? _PickUpSoundLocation;
        public IFormLinkNullableGetter<ISoundDescriptorGetter> PickUpSound => _PickUpSoundLocation.HasValue ? new FormLinkNullable<ISoundDescriptorGetter>(FormKey.Factory(_package.MetaData.MasterReferences!, BinaryPrimitives.ReadUInt32LittleEndian(HeaderTranslation.ExtractSubrecordMemory(_data, _PickUpSoundLocation.Value, _package.MetaData.Constants)))) : FormLinkNullable<ISoundDescriptorGetter>.Null;
        #endregion
        #region PutDownSound
        private int? _PutDownSoundLocation;
        public IFormLinkNullableGetter<ISoundDescriptorGetter> PutDownSound => _PutDownSoundLocation.HasValue ? new FormLinkNullable<ISoundDescriptorGetter>(FormKey.Factory(_package.MetaData.MasterReferences!, BinaryPrimitives.ReadUInt32LittleEndian(HeaderTranslation.ExtractSubrecordMemory(_data, _PutDownSoundLocation.Value, _package.MetaData.Constants)))) : FormLinkNullable<ISoundDescriptorGetter>.Null;
        #endregion
        #region Keywords
        public IReadOnlyList<IFormLinkGetter<IKeywordGetter>>? Keywords { get; private set; }
        IReadOnlyList<IFormLinkGetter<IKeywordCommonGetter>>? IKeywordedGetter.Keywords => this.Keywords;
        #endregion
        #region Description
        private int? _DescriptionLocation;
        public ITranslatedStringGetter? Description => _DescriptionLocation.HasValue ? StringBinaryTranslation.Instance.Parse(HeaderTranslation.ExtractSubrecordMemory(_data, _DescriptionLocation.Value, _package.MetaData.Constants), StringsSource.Normal, parsingBundle: _package.MetaData) : default(TranslatedString?);
        #endregion
        #region InstanceNaming
        private int? _InstanceNamingLocation;
        public IFormLinkNullableGetter<IInstanceNamingRuleGetter> InstanceNaming => _InstanceNamingLocation.HasValue ? new FormLinkNullable<IInstanceNamingRuleGetter>(FormKey.Factory(_package.MetaData.MasterReferences!, BinaryPrimitives.ReadUInt32LittleEndian(HeaderTranslation.ExtractSubrecordMemory(_data, _InstanceNamingLocation.Value, _package.MetaData.Constants)))) : FormLinkNullable<IInstanceNamingRuleGetter>.Null;
        #endregion
        public IReadOnlyList<IFormLinkGetter<IKeywordGetter>>? AttachParentSlots { get; private set; }
        public IReadOnlyList<IObjectTemplateGetter<Weapon.Property>>? ObjectTemplates { get; private set; }
        #region EmbeddedWeaponMod
        private int? _EmbeddedWeaponModLocation;
        public IFormLinkNullableGetter<IObjectModificationGetter> EmbeddedWeaponMod => _EmbeddedWeaponModLocation.HasValue ? new FormLinkNullable<IObjectModificationGetter>(FormKey.Factory(_package.MetaData.MasterReferences!, BinaryPrimitives.ReadUInt32LittleEndian(HeaderTranslation.ExtractSubrecordMemory(_data, _EmbeddedWeaponModLocation.Value, _package.MetaData.Constants)))) : FormLinkNullable<IObjectModificationGetter>.Null;
        #endregion
        public IModelGetter? FirstPersonModel { get; private set; }
        #region FirstPersonColorRemappingIndex
        private int? _FirstPersonColorRemappingIndexLocation;
        public Single? FirstPersonColorRemappingIndex => _FirstPersonColorRemappingIndexLocation.HasValue ? HeaderTranslation.ExtractSubrecordMemory(_data, _FirstPersonColorRemappingIndexLocation.Value, _package.MetaData.Constants).Float() : default(Single?);
        #endregion
        #region MO4F
        private int? _MO4FLocation;
        public Int32? MO4F => _MO4FLocation.HasValue ? BinaryPrimitives.ReadInt32LittleEndian(HeaderTranslation.ExtractSubrecordMemory(_data, _MO4FLocation.Value, _package.MetaData.Constants)) : default(Int32?);
        #endregion
        private RangeInt32? _DNAMLocation;
        public Weapon.DNAMDataType DNAMDataTypeState { get; private set; }
        #region Ammo
        private int _AmmoLocation => _DNAMLocation!.Value.Min;
        private bool _Ammo_IsSet => _DNAMLocation.HasValue;
        public IFormLinkGetter<IAmmunitionGetter> Ammo => _Ammo_IsSet ? new FormLink<IAmmunitionGetter>(FormKey.Factory(_package.MetaData.MasterReferences!, BinaryPrimitives.ReadUInt32LittleEndian(_data.Span.Slice(_AmmoLocation, 0x4)))) : FormLink<IAmmunitionGetter>.Null;
        #endregion
        #region Speed
        private int _SpeedLocation => _DNAMLocation!.Value.Min + 0x4;
        private bool _Speed_IsSet => _DNAMLocation.HasValue;
        public Single Speed => _Speed_IsSet ? _data.Slice(_SpeedLocation, 4).Float() : default;
        #endregion
        #region ReloadSpeed
        private int _ReloadSpeedLocation => _DNAMLocation!.Value.Min + 0x8;
        private bool _ReloadSpeed_IsSet => _DNAMLocation.HasValue;
        public Single ReloadSpeed => _ReloadSpeed_IsSet ? _data.Slice(_ReloadSpeedLocation, 4).Float() : default;
        #endregion
        #region Reach
        private int _ReachLocation => _DNAMLocation!.Value.Min + 0xC;
        private bool _Reach_IsSet => _DNAMLocation.HasValue;
        public Single Reach => _Reach_IsSet ? _data.Slice(_ReachLocation, 4).Float() : default;
        #endregion
        #region MinRange
        private int _MinRangeLocation => _DNAMLocation!.Value.Min + 0x10;
        private bool _MinRange_IsSet => _DNAMLocation.HasValue;
        public Single MinRange => _MinRange_IsSet ? _data.Slice(_MinRangeLocation, 4).Float() : default;
        #endregion
        #region MaxRange
        private int _MaxRangeLocation => _DNAMLocation!.Value.Min + 0x14;
        private bool _MaxRange_IsSet => _DNAMLocation.HasValue;
        public Single MaxRange => _MaxRange_IsSet ? _data.Slice(_MaxRangeLocation, 4).Float() : default;
        #endregion
        #region AttackDelay
        private int _AttackDelayLocation => _DNAMLocation!.Value.Min + 0x18;
        private bool _AttackDelay_IsSet => _DNAMLocation.HasValue;
        public Single AttackDelay => _AttackDelay_IsSet ? _data.Slice(_AttackDelayLocation, 4).Float() : default;
        #endregion
        #region Unknown
        private int _UnknownLocation => _DNAMLocation!.Value.Min + 0x1C;
        private bool _Unknown_IsSet => _DNAMLocation.HasValue;
        public Single Unknown => _Unknown_IsSet ? _data.Slice(_UnknownLocation, 4).Float() : default;
        #endregion
        #region DamageOutOfRangeMult
        private int _DamageOutOfRangeMultLocation => _DNAMLocation!.Value.Min + 0x20;
        private bool _DamageOutOfRangeMult_IsSet => _DNAMLocation.HasValue;
        public Single DamageOutOfRangeMult => _DamageOutOfRangeMult_IsSet ? _data.Slice(_DamageOutOfRangeMultLocation, 4).Float() : default;
        #endregion
        #region OnHit
        private int _OnHitLocation => _DNAMLocation!.Value.Min + 0x24;
        private bool _OnHit_IsSet => _DNAMLocation.HasValue;
        public Weapon.HitBehavior OnHit => _OnHit_IsSet ? (Weapon.HitBehavior)BinaryPrimitives.ReadInt32LittleEndian(_data.Span.Slice(_OnHitLocation, 0x4)) : default;
        #endregion
        #region Skill
        private int _SkillLocation => _DNAMLocation!.Value.Min + 0x28;
        private bool _Skill_IsSet => _DNAMLocation.HasValue;
        public IFormLinkGetter<IActorValueInformationGetter> Skill => _Skill_IsSet ? new FormLink<IActorValueInformationGetter>(FormKey.Factory(_package.MetaData.MasterReferences!, BinaryPrimitives.ReadUInt32LittleEndian(_data.Span.Slice(_SkillLocation, 0x4)))) : FormLink<IActorValueInformationGetter>.Null;
        #endregion
        #region Resist
        private int _ResistLocation => _DNAMLocation!.Value.Min + 0x2C;
        private bool _Resist_IsSet => _DNAMLocation.HasValue;
        public IFormLinkGetter<IActorValueInformationGetter> Resist => _Resist_IsSet ? new FormLink<IActorValueInformationGetter>(FormKey.Factory(_package.MetaData.MasterReferences!, BinaryPrimitives.ReadUInt32LittleEndian(_data.Span.Slice(_ResistLocation, 0x4)))) : FormLink<IActorValueInformationGetter>.Null;
        #endregion
        #region Flags
        private int _FlagsLocation => _DNAMLocation!.Value.Min + 0x30;
        private bool _Flags_IsSet => _DNAMLocation.HasValue;
        public Weapon.Flag Flags => _Flags_IsSet ? (Weapon.Flag)BinaryPrimitives.ReadInt32LittleEndian(_data.Span.Slice(_FlagsLocation, 0x4)) : default;
        #endregion
        #region Capacity
        private int _CapacityLocation => _DNAMLocation!.Value.Min + 0x34;
        private bool _Capacity_IsSet => _DNAMLocation.HasValue;
        public UInt16 Capacity => _Capacity_IsSet ? BinaryPrimitives.ReadUInt16LittleEndian(_data.Slice(_CapacityLocation, 2)) : default;
        #endregion
        #region AnimationType
        private int _AnimationTypeLocation => _DNAMLocation!.Value.Min + 0x36;
        private bool _AnimationType_IsSet => _DNAMLocation.HasValue;
        public Weapon.AnimationTypes AnimationType => _AnimationType_IsSet ? (Weapon.AnimationTypes)_data.Span.Slice(_AnimationTypeLocation, 0x1)[0] : default;
        #endregion
        #region SecondaryDamage
        private int _SecondaryDamageLocation => _DNAMLocation!.Value.Min + 0x37;
        private bool _SecondaryDamage_IsSet => _DNAMLocation.HasValue;
        public Single SecondaryDamage => _SecondaryDamage_IsSet ? _data.Slice(_SecondaryDamageLocation, 4).Float() : default;
        #endregion
        #region Weight
        private int _WeightLocation => _DNAMLocation!.Value.Min + 0x3B;
        private bool _Weight_IsSet => _DNAMLocation.HasValue;
        public Single Weight => _Weight_IsSet ? _data.Slice(_WeightLocation, 4).Float() : default;
        #endregion
        #region Value
        private int _ValueLocation => _DNAMLocation!.Value.Min + 0x3F;
        private bool _Value_IsSet => _DNAMLocation.HasValue;
        public UInt32 Value => _Value_IsSet ? BinaryPrimitives.ReadUInt32LittleEndian(_data.Slice(_ValueLocation, 4)) : default;
        #endregion
        #region BaseDamage
        private int _BaseDamageLocation => _DNAMLocation!.Value.Min + 0x43;
        private bool _BaseDamage_IsSet => _DNAMLocation.HasValue;
        public UInt16 BaseDamage => _BaseDamage_IsSet ? BinaryPrimitives.ReadUInt16LittleEndian(_data.Slice(_BaseDamageLocation, 2)) : default;
        #endregion
        #region SoundLevel
        private int _SoundLevelLocation => _DNAMLocation!.Value.Min + 0x45;
        private bool _SoundLevel_IsSet => _DNAMLocation.HasValue;
        public SoundLevel SoundLevel => _SoundLevel_IsSet ? (SoundLevel)BinaryPrimitives.ReadInt32LittleEndian(_data.Span.Slice(_SoundLevelLocation, 0x4)) : default;
        #endregion
        #region AttackSound
        private int _AttackSoundLocation => _DNAMLocation!.Value.Min + 0x49;
        private bool _AttackSound_IsSet => _DNAMLocation.HasValue;
        public IFormLinkGetter<ISoundDescriptorGetter> AttackSound => _AttackSound_IsSet ? new FormLink<ISoundDescriptorGetter>(FormKey.Factory(_package.MetaData.MasterReferences!, BinaryPrimitives.ReadUInt32LittleEndian(_data.Span.Slice(_AttackSoundLocation, 0x4)))) : FormLink<ISoundDescriptorGetter>.Null;
        #endregion
        #region Attack2dSound
        private int _Attack2dSoundLocation => _DNAMLocation!.Value.Min + 0x4D;
        private bool _Attack2dSound_IsSet => _DNAMLocation.HasValue;
        public IFormLinkGetter<ISoundDescriptorGetter> Attack2dSound => _Attack2dSound_IsSet ? new FormLink<ISoundDescriptorGetter>(FormKey.Factory(_package.MetaData.MasterReferences!, BinaryPrimitives.ReadUInt32LittleEndian(_data.Span.Slice(_Attack2dSoundLocation, 0x4)))) : FormLink<ISoundDescriptorGetter>.Null;
        #endregion
        #region AttackLoopSound
        private int _AttackLoopSoundLocation => _DNAMLocation!.Value.Min + 0x51;
        private bool _AttackLoopSound_IsSet => _DNAMLocation.HasValue;
        public IFormLinkGetter<ISoundDescriptorGetter> AttackLoopSound => _AttackLoopSound_IsSet ? new FormLink<ISoundDescriptorGetter>(FormKey.Factory(_package.MetaData.MasterReferences!, BinaryPrimitives.ReadUInt32LittleEndian(_data.Span.Slice(_AttackLoopSoundLocation, 0x4)))) : FormLink<ISoundDescriptorGetter>.Null;
        #endregion
        #region AttackFailSound
        private int _AttackFailSoundLocation => _DNAMLocation!.Value.Min + 0x55;
        private bool _AttackFailSound_IsSet => _DNAMLocation.HasValue;
        public IFormLinkGetter<ISoundDescriptorGetter> AttackFailSound => _AttackFailSound_IsSet ? new FormLink<ISoundDescriptorGetter>(FormKey.Factory(_package.MetaData.MasterReferences!, BinaryPrimitives.ReadUInt32LittleEndian(_data.Span.Slice(_AttackFailSoundLocation, 0x4)))) : FormLink<ISoundDescriptorGetter>.Null;
        #endregion
        #region IdleSound
        private int _IdleSoundLocation => _DNAMLocation!.Value.Min + 0x59;
        private bool _IdleSound_IsSet => _DNAMLocation.HasValue;
        public IFormLinkGetter<ISoundDescriptorGetter> IdleSound => _IdleSound_IsSet ? new FormLink<ISoundDescriptorGetter>(FormKey.Factory(_package.MetaData.MasterReferences!, BinaryPrimitives.ReadUInt32LittleEndian(_data.Span.Slice(_IdleSoundLocation, 0x4)))) : FormLink<ISoundDescriptorGetter>.Null;
        #endregion
        #region EquipSound
        private int _EquipSoundLocation => _DNAMLocation!.Value.Min + 0x5D;
        private bool _EquipSound_IsSet => _DNAMLocation.HasValue;
        public IFormLinkGetter<ISoundDescriptorGetter> EquipSound => _EquipSound_IsSet ? new FormLink<ISoundDescriptorGetter>(FormKey.Factory(_package.MetaData.MasterReferences!, BinaryPrimitives.ReadUInt32LittleEndian(_data.Span.Slice(_EquipSoundLocation, 0x4)))) : FormLink<ISoundDescriptorGetter>.Null;
        #endregion
        #region UnequipSound
        private int _UnequipSoundLocation => _DNAMLocation!.Value.Min + 0x61;
        private bool _UnequipSound_IsSet => _DNAMLocation.HasValue;
        public IFormLinkGetter<ISoundDescriptorGetter> UnequipSound => _UnequipSound_IsSet ? new FormLink<ISoundDescriptorGetter>(FormKey.Factory(_package.MetaData.MasterReferences!, BinaryPrimitives.ReadUInt32LittleEndian(_data.Span.Slice(_UnequipSoundLocation, 0x4)))) : FormLink<ISoundDescriptorGetter>.Null;
        #endregion
        #region FastEquipSound
        private int _FastEquipSoundLocation => _DNAMLocation!.Value.Min + 0x65;
        private bool _FastEquipSound_IsSet => _DNAMLocation.HasValue;
        public IFormLinkGetter<ISoundDescriptorGetter> FastEquipSound => _FastEquipSound_IsSet ? new FormLink<ISoundDescriptorGetter>(FormKey.Factory(_package.MetaData.MasterReferences!, BinaryPrimitives.ReadUInt32LittleEndian(_data.Span.Slice(_FastEquipSoundLocation, 0x4)))) : FormLink<ISoundDescriptorGetter>.Null;
        #endregion
        #region AccuracyBonus
        private int _AccuracyBonusLocation => _DNAMLocation!.Value.Min + 0x69;
        private bool _AccuracyBonus_IsSet => _DNAMLocation.HasValue;
        public Byte AccuracyBonus => _AccuracyBonus_IsSet ? _data.Span[_AccuracyBonusLocation] : default;
        #endregion
        #region AnimationAttackSeconds
        private int _AnimationAttackSecondsLocation => _DNAMLocation!.Value.Min + 0x6A;
        private bool _AnimationAttackSeconds_IsSet => _DNAMLocation.HasValue;
        public Single AnimationAttackSeconds => _AnimationAttackSeconds_IsSet ? _data.Slice(_AnimationAttackSecondsLocation, 4).Float() : default;
        #endregion
        #region Unknown2
        private int _Unknown2Location => _DNAMLocation!.Value.Min + 0x6E;
        private bool _Unknown2_IsSet => _DNAMLocation.HasValue;
        public UInt16 Unknown2 => _Unknown2_IsSet ? BinaryPrimitives.ReadUInt16LittleEndian(_data.Slice(_Unknown2Location, 2)) : default;
        #endregion
        #region ActionPointCost
        private int _ActionPointCostLocation => _DNAMLocation!.Value.Min + 0x70;
        private bool _ActionPointCost_IsSet => _DNAMLocation.HasValue;
        public Single ActionPointCost => _ActionPointCost_IsSet ? _data.Slice(_ActionPointCostLocation, 4).Float() : default;
        #endregion
        #region FullPowerSeconds
        private int _FullPowerSecondsLocation => _DNAMLocation!.Value.Min + 0x74;
        private bool _FullPowerSeconds_IsSet => _DNAMLocation.HasValue;
        public Single FullPowerSeconds => _FullPowerSeconds_IsSet ? _data.Slice(_FullPowerSecondsLocation, 4).Float() : default;
        #endregion
        #region MinPowerPerShot
        private int _MinPowerPerShotLocation => _DNAMLocation!.Value.Min + 0x78;
        private bool _MinPowerPerShot_IsSet => _DNAMLocation.HasValue;
        public Single MinPowerPerShot => _MinPowerPerShot_IsSet ? _data.Slice(_MinPowerPerShotLocation, 4).Float() : default;
        #endregion
        #region Stagger
        private int _StaggerLocation => _DNAMLocation!.Value.Min + 0x7C;
        private bool _Stagger_IsSet => _DNAMLocation.HasValue;
        public Stagger Stagger => _Stagger_IsSet ? (Stagger)BinaryPrimitives.ReadInt32LittleEndian(_data.Span.Slice(_StaggerLocation, 0x4)) : default;
        #endregion
        #region Unknown3
        private int _Unknown3Location => _DNAMLocation!.Value.Min + 0x80;
        private bool _Unknown3_IsSet => _DNAMLocation.HasValue;
        public Int32 Unknown3 => _Unknown3_IsSet ? BinaryPrimitives.ReadInt32LittleEndian(_data.Slice(_Unknown3Location, 4)) : default;
        #endregion
        #region ExtraData
        private RangeInt32? _ExtraDataLocation;
        public IWeaponExtraDataGetter? ExtraData => _ExtraDataLocation.HasValue ? WeaponExtraDataBinaryOverlay.WeaponExtraDataFactory(new OverlayStream(_data.Slice(_ExtraDataLocation!.Value.Min), _package), _package) : default;
        #endregion
        private RangeInt32? _CRDTLocation;
        public Weapon.CRDTDataType CRDTDataTypeState { get; private set; }
        #region CritDamageMult
        private int _CritDamageMultLocation => _CRDTLocation!.Value.Min;
        private bool _CritDamageMult_IsSet => _CRDTLocation.HasValue;
        public Single CritDamageMult => _CritDamageMult_IsSet ? _data.Slice(_CritDamageMultLocation, 4).Float() : default;
        #endregion
        #region CritChargeBonus
        private int _CritChargeBonusLocation => _CRDTLocation!.Value.Min + 0x4;
        private bool _CritChargeBonus_IsSet => _CRDTLocation.HasValue;
        public Single CritChargeBonus => _CritChargeBonus_IsSet ? _data.Slice(_CritChargeBonusLocation, 4).Float() : default;
        #endregion
        #region CritEffect
        private int _CritEffectLocation => _CRDTLocation!.Value.Min + 0x8;
        private bool _CritEffect_IsSet => _CRDTLocation.HasValue;
        public IFormLinkGetter<ISpellGetter> CritEffect => _CritEffect_IsSet ? new FormLink<ISpellGetter>(FormKey.Factory(_package.MetaData.MasterReferences!, BinaryPrimitives.ReadUInt32LittleEndian(_data.Span.Slice(_CritEffectLocation, 0x4)))) : FormLink<ISpellGetter>.Null;
        #endregion
        #region ImpactDataSet
        private int? _ImpactDataSetLocation;
        public IFormLinkNullableGetter<IImpactDataSetGetter> ImpactDataSet => _ImpactDataSetLocation.HasValue ? new FormLinkNullable<IImpactDataSetGetter>(FormKey.Factory(_package.MetaData.MasterReferences!, BinaryPrimitives.ReadUInt32LittleEndian(HeaderTranslation.ExtractSubrecordMemory(_data, _ImpactDataSetLocation.Value, _package.MetaData.Constants)))) : FormLinkNullable<IImpactDataSetGetter>.Null;
        #endregion
        #region NpcAddAmmoList
        private int? _NpcAddAmmoListLocation;
        public IFormLinkNullableGetter<ILeveledItemGetter> NpcAddAmmoList => _NpcAddAmmoListLocation.HasValue ? new FormLinkNullable<ILeveledItemGetter>(FormKey.Factory(_package.MetaData.MasterReferences!, BinaryPrimitives.ReadUInt32LittleEndian(HeaderTranslation.ExtractSubrecordMemory(_data, _NpcAddAmmoListLocation.Value, _package.MetaData.Constants)))) : FormLinkNullable<ILeveledItemGetter>.Null;
        #endregion
        #region AimModel
        private int? _AimModelLocation;
        public IFormLinkNullableGetter<IAimModelGetter> AimModel => _AimModelLocation.HasValue ? new FormLinkNullable<IAimModelGetter>(FormKey.Factory(_package.MetaData.MasterReferences!, BinaryPrimitives.ReadUInt32LittleEndian(HeaderTranslation.ExtractSubrecordMemory(_data, _AimModelLocation.Value, _package.MetaData.Constants)))) : FormLinkNullable<IAimModelGetter>.Null;
        #endregion
        #region Zoom
        private int? _ZoomLocation;
        public IFormLinkNullableGetter<IZoomGetter> Zoom => _ZoomLocation.HasValue ? new FormLinkNullable<IZoomGetter>(FormKey.Factory(_package.MetaData.MasterReferences!, BinaryPrimitives.ReadUInt32LittleEndian(HeaderTranslation.ExtractSubrecordMemory(_data, _ZoomLocation.Value, _package.MetaData.Constants)))) : FormLinkNullable<IZoomGetter>.Null;
        #endregion
        #region Template
        private int? _TemplateLocation;
        public IFormLinkNullableGetter<IWeaponGetter> Template => _TemplateLocation.HasValue ? new FormLinkNullable<IWeaponGetter>(FormKey.Factory(_package.MetaData.MasterReferences!, BinaryPrimitives.ReadUInt32LittleEndian(HeaderTranslation.ExtractSubrecordMemory(_data, _TemplateLocation.Value, _package.MetaData.Constants)))) : FormLinkNullable<IWeaponGetter>.Null;
        #endregion
        #region DamageType
        private RangeInt32? _DamageTypeLocation;
        public IWeaponDamageTypeGetter? DamageType => _DamageTypeLocation.HasValue ? WeaponDamageTypeBinaryOverlay.WeaponDamageTypeFactory(new OverlayStream(_data.Slice(_DamageTypeLocation!.Value.Min), _package), _package) : default;
        #endregion
        #region Filter
        private int? _FilterLocation;
        public String? Filter => _FilterLocation.HasValue ? BinaryStringUtility.ProcessWholeToZString(HeaderTranslation.ExtractSubrecordMemory(_data, _FilterLocation.Value, _package.MetaData.Constants), encoding: _package.MetaData.Encodings.NonTranslated) : default(string?);
        #endregion
        #region MeleeSpeed
        private int? _MeleeSpeedLocation;
        public Weapon.MeleeSpeeds? MeleeSpeed => _MeleeSpeedLocation.HasValue ? (Weapon.MeleeSpeeds)BinaryPrimitives.ReadInt32LittleEndian(HeaderTranslation.ExtractSubrecordMemory(_data, _MeleeSpeedLocation!.Value, _package.MetaData.Constants)) : default(Weapon.MeleeSpeeds?);
        #endregion
        partial void CustomFactoryEnd(
            OverlayStream stream,
            int finalPos,
            int offset);

        partial void CustomCtor();
        protected WeaponBinaryOverlay(
            ReadOnlyMemorySlice<byte> bytes,
            BinaryOverlayFactoryPackage package)
            : base(
                bytes: bytes,
                package: package)
        {
            this.CustomCtor();
        }

        public static WeaponBinaryOverlay WeaponFactory(
            OverlayStream stream,
            BinaryOverlayFactoryPackage package,
            TypedParseParams? parseParams = null)
        {
            stream = Decompression.DecompressStream(stream);
            var ret = new WeaponBinaryOverlay(
                bytes: HeaderTranslation.ExtractRecordMemory(stream.RemainingMemory, package.MetaData.Constants),
                package: package);
            var finalPos = checked((int)(stream.Position + stream.GetMajorRecordHeader().TotalLength));
            int offset = stream.Position + package.MetaData.Constants.MajorConstants.TypeAndLengthLength;
            ret._package.FormVersion = ret;
            stream.Position += 0x10 + package.MetaData.Constants.MajorConstants.TypeAndLengthLength;
            ret.CustomFactoryEnd(
                stream: stream,
                finalPos: finalPos,
                offset: offset);
            ret.FillSubrecordTypes(
                majorReference: ret,
                stream: stream,
                finalPos: finalPos,
                offset: offset,
                parseParams: parseParams,
                fill: ret.FillRecordType);
            return ret;
        }

        public static WeaponBinaryOverlay WeaponFactory(
            ReadOnlyMemorySlice<byte> slice,
            BinaryOverlayFactoryPackage package,
            TypedParseParams? parseParams = null)
        {
            return WeaponFactory(
                stream: new OverlayStream(slice, package),
                package: package,
                parseParams: parseParams);
        }

        public override ParseResult FillRecordType(
            OverlayStream stream,
            int finalPos,
            int offset,
            RecordType type,
            PreviousParse lastParsed,
            Dictionary<RecordType, int>? recordParseCount,
            TypedParseParams? parseParams = null)
        {
            type = parseParams.ConvertToStandard(type);
            switch (type.TypeInt)
            {
                case RecordTypeInts.VMAD:
                {
                    _VirtualMachineAdapterLocation = new RangeInt32((stream.Position - offset), finalPos - offset);
                    return (int)Weapon_FieldIndex.VirtualMachineAdapter;
                }
                case RecordTypeInts.OBND:
                {
                    _ObjectBoundsLocation = new RangeInt32((stream.Position - offset), finalPos - offset);
                    return (int)Weapon_FieldIndex.ObjectBounds;
                }
                case RecordTypeInts.PTRN:
                {
                    _PreviewTransformLocation = (stream.Position - offset);
                    return (int)Weapon_FieldIndex.PreviewTransform;
                }
                case RecordTypeInts.STCP:
                {
                    _AnimationSoundLocation = (stream.Position - offset);
                    return (int)Weapon_FieldIndex.AnimationSound;
                }
                case RecordTypeInts.FULL:
                {
                    _NameLocation = (stream.Position - offset);
                    return (int)Weapon_FieldIndex.Name;
                }
                case RecordTypeInts.MODL:
                {
                    this.Model = ModelBinaryOverlay.ModelFactory(
                        stream: stream,
                        package: _package,
                        parseParams: parseParams);
                    return (int)Weapon_FieldIndex.Model;
                }
                case RecordTypeInts.ICON:
                case RecordTypeInts.MICO:
                {
                    this.Icons = IconsBinaryOverlay.IconsFactory(
                        stream: stream,
                        package: _package,
                        parseParams: parseParams);
                    return (int)Weapon_FieldIndex.Icons;
                }
                case RecordTypeInts.EITM:
                {
                    _ObjectEffectLocation = (stream.Position - offset);
                    return (int)Weapon_FieldIndex.ObjectEffect;
                }
                case RecordTypeInts.EAMT:
                {
                    _EnchantmentAmountLocation = (stream.Position - offset);
                    return (int)Weapon_FieldIndex.EnchantmentAmount;
                }
                case RecordTypeInts.DEST:
                case RecordTypeInts.DAMC:
                case RecordTypeInts.DSTD:
                case RecordTypeInts.DSTA:
                case RecordTypeInts.DMDL:
                {
                    this.Destructible = DestructibleBinaryOverlay.DestructibleFactory(
                        stream: stream,
                        package: _package,
                        parseParams: parseParams);
                    return (int)Weapon_FieldIndex.Destructible;
                }
                case RecordTypeInts.ETYP:
                {
                    _EquipmentTypeLocation = (stream.Position - offset);
                    return (int)Weapon_FieldIndex.EquipmentType;
                }
                case RecordTypeInts.BIDS:
                {
                    _BlockBashImpactDataSetLocation = (stream.Position - offset);
                    return (int)Weapon_FieldIndex.BlockBashImpactDataSet;
                }
                case RecordTypeInts.BAMT:
                {
                    _AlternateBlockMaterialLocation = (stream.Position - offset);
                    return (int)Weapon_FieldIndex.AlternateBlockMaterial;
                }
                case RecordTypeInts.YNAM:
                {
                    _PickUpSoundLocation = (stream.Position - offset);
                    return (int)Weapon_FieldIndex.PickUpSound;
                }
                case RecordTypeInts.ZNAM:
                {
                    _PutDownSoundLocation = (stream.Position - offset);
                    return (int)Weapon_FieldIndex.PutDownSound;
                }
                case RecordTypeInts.KWDA:
                case RecordTypeInts.KSIZ:
                {
                    this.Keywords = BinaryOverlayList.FactoryByCount<IFormLinkGetter<IKeywordGetter>>(
                        stream: stream,
                        package: _package,
                        itemLength: 0x4,
                        countLength: 4,
                        countType: RecordTypes.KSIZ,
                        trigger: RecordTypes.KWDA,
                        getter: (s, p) => new FormLink<IKeywordGetter>(FormKey.Factory(p.MetaData.MasterReferences!, BinaryPrimitives.ReadUInt32LittleEndian(s))));
                    return (int)Weapon_FieldIndex.Keywords;
                }
                case RecordTypeInts.DESC:
                {
                    _DescriptionLocation = (stream.Position - offset);
                    return (int)Weapon_FieldIndex.Description;
                }
                case RecordTypeInts.INRD:
                {
                    _InstanceNamingLocation = (stream.Position - offset);
                    return (int)Weapon_FieldIndex.InstanceNaming;
                }
                case RecordTypeInts.APPR:
                {
                    var subMeta = stream.ReadSubrecordHeader();
                    var subLen = finalPos - stream.Position;
                    this.AttachParentSlots = BinaryOverlayList.FactoryByStartIndex<IFormLinkGetter<IKeywordGetter>>(
                        mem: stream.RemainingMemory.Slice(0, subLen),
                        package: _package,
                        itemLength: 4,
                        getter: (s, p) => new FormLink<IKeywordGetter>(FormKey.Factory(p.MetaData.MasterReferences!, BinaryPrimitives.ReadUInt32LittleEndian(s))));
                    stream.Position += subLen;
                    return (int)Weapon_FieldIndex.AttachParentSlots;
                }
                case RecordTypeInts.OBTE:
                {
                    this.ObjectTemplates = BinaryOverlayList.FactoryByCountPerItem<ObjectTemplateBinaryOverlay<Weapon.Property>>(
                        stream: stream,
                        package: _package,
                        countLength: 4,
                        trigger: ObjectTemplate_Registration.TriggerSpecs,
                        countType: RecordTypes.OBTE,
                        parseParams: parseParams,
                        getter: (s, p, recConv) => ObjectTemplateBinaryOverlay<Weapon.Property>.ObjectTemplateFactory(new OverlayStream(s, p), p, recConv),
                        skipHeader: false);
                    return (int)Weapon_FieldIndex.ObjectTemplates;
                }
                case RecordTypeInts.NNAM:
                {
                    _EmbeddedWeaponModLocation = (stream.Position - offset);
                    return (int)Weapon_FieldIndex.EmbeddedWeaponMod;
                }
                case RecordTypeInts.MOD4:
                {
                    this.FirstPersonModel = ModelBinaryOverlay.ModelFactory(
                        stream: stream,
                        package: _package,
                        parseParams: Weapon_Registration.FirstPersonModelConverter);
                    return (int)Weapon_FieldIndex.FirstPersonModel;
                }
                case RecordTypeInts.MO4C:
                {
                    _FirstPersonColorRemappingIndexLocation = (stream.Position - offset);
                    return (int)Weapon_FieldIndex.FirstPersonColorRemappingIndex;
                }
                case RecordTypeInts.MO4F:
                {
                    _MO4FLocation = (stream.Position - offset);
                    return (int)Weapon_FieldIndex.MO4F;
                }
                case RecordTypeInts.DNAM:
                {
                    _DNAMLocation = new((stream.Position - offset) + _package.MetaData.Constants.SubConstants.TypeAndLengthLength, finalPos - offset - 1);
                    return (int)Weapon_FieldIndex.Unknown3;
                }
                case RecordTypeInts.FNAM:
                {
                    _ExtraDataLocation = new RangeInt32((stream.Position - offset), finalPos - offset);
                    return (int)Weapon_FieldIndex.ExtraData;
                }
                case RecordTypeInts.CRDT:
                {
                    _CRDTLocation = new((stream.Position - offset) + _package.MetaData.Constants.SubConstants.TypeAndLengthLength, finalPos - offset - 1);
                    return (int)Weapon_FieldIndex.CritEffect;
                }
                case RecordTypeInts.INAM:
                {
                    _ImpactDataSetLocation = (stream.Position - offset);
                    return (int)Weapon_FieldIndex.ImpactDataSet;
                }
                case RecordTypeInts.LNAM:
                {
                    _NpcAddAmmoListLocation = (stream.Position - offset);
                    return (int)Weapon_FieldIndex.NpcAddAmmoList;
                }
                case RecordTypeInts.WAMD:
                {
                    _AimModelLocation = (stream.Position - offset);
                    return (int)Weapon_FieldIndex.AimModel;
                }
                case RecordTypeInts.WZMD:
                {
                    _ZoomLocation = (stream.Position - offset);
                    return (int)Weapon_FieldIndex.Zoom;
                }
                case RecordTypeInts.CNAM:
                {
                    _TemplateLocation = (stream.Position - offset);
                    return (int)Weapon_FieldIndex.Template;
                }
                case RecordTypeInts.DAMA:
                {
                    _DamageTypeLocation = new RangeInt32((stream.Position - offset), finalPos - offset);
                    return (int)Weapon_FieldIndex.DamageType;
                }
                case RecordTypeInts.FLTR:
                {
                    _FilterLocation = (stream.Position - offset);
                    return (int)Weapon_FieldIndex.Filter;
                }
                case RecordTypeInts.MASE:
                {
                    _MeleeSpeedLocation = (stream.Position - offset);
                    return (int)Weapon_FieldIndex.MeleeSpeed;
                }
                default:
                    return base.FillRecordType(
                        stream: stream,
                        finalPos: finalPos,
                        offset: offset,
                        type: type,
                        lastParsed: lastParsed,
                        recordParseCount: recordParseCount);
            }
        }
        #region To String

        public override void ToString(
            StructuredStringBuilder sb,
            string? name = null)
        {
            WeaponMixIn.ToString(
                item: this,
                sb: sb,
                name: name);
        }

        #endregion

        public override string ToString()
        {
            return MajorRecordPrinter<Weapon>.ToString(this);
        }

        #region Equals and Hash
        public override bool Equals(object? obj)
        {
            if (obj is IFormLinkGetter formLink)
            {
                return formLink.Equals(this);
            }
            if (obj is not IWeaponGetter rhs) return false;
            return ((WeaponCommon)((IWeaponGetter)this).CommonInstance()!).Equals(this, rhs, crystal: null);
        }

        public bool Equals(IWeaponGetter? obj)
        {
            return ((WeaponCommon)((IWeaponGetter)this).CommonInstance()!).Equals(this, obj, crystal: null);
        }

        public override int GetHashCode() => ((WeaponCommon)((IWeaponGetter)this).CommonInstance()!).GetHashCode(this);

        #endregion

    }

}
#endregion

#endregion

