/*
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
 * Autogenerated by Loqui.  Do not manually change.
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
*/
#region Usings
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Loqui;
using Loqui.Internal;
using Noggog;
using Mutagen.Bethesda.Oblivion.Internals;
using System.Reactive.Disposables;
using System.Reactive.Linq;
using System.Xml;
using System.Xml.Linq;
using System.IO;
using Noggog.Xml;
using Loqui.Xml;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using Mutagen.Bethesda.Xml;
using Mutagen.Bethesda.Binary;
using System.Buffers.Binary;
using Mutagen.Bethesda.Internals;
#endregion

#nullable enable
namespace Mutagen.Bethesda.Oblivion
{
    #region Class
    public partial class CombatStyleData :
        ICombatStyleData,
        ILoquiObjectSetter<CombatStyleData>,
        IEquatable<CombatStyleData>,
        IEqualsMask
    {
        #region Ctor
        public CombatStyleData()
        {
            CustomCtor();
        }
        partial void CustomCtor();
        #endregion

        #region Versioning
        public CombatStyleData.VersioningBreaks Versioning { get; set; } = default;
        #endregion
        #region DodgePercentChance
        public Byte DodgePercentChance { get; set; } = default;
        public static RangeUInt8 DodgePercentChance_Range = new RangeUInt8(0, 100);
        #endregion
        #region LeftRightPercentChance
        public Byte LeftRightPercentChance { get; set; } = default;
        public static RangeUInt8 LeftRightPercentChance_Range = new RangeUInt8(0, 100);
        #endregion
        #region DodgeLeftRightTimerMin
        public Single DodgeLeftRightTimerMin { get; set; } = default;
        #endregion
        #region DodgeLeftRightTimerMax
        public Single DodgeLeftRightTimerMax { get; set; } = default;
        #endregion
        #region DodgeForwardTimerMin
        public Single DodgeForwardTimerMin { get; set; } = default;
        #endregion
        #region DodgeForwardTimerMax
        public Single DodgeForwardTimerMax { get; set; } = default;
        #endregion
        #region DodgeBackTimerMin
        public Single DodgeBackTimerMin { get; set; } = default;
        #endregion
        #region DodgeBackTimerMax
        public Single DodgeBackTimerMax { get; set; } = default;
        #endregion
        #region IdleTimerMin
        public Single IdleTimerMin { get; set; } = default;
        #endregion
        #region IdleTimerMax
        public Single IdleTimerMax { get; set; } = default;
        #endregion
        #region BlockPercentChance
        public Byte BlockPercentChance { get; set; } = default;
        public static RangeUInt8 BlockPercentChance_Range = new RangeUInt8(0, 100);
        #endregion
        #region AttackPercentChance
        public Byte AttackPercentChance { get; set; } = default;
        public static RangeUInt8 AttackPercentChance_Range = new RangeUInt8(0, 100);
        #endregion
        #region RecoilStaggerBonusToAttack
        public Single RecoilStaggerBonusToAttack { get; set; } = default;
        #endregion
        #region UnconsciousBonusToAttack
        public Single UnconsciousBonusToAttack { get; set; } = default;
        #endregion
        #region HandToHandBonusToAttack
        public Single HandToHandBonusToAttack { get; set; } = default;
        #endregion
        #region PowerAttackPercentChance
        public Byte PowerAttackPercentChance { get; set; } = default;
        public static RangeUInt8 PowerAttackPercentChance_Range = new RangeUInt8(0, 100);
        #endregion
        #region RecoilStaggerBonusToPowerAttack
        public Single RecoilStaggerBonusToPowerAttack { get; set; } = default;
        #endregion
        #region UnconsciousBonusToPowerAttack
        public Single UnconsciousBonusToPowerAttack { get; set; } = default;
        #endregion
        #region PowerAttackNormal
        public Byte PowerAttackNormal { get; set; } = default;
        public static RangeUInt8 PowerAttackNormal_Range = new RangeUInt8(0, 100);
        #endregion
        #region PowerAttackForward
        public Byte PowerAttackForward { get; set; } = default;
        public static RangeUInt8 PowerAttackForward_Range = new RangeUInt8(0, 100);
        #endregion
        #region PowerAttackBack
        public Byte PowerAttackBack { get; set; } = default;
        public static RangeUInt8 PowerAttackBack_Range = new RangeUInt8(0, 100);
        #endregion
        #region PowerAttackLeft
        public Byte PowerAttackLeft { get; set; } = default;
        public static RangeUInt8 PowerAttackLeft_Range = new RangeUInt8(0, 100);
        #endregion
        #region PowerAttackRight
        public Byte PowerAttackRight { get; set; } = default;
        public static RangeUInt8 PowerAttackRight_Range = new RangeUInt8(0, 100);
        #endregion
        #region HoldTimerMin
        public Single HoldTimerMin { get; set; } = default;
        #endregion
        #region HoldTimerMax
        public Single HoldTimerMax { get; set; } = default;
        #endregion
        #region Flags
        public CombatStyle.Flag Flags { get; set; } = default;
        #endregion
        #region AcrobaticDodgePercentChance
        public Byte AcrobaticDodgePercentChance { get; set; } = default;
        public static RangeUInt8 AcrobaticDodgePercentChance_Range = new RangeUInt8(0, 100);
        #endregion
        #region RangeMultOptimal
        public Single RangeMultOptimal { get; set; } = default;
        #endregion
        #region RangeMultMax
        public Single RangeMultMax { get; set; } = default;
        #endregion
        #region SwitchDistanceMelee
        public Single SwitchDistanceMelee { get; set; } = default;
        #endregion
        #region SwitchDistanceRanged
        public Single SwitchDistanceRanged { get; set; } = default;
        #endregion
        #region BuffStandoffDistance
        public Single BuffStandoffDistance { get; set; } = default;
        #endregion
        #region RangedStandoffDistance
        public Single RangedStandoffDistance { get; set; } = default;
        #endregion
        #region GroupStandoffDistance
        public Single GroupStandoffDistance { get; set; } = default;
        #endregion
        #region RushingAttackPercentChance
        public Byte RushingAttackPercentChance { get; set; } = default;
        public static RangeUInt8 RushingAttackPercentChance_Range = new RangeUInt8(0, 100);
        #endregion
        #region RushingAttackDistanceMult
        public Single RushingAttackDistanceMult { get; set; } = default;
        #endregion

        #region To String

        public void ToString(
            FileGeneration fg,
            string? name = null)
        {
            CombatStyleDataMixIn.ToString(
                item: this,
                name: name);
        }

        #endregion

        #region Equals and Hash
        public override bool Equals(object? obj)
        {
            if (!(obj is ICombatStyleDataGetter rhs)) return false;
            return ((CombatStyleDataCommon)((ICombatStyleDataGetter)this).CommonInstance()!).Equals(this, rhs);
        }

        public bool Equals(CombatStyleData obj)
        {
            return ((CombatStyleDataCommon)((ICombatStyleDataGetter)this).CommonInstance()!).Equals(this, obj);
        }

        public override int GetHashCode() => ((CombatStyleDataCommon)((ICombatStyleDataGetter)this).CommonInstance()!).GetHashCode(this);

        #endregion

        #region Xml Translation
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected object XmlWriteTranslator => CombatStyleDataXmlWriteTranslation.Instance;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        object IXmlItem.XmlWriteTranslator => this.XmlWriteTranslator;
        void IXmlItem.WriteToXml(
            XElement node,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask,
            string? name = null)
        {
            ((CombatStyleDataXmlWriteTranslation)this.XmlWriteTranslator).Write(
                item: this,
                name: name,
                node: node,
                errorMask: errorMask,
                translationMask: translationMask);
        }
        #region Xml Create
        [DebuggerStepThrough]
        public static CombatStyleData CreateFromXml(
            XElement node,
            CombatStyleData.TranslationMask? translationMask = null)
        {
            return CreateFromXml(
                node: node,
                errorMask: null,
                translationMask: translationMask?.GetCrystal());
        }

        [DebuggerStepThrough]
        public static CombatStyleData CreateFromXml(
            XElement node,
            out CombatStyleData.ErrorMask errorMask,
            CombatStyleData.TranslationMask? translationMask = null)
        {
            ErrorMaskBuilder errorMaskBuilder = new ErrorMaskBuilder();
            var ret = CreateFromXml(
                node: node,
                errorMask: errorMaskBuilder,
                translationMask: translationMask?.GetCrystal());
            errorMask = CombatStyleData.ErrorMask.Factory(errorMaskBuilder);
            return ret;
        }

        public static CombatStyleData CreateFromXml(
            XElement node,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask)
        {
            var ret = new CombatStyleData();
            ((CombatStyleDataSetterCommon)((ICombatStyleDataGetter)ret).CommonSetterInstance()!).CopyInFromXml(
                item: ret,
                node: node,
                errorMask: errorMask,
                translationMask: translationMask);
            return ret;
        }

        public static CombatStyleData CreateFromXml(
            string path,
            CombatStyleData.TranslationMask? translationMask = null)
        {
            var node = XDocument.Load(path).Root;
            return CreateFromXml(
                node: node,
                translationMask: translationMask);
        }

        public static CombatStyleData CreateFromXml(
            string path,
            out CombatStyleData.ErrorMask errorMask,
            CombatStyleData.TranslationMask? translationMask = null)
        {
            var node = XDocument.Load(path).Root;
            return CreateFromXml(
                node: node,
                errorMask: out errorMask,
                translationMask: translationMask);
        }

        public static CombatStyleData CreateFromXml(
            string path,
            ErrorMaskBuilder? errorMask,
            CombatStyleData.TranslationMask? translationMask = null)
        {
            var node = XDocument.Load(path).Root;
            return CreateFromXml(
                node: node,
                errorMask: errorMask,
                translationMask: translationMask?.GetCrystal());
        }

        public static CombatStyleData CreateFromXml(
            Stream stream,
            CombatStyleData.TranslationMask? translationMask = null)
        {
            var node = XDocument.Load(stream).Root;
            return CreateFromXml(
                node: node,
                translationMask: translationMask);
        }

        public static CombatStyleData CreateFromXml(
            Stream stream,
            out CombatStyleData.ErrorMask errorMask,
            CombatStyleData.TranslationMask? translationMask = null)
        {
            var node = XDocument.Load(stream).Root;
            return CreateFromXml(
                node: node,
                errorMask: out errorMask,
                translationMask: translationMask);
        }

        public static CombatStyleData CreateFromXml(
            Stream stream,
            ErrorMaskBuilder? errorMask,
            CombatStyleData.TranslationMask? translationMask = null)
        {
            var node = XDocument.Load(stream).Root;
            return CreateFromXml(
                node: node,
                errorMask: errorMask,
                translationMask: translationMask?.GetCrystal());
        }

        #endregion

        #endregion

        #region Mask
        public class Mask<TItem> :
            IMask<TItem>,
            IEquatable<Mask<TItem>>
            where TItem : notnull
        {
            #region Ctors
            public Mask(TItem initialValue)
            {
                this.Versioning = initialValue;
                this.DodgePercentChance = initialValue;
                this.LeftRightPercentChance = initialValue;
                this.DodgeLeftRightTimerMin = initialValue;
                this.DodgeLeftRightTimerMax = initialValue;
                this.DodgeForwardTimerMin = initialValue;
                this.DodgeForwardTimerMax = initialValue;
                this.DodgeBackTimerMin = initialValue;
                this.DodgeBackTimerMax = initialValue;
                this.IdleTimerMin = initialValue;
                this.IdleTimerMax = initialValue;
                this.BlockPercentChance = initialValue;
                this.AttackPercentChance = initialValue;
                this.RecoilStaggerBonusToAttack = initialValue;
                this.UnconsciousBonusToAttack = initialValue;
                this.HandToHandBonusToAttack = initialValue;
                this.PowerAttackPercentChance = initialValue;
                this.RecoilStaggerBonusToPowerAttack = initialValue;
                this.UnconsciousBonusToPowerAttack = initialValue;
                this.PowerAttackNormal = initialValue;
                this.PowerAttackForward = initialValue;
                this.PowerAttackBack = initialValue;
                this.PowerAttackLeft = initialValue;
                this.PowerAttackRight = initialValue;
                this.HoldTimerMin = initialValue;
                this.HoldTimerMax = initialValue;
                this.Flags = initialValue;
                this.AcrobaticDodgePercentChance = initialValue;
                this.RangeMultOptimal = initialValue;
                this.RangeMultMax = initialValue;
                this.SwitchDistanceMelee = initialValue;
                this.SwitchDistanceRanged = initialValue;
                this.BuffStandoffDistance = initialValue;
                this.RangedStandoffDistance = initialValue;
                this.GroupStandoffDistance = initialValue;
                this.RushingAttackPercentChance = initialValue;
                this.RushingAttackDistanceMult = initialValue;
            }

            public Mask(
                TItem Versioning,
                TItem DodgePercentChance,
                TItem LeftRightPercentChance,
                TItem DodgeLeftRightTimerMin,
                TItem DodgeLeftRightTimerMax,
                TItem DodgeForwardTimerMin,
                TItem DodgeForwardTimerMax,
                TItem DodgeBackTimerMin,
                TItem DodgeBackTimerMax,
                TItem IdleTimerMin,
                TItem IdleTimerMax,
                TItem BlockPercentChance,
                TItem AttackPercentChance,
                TItem RecoilStaggerBonusToAttack,
                TItem UnconsciousBonusToAttack,
                TItem HandToHandBonusToAttack,
                TItem PowerAttackPercentChance,
                TItem RecoilStaggerBonusToPowerAttack,
                TItem UnconsciousBonusToPowerAttack,
                TItem PowerAttackNormal,
                TItem PowerAttackForward,
                TItem PowerAttackBack,
                TItem PowerAttackLeft,
                TItem PowerAttackRight,
                TItem HoldTimerMin,
                TItem HoldTimerMax,
                TItem Flags,
                TItem AcrobaticDodgePercentChance,
                TItem RangeMultOptimal,
                TItem RangeMultMax,
                TItem SwitchDistanceMelee,
                TItem SwitchDistanceRanged,
                TItem BuffStandoffDistance,
                TItem RangedStandoffDistance,
                TItem GroupStandoffDistance,
                TItem RushingAttackPercentChance,
                TItem RushingAttackDistanceMult)
            {
                this.Versioning = Versioning;
                this.DodgePercentChance = DodgePercentChance;
                this.LeftRightPercentChance = LeftRightPercentChance;
                this.DodgeLeftRightTimerMin = DodgeLeftRightTimerMin;
                this.DodgeLeftRightTimerMax = DodgeLeftRightTimerMax;
                this.DodgeForwardTimerMin = DodgeForwardTimerMin;
                this.DodgeForwardTimerMax = DodgeForwardTimerMax;
                this.DodgeBackTimerMin = DodgeBackTimerMin;
                this.DodgeBackTimerMax = DodgeBackTimerMax;
                this.IdleTimerMin = IdleTimerMin;
                this.IdleTimerMax = IdleTimerMax;
                this.BlockPercentChance = BlockPercentChance;
                this.AttackPercentChance = AttackPercentChance;
                this.RecoilStaggerBonusToAttack = RecoilStaggerBonusToAttack;
                this.UnconsciousBonusToAttack = UnconsciousBonusToAttack;
                this.HandToHandBonusToAttack = HandToHandBonusToAttack;
                this.PowerAttackPercentChance = PowerAttackPercentChance;
                this.RecoilStaggerBonusToPowerAttack = RecoilStaggerBonusToPowerAttack;
                this.UnconsciousBonusToPowerAttack = UnconsciousBonusToPowerAttack;
                this.PowerAttackNormal = PowerAttackNormal;
                this.PowerAttackForward = PowerAttackForward;
                this.PowerAttackBack = PowerAttackBack;
                this.PowerAttackLeft = PowerAttackLeft;
                this.PowerAttackRight = PowerAttackRight;
                this.HoldTimerMin = HoldTimerMin;
                this.HoldTimerMax = HoldTimerMax;
                this.Flags = Flags;
                this.AcrobaticDodgePercentChance = AcrobaticDodgePercentChance;
                this.RangeMultOptimal = RangeMultOptimal;
                this.RangeMultMax = RangeMultMax;
                this.SwitchDistanceMelee = SwitchDistanceMelee;
                this.SwitchDistanceRanged = SwitchDistanceRanged;
                this.BuffStandoffDistance = BuffStandoffDistance;
                this.RangedStandoffDistance = RangedStandoffDistance;
                this.GroupStandoffDistance = GroupStandoffDistance;
                this.RushingAttackPercentChance = RushingAttackPercentChance;
                this.RushingAttackDistanceMult = RushingAttackDistanceMult;
            }

            #pragma warning disable CS8618
            protected Mask()
            {
            }
            #pragma warning restore CS8618

            #endregion

            #region Members
            public TItem Versioning;
            public TItem DodgePercentChance;
            public TItem LeftRightPercentChance;
            public TItem DodgeLeftRightTimerMin;
            public TItem DodgeLeftRightTimerMax;
            public TItem DodgeForwardTimerMin;
            public TItem DodgeForwardTimerMax;
            public TItem DodgeBackTimerMin;
            public TItem DodgeBackTimerMax;
            public TItem IdleTimerMin;
            public TItem IdleTimerMax;
            public TItem BlockPercentChance;
            public TItem AttackPercentChance;
            public TItem RecoilStaggerBonusToAttack;
            public TItem UnconsciousBonusToAttack;
            public TItem HandToHandBonusToAttack;
            public TItem PowerAttackPercentChance;
            public TItem RecoilStaggerBonusToPowerAttack;
            public TItem UnconsciousBonusToPowerAttack;
            public TItem PowerAttackNormal;
            public TItem PowerAttackForward;
            public TItem PowerAttackBack;
            public TItem PowerAttackLeft;
            public TItem PowerAttackRight;
            public TItem HoldTimerMin;
            public TItem HoldTimerMax;
            public TItem Flags;
            public TItem AcrobaticDodgePercentChance;
            public TItem RangeMultOptimal;
            public TItem RangeMultMax;
            public TItem SwitchDistanceMelee;
            public TItem SwitchDistanceRanged;
            public TItem BuffStandoffDistance;
            public TItem RangedStandoffDistance;
            public TItem GroupStandoffDistance;
            public TItem RushingAttackPercentChance;
            public TItem RushingAttackDistanceMult;
            #endregion

            #region Equals
            public override bool Equals(object? obj)
            {
                if (!(obj is Mask<TItem> rhs)) return false;
                return Equals(rhs);
            }

            public bool Equals(Mask<TItem> rhs)
            {
                if (rhs == null) return false;
                if (!object.Equals(this.Versioning, rhs.Versioning)) return false;
                if (!object.Equals(this.DodgePercentChance, rhs.DodgePercentChance)) return false;
                if (!object.Equals(this.LeftRightPercentChance, rhs.LeftRightPercentChance)) return false;
                if (!object.Equals(this.DodgeLeftRightTimerMin, rhs.DodgeLeftRightTimerMin)) return false;
                if (!object.Equals(this.DodgeLeftRightTimerMax, rhs.DodgeLeftRightTimerMax)) return false;
                if (!object.Equals(this.DodgeForwardTimerMin, rhs.DodgeForwardTimerMin)) return false;
                if (!object.Equals(this.DodgeForwardTimerMax, rhs.DodgeForwardTimerMax)) return false;
                if (!object.Equals(this.DodgeBackTimerMin, rhs.DodgeBackTimerMin)) return false;
                if (!object.Equals(this.DodgeBackTimerMax, rhs.DodgeBackTimerMax)) return false;
                if (!object.Equals(this.IdleTimerMin, rhs.IdleTimerMin)) return false;
                if (!object.Equals(this.IdleTimerMax, rhs.IdleTimerMax)) return false;
                if (!object.Equals(this.BlockPercentChance, rhs.BlockPercentChance)) return false;
                if (!object.Equals(this.AttackPercentChance, rhs.AttackPercentChance)) return false;
                if (!object.Equals(this.RecoilStaggerBonusToAttack, rhs.RecoilStaggerBonusToAttack)) return false;
                if (!object.Equals(this.UnconsciousBonusToAttack, rhs.UnconsciousBonusToAttack)) return false;
                if (!object.Equals(this.HandToHandBonusToAttack, rhs.HandToHandBonusToAttack)) return false;
                if (!object.Equals(this.PowerAttackPercentChance, rhs.PowerAttackPercentChance)) return false;
                if (!object.Equals(this.RecoilStaggerBonusToPowerAttack, rhs.RecoilStaggerBonusToPowerAttack)) return false;
                if (!object.Equals(this.UnconsciousBonusToPowerAttack, rhs.UnconsciousBonusToPowerAttack)) return false;
                if (!object.Equals(this.PowerAttackNormal, rhs.PowerAttackNormal)) return false;
                if (!object.Equals(this.PowerAttackForward, rhs.PowerAttackForward)) return false;
                if (!object.Equals(this.PowerAttackBack, rhs.PowerAttackBack)) return false;
                if (!object.Equals(this.PowerAttackLeft, rhs.PowerAttackLeft)) return false;
                if (!object.Equals(this.PowerAttackRight, rhs.PowerAttackRight)) return false;
                if (!object.Equals(this.HoldTimerMin, rhs.HoldTimerMin)) return false;
                if (!object.Equals(this.HoldTimerMax, rhs.HoldTimerMax)) return false;
                if (!object.Equals(this.Flags, rhs.Flags)) return false;
                if (!object.Equals(this.AcrobaticDodgePercentChance, rhs.AcrobaticDodgePercentChance)) return false;
                if (!object.Equals(this.RangeMultOptimal, rhs.RangeMultOptimal)) return false;
                if (!object.Equals(this.RangeMultMax, rhs.RangeMultMax)) return false;
                if (!object.Equals(this.SwitchDistanceMelee, rhs.SwitchDistanceMelee)) return false;
                if (!object.Equals(this.SwitchDistanceRanged, rhs.SwitchDistanceRanged)) return false;
                if (!object.Equals(this.BuffStandoffDistance, rhs.BuffStandoffDistance)) return false;
                if (!object.Equals(this.RangedStandoffDistance, rhs.RangedStandoffDistance)) return false;
                if (!object.Equals(this.GroupStandoffDistance, rhs.GroupStandoffDistance)) return false;
                if (!object.Equals(this.RushingAttackPercentChance, rhs.RushingAttackPercentChance)) return false;
                if (!object.Equals(this.RushingAttackDistanceMult, rhs.RushingAttackDistanceMult)) return false;
                return true;
            }
            public override int GetHashCode()
            {
                var hash = new HashCode();
                hash.Add(this.Versioning);
                hash.Add(this.DodgePercentChance);
                hash.Add(this.LeftRightPercentChance);
                hash.Add(this.DodgeLeftRightTimerMin);
                hash.Add(this.DodgeLeftRightTimerMax);
                hash.Add(this.DodgeForwardTimerMin);
                hash.Add(this.DodgeForwardTimerMax);
                hash.Add(this.DodgeBackTimerMin);
                hash.Add(this.DodgeBackTimerMax);
                hash.Add(this.IdleTimerMin);
                hash.Add(this.IdleTimerMax);
                hash.Add(this.BlockPercentChance);
                hash.Add(this.AttackPercentChance);
                hash.Add(this.RecoilStaggerBonusToAttack);
                hash.Add(this.UnconsciousBonusToAttack);
                hash.Add(this.HandToHandBonusToAttack);
                hash.Add(this.PowerAttackPercentChance);
                hash.Add(this.RecoilStaggerBonusToPowerAttack);
                hash.Add(this.UnconsciousBonusToPowerAttack);
                hash.Add(this.PowerAttackNormal);
                hash.Add(this.PowerAttackForward);
                hash.Add(this.PowerAttackBack);
                hash.Add(this.PowerAttackLeft);
                hash.Add(this.PowerAttackRight);
                hash.Add(this.HoldTimerMin);
                hash.Add(this.HoldTimerMax);
                hash.Add(this.Flags);
                hash.Add(this.AcrobaticDodgePercentChance);
                hash.Add(this.RangeMultOptimal);
                hash.Add(this.RangeMultMax);
                hash.Add(this.SwitchDistanceMelee);
                hash.Add(this.SwitchDistanceRanged);
                hash.Add(this.BuffStandoffDistance);
                hash.Add(this.RangedStandoffDistance);
                hash.Add(this.GroupStandoffDistance);
                hash.Add(this.RushingAttackPercentChance);
                hash.Add(this.RushingAttackDistanceMult);
                return hash.ToHashCode();
            }

            #endregion

            #region All
            public bool All(Func<TItem, bool> eval)
            {
                if (!eval(this.Versioning)) return false;
                if (!eval(this.DodgePercentChance)) return false;
                if (!eval(this.LeftRightPercentChance)) return false;
                if (!eval(this.DodgeLeftRightTimerMin)) return false;
                if (!eval(this.DodgeLeftRightTimerMax)) return false;
                if (!eval(this.DodgeForwardTimerMin)) return false;
                if (!eval(this.DodgeForwardTimerMax)) return false;
                if (!eval(this.DodgeBackTimerMin)) return false;
                if (!eval(this.DodgeBackTimerMax)) return false;
                if (!eval(this.IdleTimerMin)) return false;
                if (!eval(this.IdleTimerMax)) return false;
                if (!eval(this.BlockPercentChance)) return false;
                if (!eval(this.AttackPercentChance)) return false;
                if (!eval(this.RecoilStaggerBonusToAttack)) return false;
                if (!eval(this.UnconsciousBonusToAttack)) return false;
                if (!eval(this.HandToHandBonusToAttack)) return false;
                if (!eval(this.PowerAttackPercentChance)) return false;
                if (!eval(this.RecoilStaggerBonusToPowerAttack)) return false;
                if (!eval(this.UnconsciousBonusToPowerAttack)) return false;
                if (!eval(this.PowerAttackNormal)) return false;
                if (!eval(this.PowerAttackForward)) return false;
                if (!eval(this.PowerAttackBack)) return false;
                if (!eval(this.PowerAttackLeft)) return false;
                if (!eval(this.PowerAttackRight)) return false;
                if (!eval(this.HoldTimerMin)) return false;
                if (!eval(this.HoldTimerMax)) return false;
                if (!eval(this.Flags)) return false;
                if (!eval(this.AcrobaticDodgePercentChance)) return false;
                if (!eval(this.RangeMultOptimal)) return false;
                if (!eval(this.RangeMultMax)) return false;
                if (!eval(this.SwitchDistanceMelee)) return false;
                if (!eval(this.SwitchDistanceRanged)) return false;
                if (!eval(this.BuffStandoffDistance)) return false;
                if (!eval(this.RangedStandoffDistance)) return false;
                if (!eval(this.GroupStandoffDistance)) return false;
                if (!eval(this.RushingAttackPercentChance)) return false;
                if (!eval(this.RushingAttackDistanceMult)) return false;
                return true;
            }
            #endregion

            #region Any
            public bool Any(Func<TItem, bool> eval)
            {
                if (eval(this.Versioning)) return true;
                if (eval(this.DodgePercentChance)) return true;
                if (eval(this.LeftRightPercentChance)) return true;
                if (eval(this.DodgeLeftRightTimerMin)) return true;
                if (eval(this.DodgeLeftRightTimerMax)) return true;
                if (eval(this.DodgeForwardTimerMin)) return true;
                if (eval(this.DodgeForwardTimerMax)) return true;
                if (eval(this.DodgeBackTimerMin)) return true;
                if (eval(this.DodgeBackTimerMax)) return true;
                if (eval(this.IdleTimerMin)) return true;
                if (eval(this.IdleTimerMax)) return true;
                if (eval(this.BlockPercentChance)) return true;
                if (eval(this.AttackPercentChance)) return true;
                if (eval(this.RecoilStaggerBonusToAttack)) return true;
                if (eval(this.UnconsciousBonusToAttack)) return true;
                if (eval(this.HandToHandBonusToAttack)) return true;
                if (eval(this.PowerAttackPercentChance)) return true;
                if (eval(this.RecoilStaggerBonusToPowerAttack)) return true;
                if (eval(this.UnconsciousBonusToPowerAttack)) return true;
                if (eval(this.PowerAttackNormal)) return true;
                if (eval(this.PowerAttackForward)) return true;
                if (eval(this.PowerAttackBack)) return true;
                if (eval(this.PowerAttackLeft)) return true;
                if (eval(this.PowerAttackRight)) return true;
                if (eval(this.HoldTimerMin)) return true;
                if (eval(this.HoldTimerMax)) return true;
                if (eval(this.Flags)) return true;
                if (eval(this.AcrobaticDodgePercentChance)) return true;
                if (eval(this.RangeMultOptimal)) return true;
                if (eval(this.RangeMultMax)) return true;
                if (eval(this.SwitchDistanceMelee)) return true;
                if (eval(this.SwitchDistanceRanged)) return true;
                if (eval(this.BuffStandoffDistance)) return true;
                if (eval(this.RangedStandoffDistance)) return true;
                if (eval(this.GroupStandoffDistance)) return true;
                if (eval(this.RushingAttackPercentChance)) return true;
                if (eval(this.RushingAttackDistanceMult)) return true;
                return false;
            }
            #endregion

            #region Translate
            public Mask<R> Translate<R>(Func<TItem, R> eval)
            {
                var ret = new CombatStyleData.Mask<R>();
                this.Translate_InternalFill(ret, eval);
                return ret;
            }

            protected void Translate_InternalFill<R>(Mask<R> obj, Func<TItem, R> eval)
            {
                obj.Versioning = eval(this.Versioning);
                obj.DodgePercentChance = eval(this.DodgePercentChance);
                obj.LeftRightPercentChance = eval(this.LeftRightPercentChance);
                obj.DodgeLeftRightTimerMin = eval(this.DodgeLeftRightTimerMin);
                obj.DodgeLeftRightTimerMax = eval(this.DodgeLeftRightTimerMax);
                obj.DodgeForwardTimerMin = eval(this.DodgeForwardTimerMin);
                obj.DodgeForwardTimerMax = eval(this.DodgeForwardTimerMax);
                obj.DodgeBackTimerMin = eval(this.DodgeBackTimerMin);
                obj.DodgeBackTimerMax = eval(this.DodgeBackTimerMax);
                obj.IdleTimerMin = eval(this.IdleTimerMin);
                obj.IdleTimerMax = eval(this.IdleTimerMax);
                obj.BlockPercentChance = eval(this.BlockPercentChance);
                obj.AttackPercentChance = eval(this.AttackPercentChance);
                obj.RecoilStaggerBonusToAttack = eval(this.RecoilStaggerBonusToAttack);
                obj.UnconsciousBonusToAttack = eval(this.UnconsciousBonusToAttack);
                obj.HandToHandBonusToAttack = eval(this.HandToHandBonusToAttack);
                obj.PowerAttackPercentChance = eval(this.PowerAttackPercentChance);
                obj.RecoilStaggerBonusToPowerAttack = eval(this.RecoilStaggerBonusToPowerAttack);
                obj.UnconsciousBonusToPowerAttack = eval(this.UnconsciousBonusToPowerAttack);
                obj.PowerAttackNormal = eval(this.PowerAttackNormal);
                obj.PowerAttackForward = eval(this.PowerAttackForward);
                obj.PowerAttackBack = eval(this.PowerAttackBack);
                obj.PowerAttackLeft = eval(this.PowerAttackLeft);
                obj.PowerAttackRight = eval(this.PowerAttackRight);
                obj.HoldTimerMin = eval(this.HoldTimerMin);
                obj.HoldTimerMax = eval(this.HoldTimerMax);
                obj.Flags = eval(this.Flags);
                obj.AcrobaticDodgePercentChance = eval(this.AcrobaticDodgePercentChance);
                obj.RangeMultOptimal = eval(this.RangeMultOptimal);
                obj.RangeMultMax = eval(this.RangeMultMax);
                obj.SwitchDistanceMelee = eval(this.SwitchDistanceMelee);
                obj.SwitchDistanceRanged = eval(this.SwitchDistanceRanged);
                obj.BuffStandoffDistance = eval(this.BuffStandoffDistance);
                obj.RangedStandoffDistance = eval(this.RangedStandoffDistance);
                obj.GroupStandoffDistance = eval(this.GroupStandoffDistance);
                obj.RushingAttackPercentChance = eval(this.RushingAttackPercentChance);
                obj.RushingAttackDistanceMult = eval(this.RushingAttackDistanceMult);
            }
            #endregion

            #region To String
            public override string ToString()
            {
                return ToString(printMask: null);
            }

            public string ToString(CombatStyleData.Mask<bool>? printMask = null)
            {
                var fg = new FileGeneration();
                ToString(fg, printMask);
                return fg.ToString();
            }

            public void ToString(FileGeneration fg, CombatStyleData.Mask<bool>? printMask = null)
            {
                fg.AppendLine($"{nameof(CombatStyleData.Mask<TItem>)} =>");
                fg.AppendLine("[");
                using (new DepthWrapper(fg))
                {
                    if (printMask?.Versioning ?? true)
                    {
                        fg.AppendItem(Versioning, "Versioning");
                    }
                    if (printMask?.DodgePercentChance ?? true)
                    {
                        fg.AppendItem(DodgePercentChance, "DodgePercentChance");
                    }
                    if (printMask?.LeftRightPercentChance ?? true)
                    {
                        fg.AppendItem(LeftRightPercentChance, "LeftRightPercentChance");
                    }
                    if (printMask?.DodgeLeftRightTimerMin ?? true)
                    {
                        fg.AppendItem(DodgeLeftRightTimerMin, "DodgeLeftRightTimerMin");
                    }
                    if (printMask?.DodgeLeftRightTimerMax ?? true)
                    {
                        fg.AppendItem(DodgeLeftRightTimerMax, "DodgeLeftRightTimerMax");
                    }
                    if (printMask?.DodgeForwardTimerMin ?? true)
                    {
                        fg.AppendItem(DodgeForwardTimerMin, "DodgeForwardTimerMin");
                    }
                    if (printMask?.DodgeForwardTimerMax ?? true)
                    {
                        fg.AppendItem(DodgeForwardTimerMax, "DodgeForwardTimerMax");
                    }
                    if (printMask?.DodgeBackTimerMin ?? true)
                    {
                        fg.AppendItem(DodgeBackTimerMin, "DodgeBackTimerMin");
                    }
                    if (printMask?.DodgeBackTimerMax ?? true)
                    {
                        fg.AppendItem(DodgeBackTimerMax, "DodgeBackTimerMax");
                    }
                    if (printMask?.IdleTimerMin ?? true)
                    {
                        fg.AppendItem(IdleTimerMin, "IdleTimerMin");
                    }
                    if (printMask?.IdleTimerMax ?? true)
                    {
                        fg.AppendItem(IdleTimerMax, "IdleTimerMax");
                    }
                    if (printMask?.BlockPercentChance ?? true)
                    {
                        fg.AppendItem(BlockPercentChance, "BlockPercentChance");
                    }
                    if (printMask?.AttackPercentChance ?? true)
                    {
                        fg.AppendItem(AttackPercentChance, "AttackPercentChance");
                    }
                    if (printMask?.RecoilStaggerBonusToAttack ?? true)
                    {
                        fg.AppendItem(RecoilStaggerBonusToAttack, "RecoilStaggerBonusToAttack");
                    }
                    if (printMask?.UnconsciousBonusToAttack ?? true)
                    {
                        fg.AppendItem(UnconsciousBonusToAttack, "UnconsciousBonusToAttack");
                    }
                    if (printMask?.HandToHandBonusToAttack ?? true)
                    {
                        fg.AppendItem(HandToHandBonusToAttack, "HandToHandBonusToAttack");
                    }
                    if (printMask?.PowerAttackPercentChance ?? true)
                    {
                        fg.AppendItem(PowerAttackPercentChance, "PowerAttackPercentChance");
                    }
                    if (printMask?.RecoilStaggerBonusToPowerAttack ?? true)
                    {
                        fg.AppendItem(RecoilStaggerBonusToPowerAttack, "RecoilStaggerBonusToPowerAttack");
                    }
                    if (printMask?.UnconsciousBonusToPowerAttack ?? true)
                    {
                        fg.AppendItem(UnconsciousBonusToPowerAttack, "UnconsciousBonusToPowerAttack");
                    }
                    if (printMask?.PowerAttackNormal ?? true)
                    {
                        fg.AppendItem(PowerAttackNormal, "PowerAttackNormal");
                    }
                    if (printMask?.PowerAttackForward ?? true)
                    {
                        fg.AppendItem(PowerAttackForward, "PowerAttackForward");
                    }
                    if (printMask?.PowerAttackBack ?? true)
                    {
                        fg.AppendItem(PowerAttackBack, "PowerAttackBack");
                    }
                    if (printMask?.PowerAttackLeft ?? true)
                    {
                        fg.AppendItem(PowerAttackLeft, "PowerAttackLeft");
                    }
                    if (printMask?.PowerAttackRight ?? true)
                    {
                        fg.AppendItem(PowerAttackRight, "PowerAttackRight");
                    }
                    if (printMask?.HoldTimerMin ?? true)
                    {
                        fg.AppendItem(HoldTimerMin, "HoldTimerMin");
                    }
                    if (printMask?.HoldTimerMax ?? true)
                    {
                        fg.AppendItem(HoldTimerMax, "HoldTimerMax");
                    }
                    if (printMask?.Flags ?? true)
                    {
                        fg.AppendItem(Flags, "Flags");
                    }
                    if (printMask?.AcrobaticDodgePercentChance ?? true)
                    {
                        fg.AppendItem(AcrobaticDodgePercentChance, "AcrobaticDodgePercentChance");
                    }
                    if (printMask?.RangeMultOptimal ?? true)
                    {
                        fg.AppendItem(RangeMultOptimal, "RangeMultOptimal");
                    }
                    if (printMask?.RangeMultMax ?? true)
                    {
                        fg.AppendItem(RangeMultMax, "RangeMultMax");
                    }
                    if (printMask?.SwitchDistanceMelee ?? true)
                    {
                        fg.AppendItem(SwitchDistanceMelee, "SwitchDistanceMelee");
                    }
                    if (printMask?.SwitchDistanceRanged ?? true)
                    {
                        fg.AppendItem(SwitchDistanceRanged, "SwitchDistanceRanged");
                    }
                    if (printMask?.BuffStandoffDistance ?? true)
                    {
                        fg.AppendItem(BuffStandoffDistance, "BuffStandoffDistance");
                    }
                    if (printMask?.RangedStandoffDistance ?? true)
                    {
                        fg.AppendItem(RangedStandoffDistance, "RangedStandoffDistance");
                    }
                    if (printMask?.GroupStandoffDistance ?? true)
                    {
                        fg.AppendItem(GroupStandoffDistance, "GroupStandoffDistance");
                    }
                    if (printMask?.RushingAttackPercentChance ?? true)
                    {
                        fg.AppendItem(RushingAttackPercentChance, "RushingAttackPercentChance");
                    }
                    if (printMask?.RushingAttackDistanceMult ?? true)
                    {
                        fg.AppendItem(RushingAttackDistanceMult, "RushingAttackDistanceMult");
                    }
                }
                fg.AppendLine("]");
            }
            #endregion

        }

        public class ErrorMask :
            IErrorMask,
            IErrorMask<ErrorMask>
        {
            #region Members
            public Exception? Overall { get; set; }
            private List<string>? _warnings;
            public List<string> Warnings
            {
                get
                {
                    if (_warnings == null)
                    {
                        _warnings = new List<string>();
                    }
                    return _warnings;
                }
            }
            public Exception? Versioning;
            public Exception? DodgePercentChance;
            public Exception? LeftRightPercentChance;
            public Exception? DodgeLeftRightTimerMin;
            public Exception? DodgeLeftRightTimerMax;
            public Exception? DodgeForwardTimerMin;
            public Exception? DodgeForwardTimerMax;
            public Exception? DodgeBackTimerMin;
            public Exception? DodgeBackTimerMax;
            public Exception? IdleTimerMin;
            public Exception? IdleTimerMax;
            public Exception? BlockPercentChance;
            public Exception? AttackPercentChance;
            public Exception? RecoilStaggerBonusToAttack;
            public Exception? UnconsciousBonusToAttack;
            public Exception? HandToHandBonusToAttack;
            public Exception? PowerAttackPercentChance;
            public Exception? RecoilStaggerBonusToPowerAttack;
            public Exception? UnconsciousBonusToPowerAttack;
            public Exception? PowerAttackNormal;
            public Exception? PowerAttackForward;
            public Exception? PowerAttackBack;
            public Exception? PowerAttackLeft;
            public Exception? PowerAttackRight;
            public Exception? HoldTimerMin;
            public Exception? HoldTimerMax;
            public Exception? Flags;
            public Exception? AcrobaticDodgePercentChance;
            public Exception? RangeMultOptimal;
            public Exception? RangeMultMax;
            public Exception? SwitchDistanceMelee;
            public Exception? SwitchDistanceRanged;
            public Exception? BuffStandoffDistance;
            public Exception? RangedStandoffDistance;
            public Exception? GroupStandoffDistance;
            public Exception? RushingAttackPercentChance;
            public Exception? RushingAttackDistanceMult;
            #endregion

            #region IErrorMask
            public object? GetNthMask(int index)
            {
                CombatStyleData_FieldIndex enu = (CombatStyleData_FieldIndex)index;
                switch (enu)
                {
                    case CombatStyleData_FieldIndex.Versioning:
                        return Versioning;
                    case CombatStyleData_FieldIndex.DodgePercentChance:
                        return DodgePercentChance;
                    case CombatStyleData_FieldIndex.LeftRightPercentChance:
                        return LeftRightPercentChance;
                    case CombatStyleData_FieldIndex.DodgeLeftRightTimerMin:
                        return DodgeLeftRightTimerMin;
                    case CombatStyleData_FieldIndex.DodgeLeftRightTimerMax:
                        return DodgeLeftRightTimerMax;
                    case CombatStyleData_FieldIndex.DodgeForwardTimerMin:
                        return DodgeForwardTimerMin;
                    case CombatStyleData_FieldIndex.DodgeForwardTimerMax:
                        return DodgeForwardTimerMax;
                    case CombatStyleData_FieldIndex.DodgeBackTimerMin:
                        return DodgeBackTimerMin;
                    case CombatStyleData_FieldIndex.DodgeBackTimerMax:
                        return DodgeBackTimerMax;
                    case CombatStyleData_FieldIndex.IdleTimerMin:
                        return IdleTimerMin;
                    case CombatStyleData_FieldIndex.IdleTimerMax:
                        return IdleTimerMax;
                    case CombatStyleData_FieldIndex.BlockPercentChance:
                        return BlockPercentChance;
                    case CombatStyleData_FieldIndex.AttackPercentChance:
                        return AttackPercentChance;
                    case CombatStyleData_FieldIndex.RecoilStaggerBonusToAttack:
                        return RecoilStaggerBonusToAttack;
                    case CombatStyleData_FieldIndex.UnconsciousBonusToAttack:
                        return UnconsciousBonusToAttack;
                    case CombatStyleData_FieldIndex.HandToHandBonusToAttack:
                        return HandToHandBonusToAttack;
                    case CombatStyleData_FieldIndex.PowerAttackPercentChance:
                        return PowerAttackPercentChance;
                    case CombatStyleData_FieldIndex.RecoilStaggerBonusToPowerAttack:
                        return RecoilStaggerBonusToPowerAttack;
                    case CombatStyleData_FieldIndex.UnconsciousBonusToPowerAttack:
                        return UnconsciousBonusToPowerAttack;
                    case CombatStyleData_FieldIndex.PowerAttackNormal:
                        return PowerAttackNormal;
                    case CombatStyleData_FieldIndex.PowerAttackForward:
                        return PowerAttackForward;
                    case CombatStyleData_FieldIndex.PowerAttackBack:
                        return PowerAttackBack;
                    case CombatStyleData_FieldIndex.PowerAttackLeft:
                        return PowerAttackLeft;
                    case CombatStyleData_FieldIndex.PowerAttackRight:
                        return PowerAttackRight;
                    case CombatStyleData_FieldIndex.HoldTimerMin:
                        return HoldTimerMin;
                    case CombatStyleData_FieldIndex.HoldTimerMax:
                        return HoldTimerMax;
                    case CombatStyleData_FieldIndex.Flags:
                        return Flags;
                    case CombatStyleData_FieldIndex.AcrobaticDodgePercentChance:
                        return AcrobaticDodgePercentChance;
                    case CombatStyleData_FieldIndex.RangeMultOptimal:
                        return RangeMultOptimal;
                    case CombatStyleData_FieldIndex.RangeMultMax:
                        return RangeMultMax;
                    case CombatStyleData_FieldIndex.SwitchDistanceMelee:
                        return SwitchDistanceMelee;
                    case CombatStyleData_FieldIndex.SwitchDistanceRanged:
                        return SwitchDistanceRanged;
                    case CombatStyleData_FieldIndex.BuffStandoffDistance:
                        return BuffStandoffDistance;
                    case CombatStyleData_FieldIndex.RangedStandoffDistance:
                        return RangedStandoffDistance;
                    case CombatStyleData_FieldIndex.GroupStandoffDistance:
                        return GroupStandoffDistance;
                    case CombatStyleData_FieldIndex.RushingAttackPercentChance:
                        return RushingAttackPercentChance;
                    case CombatStyleData_FieldIndex.RushingAttackDistanceMult:
                        return RushingAttackDistanceMult;
                    default:
                        throw new ArgumentException($"Index is out of range: {index}");
                }
            }

            public void SetNthException(int index, Exception ex)
            {
                CombatStyleData_FieldIndex enu = (CombatStyleData_FieldIndex)index;
                switch (enu)
                {
                    case CombatStyleData_FieldIndex.Versioning:
                        this.Versioning = ex;
                        break;
                    case CombatStyleData_FieldIndex.DodgePercentChance:
                        this.DodgePercentChance = ex;
                        break;
                    case CombatStyleData_FieldIndex.LeftRightPercentChance:
                        this.LeftRightPercentChance = ex;
                        break;
                    case CombatStyleData_FieldIndex.DodgeLeftRightTimerMin:
                        this.DodgeLeftRightTimerMin = ex;
                        break;
                    case CombatStyleData_FieldIndex.DodgeLeftRightTimerMax:
                        this.DodgeLeftRightTimerMax = ex;
                        break;
                    case CombatStyleData_FieldIndex.DodgeForwardTimerMin:
                        this.DodgeForwardTimerMin = ex;
                        break;
                    case CombatStyleData_FieldIndex.DodgeForwardTimerMax:
                        this.DodgeForwardTimerMax = ex;
                        break;
                    case CombatStyleData_FieldIndex.DodgeBackTimerMin:
                        this.DodgeBackTimerMin = ex;
                        break;
                    case CombatStyleData_FieldIndex.DodgeBackTimerMax:
                        this.DodgeBackTimerMax = ex;
                        break;
                    case CombatStyleData_FieldIndex.IdleTimerMin:
                        this.IdleTimerMin = ex;
                        break;
                    case CombatStyleData_FieldIndex.IdleTimerMax:
                        this.IdleTimerMax = ex;
                        break;
                    case CombatStyleData_FieldIndex.BlockPercentChance:
                        this.BlockPercentChance = ex;
                        break;
                    case CombatStyleData_FieldIndex.AttackPercentChance:
                        this.AttackPercentChance = ex;
                        break;
                    case CombatStyleData_FieldIndex.RecoilStaggerBonusToAttack:
                        this.RecoilStaggerBonusToAttack = ex;
                        break;
                    case CombatStyleData_FieldIndex.UnconsciousBonusToAttack:
                        this.UnconsciousBonusToAttack = ex;
                        break;
                    case CombatStyleData_FieldIndex.HandToHandBonusToAttack:
                        this.HandToHandBonusToAttack = ex;
                        break;
                    case CombatStyleData_FieldIndex.PowerAttackPercentChance:
                        this.PowerAttackPercentChance = ex;
                        break;
                    case CombatStyleData_FieldIndex.RecoilStaggerBonusToPowerAttack:
                        this.RecoilStaggerBonusToPowerAttack = ex;
                        break;
                    case CombatStyleData_FieldIndex.UnconsciousBonusToPowerAttack:
                        this.UnconsciousBonusToPowerAttack = ex;
                        break;
                    case CombatStyleData_FieldIndex.PowerAttackNormal:
                        this.PowerAttackNormal = ex;
                        break;
                    case CombatStyleData_FieldIndex.PowerAttackForward:
                        this.PowerAttackForward = ex;
                        break;
                    case CombatStyleData_FieldIndex.PowerAttackBack:
                        this.PowerAttackBack = ex;
                        break;
                    case CombatStyleData_FieldIndex.PowerAttackLeft:
                        this.PowerAttackLeft = ex;
                        break;
                    case CombatStyleData_FieldIndex.PowerAttackRight:
                        this.PowerAttackRight = ex;
                        break;
                    case CombatStyleData_FieldIndex.HoldTimerMin:
                        this.HoldTimerMin = ex;
                        break;
                    case CombatStyleData_FieldIndex.HoldTimerMax:
                        this.HoldTimerMax = ex;
                        break;
                    case CombatStyleData_FieldIndex.Flags:
                        this.Flags = ex;
                        break;
                    case CombatStyleData_FieldIndex.AcrobaticDodgePercentChance:
                        this.AcrobaticDodgePercentChance = ex;
                        break;
                    case CombatStyleData_FieldIndex.RangeMultOptimal:
                        this.RangeMultOptimal = ex;
                        break;
                    case CombatStyleData_FieldIndex.RangeMultMax:
                        this.RangeMultMax = ex;
                        break;
                    case CombatStyleData_FieldIndex.SwitchDistanceMelee:
                        this.SwitchDistanceMelee = ex;
                        break;
                    case CombatStyleData_FieldIndex.SwitchDistanceRanged:
                        this.SwitchDistanceRanged = ex;
                        break;
                    case CombatStyleData_FieldIndex.BuffStandoffDistance:
                        this.BuffStandoffDistance = ex;
                        break;
                    case CombatStyleData_FieldIndex.RangedStandoffDistance:
                        this.RangedStandoffDistance = ex;
                        break;
                    case CombatStyleData_FieldIndex.GroupStandoffDistance:
                        this.GroupStandoffDistance = ex;
                        break;
                    case CombatStyleData_FieldIndex.RushingAttackPercentChance:
                        this.RushingAttackPercentChance = ex;
                        break;
                    case CombatStyleData_FieldIndex.RushingAttackDistanceMult:
                        this.RushingAttackDistanceMult = ex;
                        break;
                    default:
                        throw new ArgumentException($"Index is out of range: {index}");
                }
            }

            public void SetNthMask(int index, object obj)
            {
                CombatStyleData_FieldIndex enu = (CombatStyleData_FieldIndex)index;
                switch (enu)
                {
                    case CombatStyleData_FieldIndex.Versioning:
                        this.Versioning = (Exception?)obj;
                        break;
                    case CombatStyleData_FieldIndex.DodgePercentChance:
                        this.DodgePercentChance = (Exception?)obj;
                        break;
                    case CombatStyleData_FieldIndex.LeftRightPercentChance:
                        this.LeftRightPercentChance = (Exception?)obj;
                        break;
                    case CombatStyleData_FieldIndex.DodgeLeftRightTimerMin:
                        this.DodgeLeftRightTimerMin = (Exception?)obj;
                        break;
                    case CombatStyleData_FieldIndex.DodgeLeftRightTimerMax:
                        this.DodgeLeftRightTimerMax = (Exception?)obj;
                        break;
                    case CombatStyleData_FieldIndex.DodgeForwardTimerMin:
                        this.DodgeForwardTimerMin = (Exception?)obj;
                        break;
                    case CombatStyleData_FieldIndex.DodgeForwardTimerMax:
                        this.DodgeForwardTimerMax = (Exception?)obj;
                        break;
                    case CombatStyleData_FieldIndex.DodgeBackTimerMin:
                        this.DodgeBackTimerMin = (Exception?)obj;
                        break;
                    case CombatStyleData_FieldIndex.DodgeBackTimerMax:
                        this.DodgeBackTimerMax = (Exception?)obj;
                        break;
                    case CombatStyleData_FieldIndex.IdleTimerMin:
                        this.IdleTimerMin = (Exception?)obj;
                        break;
                    case CombatStyleData_FieldIndex.IdleTimerMax:
                        this.IdleTimerMax = (Exception?)obj;
                        break;
                    case CombatStyleData_FieldIndex.BlockPercentChance:
                        this.BlockPercentChance = (Exception?)obj;
                        break;
                    case CombatStyleData_FieldIndex.AttackPercentChance:
                        this.AttackPercentChance = (Exception?)obj;
                        break;
                    case CombatStyleData_FieldIndex.RecoilStaggerBonusToAttack:
                        this.RecoilStaggerBonusToAttack = (Exception?)obj;
                        break;
                    case CombatStyleData_FieldIndex.UnconsciousBonusToAttack:
                        this.UnconsciousBonusToAttack = (Exception?)obj;
                        break;
                    case CombatStyleData_FieldIndex.HandToHandBonusToAttack:
                        this.HandToHandBonusToAttack = (Exception?)obj;
                        break;
                    case CombatStyleData_FieldIndex.PowerAttackPercentChance:
                        this.PowerAttackPercentChance = (Exception?)obj;
                        break;
                    case CombatStyleData_FieldIndex.RecoilStaggerBonusToPowerAttack:
                        this.RecoilStaggerBonusToPowerAttack = (Exception?)obj;
                        break;
                    case CombatStyleData_FieldIndex.UnconsciousBonusToPowerAttack:
                        this.UnconsciousBonusToPowerAttack = (Exception?)obj;
                        break;
                    case CombatStyleData_FieldIndex.PowerAttackNormal:
                        this.PowerAttackNormal = (Exception?)obj;
                        break;
                    case CombatStyleData_FieldIndex.PowerAttackForward:
                        this.PowerAttackForward = (Exception?)obj;
                        break;
                    case CombatStyleData_FieldIndex.PowerAttackBack:
                        this.PowerAttackBack = (Exception?)obj;
                        break;
                    case CombatStyleData_FieldIndex.PowerAttackLeft:
                        this.PowerAttackLeft = (Exception?)obj;
                        break;
                    case CombatStyleData_FieldIndex.PowerAttackRight:
                        this.PowerAttackRight = (Exception?)obj;
                        break;
                    case CombatStyleData_FieldIndex.HoldTimerMin:
                        this.HoldTimerMin = (Exception?)obj;
                        break;
                    case CombatStyleData_FieldIndex.HoldTimerMax:
                        this.HoldTimerMax = (Exception?)obj;
                        break;
                    case CombatStyleData_FieldIndex.Flags:
                        this.Flags = (Exception?)obj;
                        break;
                    case CombatStyleData_FieldIndex.AcrobaticDodgePercentChance:
                        this.AcrobaticDodgePercentChance = (Exception?)obj;
                        break;
                    case CombatStyleData_FieldIndex.RangeMultOptimal:
                        this.RangeMultOptimal = (Exception?)obj;
                        break;
                    case CombatStyleData_FieldIndex.RangeMultMax:
                        this.RangeMultMax = (Exception?)obj;
                        break;
                    case CombatStyleData_FieldIndex.SwitchDistanceMelee:
                        this.SwitchDistanceMelee = (Exception?)obj;
                        break;
                    case CombatStyleData_FieldIndex.SwitchDistanceRanged:
                        this.SwitchDistanceRanged = (Exception?)obj;
                        break;
                    case CombatStyleData_FieldIndex.BuffStandoffDistance:
                        this.BuffStandoffDistance = (Exception?)obj;
                        break;
                    case CombatStyleData_FieldIndex.RangedStandoffDistance:
                        this.RangedStandoffDistance = (Exception?)obj;
                        break;
                    case CombatStyleData_FieldIndex.GroupStandoffDistance:
                        this.GroupStandoffDistance = (Exception?)obj;
                        break;
                    case CombatStyleData_FieldIndex.RushingAttackPercentChance:
                        this.RushingAttackPercentChance = (Exception?)obj;
                        break;
                    case CombatStyleData_FieldIndex.RushingAttackDistanceMult:
                        this.RushingAttackDistanceMult = (Exception?)obj;
                        break;
                    default:
                        throw new ArgumentException($"Index is out of range: {index}");
                }
            }

            public bool IsInError()
            {
                if (Overall != null) return true;
                if (Versioning != null) return true;
                if (DodgePercentChance != null) return true;
                if (LeftRightPercentChance != null) return true;
                if (DodgeLeftRightTimerMin != null) return true;
                if (DodgeLeftRightTimerMax != null) return true;
                if (DodgeForwardTimerMin != null) return true;
                if (DodgeForwardTimerMax != null) return true;
                if (DodgeBackTimerMin != null) return true;
                if (DodgeBackTimerMax != null) return true;
                if (IdleTimerMin != null) return true;
                if (IdleTimerMax != null) return true;
                if (BlockPercentChance != null) return true;
                if (AttackPercentChance != null) return true;
                if (RecoilStaggerBonusToAttack != null) return true;
                if (UnconsciousBonusToAttack != null) return true;
                if (HandToHandBonusToAttack != null) return true;
                if (PowerAttackPercentChance != null) return true;
                if (RecoilStaggerBonusToPowerAttack != null) return true;
                if (UnconsciousBonusToPowerAttack != null) return true;
                if (PowerAttackNormal != null) return true;
                if (PowerAttackForward != null) return true;
                if (PowerAttackBack != null) return true;
                if (PowerAttackLeft != null) return true;
                if (PowerAttackRight != null) return true;
                if (HoldTimerMin != null) return true;
                if (HoldTimerMax != null) return true;
                if (Flags != null) return true;
                if (AcrobaticDodgePercentChance != null) return true;
                if (RangeMultOptimal != null) return true;
                if (RangeMultMax != null) return true;
                if (SwitchDistanceMelee != null) return true;
                if (SwitchDistanceRanged != null) return true;
                if (BuffStandoffDistance != null) return true;
                if (RangedStandoffDistance != null) return true;
                if (GroupStandoffDistance != null) return true;
                if (RushingAttackPercentChance != null) return true;
                if (RushingAttackDistanceMult != null) return true;
                return false;
            }
            #endregion

            #region To String
            public override string ToString()
            {
                var fg = new FileGeneration();
                ToString(fg, null);
                return fg.ToString();
            }

            public void ToString(FileGeneration fg, string? name = null)
            {
                fg.AppendLine($"{(name ?? "ErrorMask")} =>");
                fg.AppendLine("[");
                using (new DepthWrapper(fg))
                {
                    if (this.Overall != null)
                    {
                        fg.AppendLine("Overall =>");
                        fg.AppendLine("[");
                        using (new DepthWrapper(fg))
                        {
                            fg.AppendLine($"{this.Overall}");
                        }
                        fg.AppendLine("]");
                    }
                    ToString_FillInternal(fg);
                }
                fg.AppendLine("]");
            }
            protected void ToString_FillInternal(FileGeneration fg)
            {
                fg.AppendItem(Versioning, "Versioning");
                fg.AppendItem(DodgePercentChance, "DodgePercentChance");
                fg.AppendItem(LeftRightPercentChance, "LeftRightPercentChance");
                fg.AppendItem(DodgeLeftRightTimerMin, "DodgeLeftRightTimerMin");
                fg.AppendItem(DodgeLeftRightTimerMax, "DodgeLeftRightTimerMax");
                fg.AppendItem(DodgeForwardTimerMin, "DodgeForwardTimerMin");
                fg.AppendItem(DodgeForwardTimerMax, "DodgeForwardTimerMax");
                fg.AppendItem(DodgeBackTimerMin, "DodgeBackTimerMin");
                fg.AppendItem(DodgeBackTimerMax, "DodgeBackTimerMax");
                fg.AppendItem(IdleTimerMin, "IdleTimerMin");
                fg.AppendItem(IdleTimerMax, "IdleTimerMax");
                fg.AppendItem(BlockPercentChance, "BlockPercentChance");
                fg.AppendItem(AttackPercentChance, "AttackPercentChance");
                fg.AppendItem(RecoilStaggerBonusToAttack, "RecoilStaggerBonusToAttack");
                fg.AppendItem(UnconsciousBonusToAttack, "UnconsciousBonusToAttack");
                fg.AppendItem(HandToHandBonusToAttack, "HandToHandBonusToAttack");
                fg.AppendItem(PowerAttackPercentChance, "PowerAttackPercentChance");
                fg.AppendItem(RecoilStaggerBonusToPowerAttack, "RecoilStaggerBonusToPowerAttack");
                fg.AppendItem(UnconsciousBonusToPowerAttack, "UnconsciousBonusToPowerAttack");
                fg.AppendItem(PowerAttackNormal, "PowerAttackNormal");
                fg.AppendItem(PowerAttackForward, "PowerAttackForward");
                fg.AppendItem(PowerAttackBack, "PowerAttackBack");
                fg.AppendItem(PowerAttackLeft, "PowerAttackLeft");
                fg.AppendItem(PowerAttackRight, "PowerAttackRight");
                fg.AppendItem(HoldTimerMin, "HoldTimerMin");
                fg.AppendItem(HoldTimerMax, "HoldTimerMax");
                fg.AppendItem(Flags, "Flags");
                fg.AppendItem(AcrobaticDodgePercentChance, "AcrobaticDodgePercentChance");
                fg.AppendItem(RangeMultOptimal, "RangeMultOptimal");
                fg.AppendItem(RangeMultMax, "RangeMultMax");
                fg.AppendItem(SwitchDistanceMelee, "SwitchDistanceMelee");
                fg.AppendItem(SwitchDistanceRanged, "SwitchDistanceRanged");
                fg.AppendItem(BuffStandoffDistance, "BuffStandoffDistance");
                fg.AppendItem(RangedStandoffDistance, "RangedStandoffDistance");
                fg.AppendItem(GroupStandoffDistance, "GroupStandoffDistance");
                fg.AppendItem(RushingAttackPercentChance, "RushingAttackPercentChance");
                fg.AppendItem(RushingAttackDistanceMult, "RushingAttackDistanceMult");
            }
            #endregion

            #region Combine
            public ErrorMask Combine(ErrorMask? rhs)
            {
                if (rhs == null) return this;
                var ret = new ErrorMask();
                ret.Versioning = this.Versioning.Combine(rhs.Versioning);
                ret.DodgePercentChance = this.DodgePercentChance.Combine(rhs.DodgePercentChance);
                ret.LeftRightPercentChance = this.LeftRightPercentChance.Combine(rhs.LeftRightPercentChance);
                ret.DodgeLeftRightTimerMin = this.DodgeLeftRightTimerMin.Combine(rhs.DodgeLeftRightTimerMin);
                ret.DodgeLeftRightTimerMax = this.DodgeLeftRightTimerMax.Combine(rhs.DodgeLeftRightTimerMax);
                ret.DodgeForwardTimerMin = this.DodgeForwardTimerMin.Combine(rhs.DodgeForwardTimerMin);
                ret.DodgeForwardTimerMax = this.DodgeForwardTimerMax.Combine(rhs.DodgeForwardTimerMax);
                ret.DodgeBackTimerMin = this.DodgeBackTimerMin.Combine(rhs.DodgeBackTimerMin);
                ret.DodgeBackTimerMax = this.DodgeBackTimerMax.Combine(rhs.DodgeBackTimerMax);
                ret.IdleTimerMin = this.IdleTimerMin.Combine(rhs.IdleTimerMin);
                ret.IdleTimerMax = this.IdleTimerMax.Combine(rhs.IdleTimerMax);
                ret.BlockPercentChance = this.BlockPercentChance.Combine(rhs.BlockPercentChance);
                ret.AttackPercentChance = this.AttackPercentChance.Combine(rhs.AttackPercentChance);
                ret.RecoilStaggerBonusToAttack = this.RecoilStaggerBonusToAttack.Combine(rhs.RecoilStaggerBonusToAttack);
                ret.UnconsciousBonusToAttack = this.UnconsciousBonusToAttack.Combine(rhs.UnconsciousBonusToAttack);
                ret.HandToHandBonusToAttack = this.HandToHandBonusToAttack.Combine(rhs.HandToHandBonusToAttack);
                ret.PowerAttackPercentChance = this.PowerAttackPercentChance.Combine(rhs.PowerAttackPercentChance);
                ret.RecoilStaggerBonusToPowerAttack = this.RecoilStaggerBonusToPowerAttack.Combine(rhs.RecoilStaggerBonusToPowerAttack);
                ret.UnconsciousBonusToPowerAttack = this.UnconsciousBonusToPowerAttack.Combine(rhs.UnconsciousBonusToPowerAttack);
                ret.PowerAttackNormal = this.PowerAttackNormal.Combine(rhs.PowerAttackNormal);
                ret.PowerAttackForward = this.PowerAttackForward.Combine(rhs.PowerAttackForward);
                ret.PowerAttackBack = this.PowerAttackBack.Combine(rhs.PowerAttackBack);
                ret.PowerAttackLeft = this.PowerAttackLeft.Combine(rhs.PowerAttackLeft);
                ret.PowerAttackRight = this.PowerAttackRight.Combine(rhs.PowerAttackRight);
                ret.HoldTimerMin = this.HoldTimerMin.Combine(rhs.HoldTimerMin);
                ret.HoldTimerMax = this.HoldTimerMax.Combine(rhs.HoldTimerMax);
                ret.Flags = this.Flags.Combine(rhs.Flags);
                ret.AcrobaticDodgePercentChance = this.AcrobaticDodgePercentChance.Combine(rhs.AcrobaticDodgePercentChance);
                ret.RangeMultOptimal = this.RangeMultOptimal.Combine(rhs.RangeMultOptimal);
                ret.RangeMultMax = this.RangeMultMax.Combine(rhs.RangeMultMax);
                ret.SwitchDistanceMelee = this.SwitchDistanceMelee.Combine(rhs.SwitchDistanceMelee);
                ret.SwitchDistanceRanged = this.SwitchDistanceRanged.Combine(rhs.SwitchDistanceRanged);
                ret.BuffStandoffDistance = this.BuffStandoffDistance.Combine(rhs.BuffStandoffDistance);
                ret.RangedStandoffDistance = this.RangedStandoffDistance.Combine(rhs.RangedStandoffDistance);
                ret.GroupStandoffDistance = this.GroupStandoffDistance.Combine(rhs.GroupStandoffDistance);
                ret.RushingAttackPercentChance = this.RushingAttackPercentChance.Combine(rhs.RushingAttackPercentChance);
                ret.RushingAttackDistanceMult = this.RushingAttackDistanceMult.Combine(rhs.RushingAttackDistanceMult);
                return ret;
            }
            public static ErrorMask? Combine(ErrorMask? lhs, ErrorMask? rhs)
            {
                if (lhs != null && rhs != null) return lhs.Combine(rhs);
                return lhs ?? rhs;
            }
            #endregion

            #region Factory
            public static ErrorMask Factory(ErrorMaskBuilder errorMask)
            {
                return new ErrorMask();
            }
            #endregion

        }
        public class TranslationMask : ITranslationMask
        {
            #region Members
            private TranslationCrystal? _crystal;
            public bool Versioning;
            public bool DodgePercentChance;
            public bool LeftRightPercentChance;
            public bool DodgeLeftRightTimerMin;
            public bool DodgeLeftRightTimerMax;
            public bool DodgeForwardTimerMin;
            public bool DodgeForwardTimerMax;
            public bool DodgeBackTimerMin;
            public bool DodgeBackTimerMax;
            public bool IdleTimerMin;
            public bool IdleTimerMax;
            public bool BlockPercentChance;
            public bool AttackPercentChance;
            public bool RecoilStaggerBonusToAttack;
            public bool UnconsciousBonusToAttack;
            public bool HandToHandBonusToAttack;
            public bool PowerAttackPercentChance;
            public bool RecoilStaggerBonusToPowerAttack;
            public bool UnconsciousBonusToPowerAttack;
            public bool PowerAttackNormal;
            public bool PowerAttackForward;
            public bool PowerAttackBack;
            public bool PowerAttackLeft;
            public bool PowerAttackRight;
            public bool HoldTimerMin;
            public bool HoldTimerMax;
            public bool Flags;
            public bool AcrobaticDodgePercentChance;
            public bool RangeMultOptimal;
            public bool RangeMultMax;
            public bool SwitchDistanceMelee;
            public bool SwitchDistanceRanged;
            public bool BuffStandoffDistance;
            public bool RangedStandoffDistance;
            public bool GroupStandoffDistance;
            public bool RushingAttackPercentChance;
            public bool RushingAttackDistanceMult;
            #endregion

            #region Ctors
            public TranslationMask(bool defaultOn)
            {
                this.Versioning = defaultOn;
                this.DodgePercentChance = defaultOn;
                this.LeftRightPercentChance = defaultOn;
                this.DodgeLeftRightTimerMin = defaultOn;
                this.DodgeLeftRightTimerMax = defaultOn;
                this.DodgeForwardTimerMin = defaultOn;
                this.DodgeForwardTimerMax = defaultOn;
                this.DodgeBackTimerMin = defaultOn;
                this.DodgeBackTimerMax = defaultOn;
                this.IdleTimerMin = defaultOn;
                this.IdleTimerMax = defaultOn;
                this.BlockPercentChance = defaultOn;
                this.AttackPercentChance = defaultOn;
                this.RecoilStaggerBonusToAttack = defaultOn;
                this.UnconsciousBonusToAttack = defaultOn;
                this.HandToHandBonusToAttack = defaultOn;
                this.PowerAttackPercentChance = defaultOn;
                this.RecoilStaggerBonusToPowerAttack = defaultOn;
                this.UnconsciousBonusToPowerAttack = defaultOn;
                this.PowerAttackNormal = defaultOn;
                this.PowerAttackForward = defaultOn;
                this.PowerAttackBack = defaultOn;
                this.PowerAttackLeft = defaultOn;
                this.PowerAttackRight = defaultOn;
                this.HoldTimerMin = defaultOn;
                this.HoldTimerMax = defaultOn;
                this.Flags = defaultOn;
                this.AcrobaticDodgePercentChance = defaultOn;
                this.RangeMultOptimal = defaultOn;
                this.RangeMultMax = defaultOn;
                this.SwitchDistanceMelee = defaultOn;
                this.SwitchDistanceRanged = defaultOn;
                this.BuffStandoffDistance = defaultOn;
                this.RangedStandoffDistance = defaultOn;
                this.GroupStandoffDistance = defaultOn;
                this.RushingAttackPercentChance = defaultOn;
                this.RushingAttackDistanceMult = defaultOn;
            }

            #endregion

            public TranslationCrystal GetCrystal()
            {
                if (_crystal != null) return _crystal;
                var ret = new List<(bool On, TranslationCrystal? SubCrystal)>();
                GetCrystal(ret);
                _crystal = new TranslationCrystal(ret.ToArray());
                return _crystal;
            }

            protected void GetCrystal(List<(bool On, TranslationCrystal? SubCrystal)> ret)
            {
                ret.Add((Versioning, null));
                ret.Add((DodgePercentChance, null));
                ret.Add((LeftRightPercentChance, null));
                ret.Add((DodgeLeftRightTimerMin, null));
                ret.Add((DodgeLeftRightTimerMax, null));
                ret.Add((DodgeForwardTimerMin, null));
                ret.Add((DodgeForwardTimerMax, null));
                ret.Add((DodgeBackTimerMin, null));
                ret.Add((DodgeBackTimerMax, null));
                ret.Add((IdleTimerMin, null));
                ret.Add((IdleTimerMax, null));
                ret.Add((BlockPercentChance, null));
                ret.Add((AttackPercentChance, null));
                ret.Add((RecoilStaggerBonusToAttack, null));
                ret.Add((UnconsciousBonusToAttack, null));
                ret.Add((HandToHandBonusToAttack, null));
                ret.Add((PowerAttackPercentChance, null));
                ret.Add((RecoilStaggerBonusToPowerAttack, null));
                ret.Add((UnconsciousBonusToPowerAttack, null));
                ret.Add((PowerAttackNormal, null));
                ret.Add((PowerAttackForward, null));
                ret.Add((PowerAttackBack, null));
                ret.Add((PowerAttackLeft, null));
                ret.Add((PowerAttackRight, null));
                ret.Add((HoldTimerMin, null));
                ret.Add((HoldTimerMax, null));
                ret.Add((Flags, null));
                ret.Add((AcrobaticDodgePercentChance, null));
                ret.Add((RangeMultOptimal, null));
                ret.Add((RangeMultMax, null));
                ret.Add((SwitchDistanceMelee, null));
                ret.Add((SwitchDistanceRanged, null));
                ret.Add((BuffStandoffDistance, null));
                ret.Add((RangedStandoffDistance, null));
                ret.Add((GroupStandoffDistance, null));
                ret.Add((RushingAttackPercentChance, null));
                ret.Add((RushingAttackDistanceMult, null));
            }
        }
        #endregion

        #region Mutagen
        public new static readonly RecordType GrupRecordType = CombatStyleData_Registration.TriggeringRecordType;
        [Flags]
        public enum VersioningBreaks
        {
            Break0 = 1,
            Break1 = 2,
            Break2 = 4,
            Break3 = 8,
            Break4 = 16
        }
        #endregion

        #region Binary Translation
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected object BinaryWriteTranslator => CombatStyleDataBinaryWriteTranslation.Instance;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        object IBinaryItem.BinaryWriteTranslator => this.BinaryWriteTranslator;
        void IBinaryItem.WriteToBinary(
            MutagenWriter writer,
            RecordTypeConverter? recordTypeConverter = null)
        {
            ((CombatStyleDataBinaryWriteTranslation)this.BinaryWriteTranslator).Write(
                item: this,
                writer: writer,
                recordTypeConverter: recordTypeConverter);
        }
        #region Binary Create
        [DebuggerStepThrough]
        public static CombatStyleData CreateFromBinary(MutagenFrame frame)
        {
            return CreateFromBinary(
                frame: frame,
                recordTypeConverter: null);
        }

        public static CombatStyleData CreateFromBinary(
            MutagenFrame frame,
            RecordTypeConverter? recordTypeConverter = null)
        {
            var ret = new CombatStyleData();
            ((CombatStyleDataSetterCommon)((ICombatStyleDataGetter)ret).CommonSetterInstance()!).CopyInFromBinary(
                item: ret,
                frame: frame,
                recordTypeConverter: recordTypeConverter);
            return ret;
        }

        #endregion

        #endregion

        void IPrintable.ToString(FileGeneration fg, string? name) => this.ToString(fg, name);
        IMask<bool> ILoquiObjectGetter.GetHasBeenSetIMask() => this.GetHasBeenSetMask();
        IMask<bool> IEqualsMask.GetEqualsIMask(object rhs, EqualsMaskHelper.Include include) => this.GetEqualsMask((ICombatStyleDataGetter)rhs, include);

        void IClearable.Clear()
        {
            ((CombatStyleDataSetterCommon)((ICombatStyleDataGetter)this).CommonSetterInstance()!).Clear(this);
        }

        internal static CombatStyleData GetNew()
        {
            return new CombatStyleData();
        }

    }
    #endregion

    #region Interface
    public partial interface ICombatStyleData :
        ICombatStyleDataGetter,
        ILoquiObjectSetter<ICombatStyleData>
    {
        new CombatStyleData.VersioningBreaks Versioning { get; set; }
        new Byte DodgePercentChance { get; set; }
        new Byte LeftRightPercentChance { get; set; }
        new Single DodgeLeftRightTimerMin { get; set; }
        new Single DodgeLeftRightTimerMax { get; set; }
        new Single DodgeForwardTimerMin { get; set; }
        new Single DodgeForwardTimerMax { get; set; }
        new Single DodgeBackTimerMin { get; set; }
        new Single DodgeBackTimerMax { get; set; }
        new Single IdleTimerMin { get; set; }
        new Single IdleTimerMax { get; set; }
        new Byte BlockPercentChance { get; set; }
        new Byte AttackPercentChance { get; set; }
        new Single RecoilStaggerBonusToAttack { get; set; }
        new Single UnconsciousBonusToAttack { get; set; }
        new Single HandToHandBonusToAttack { get; set; }
        new Byte PowerAttackPercentChance { get; set; }
        new Single RecoilStaggerBonusToPowerAttack { get; set; }
        new Single UnconsciousBonusToPowerAttack { get; set; }
        new Byte PowerAttackNormal { get; set; }
        new Byte PowerAttackForward { get; set; }
        new Byte PowerAttackBack { get; set; }
        new Byte PowerAttackLeft { get; set; }
        new Byte PowerAttackRight { get; set; }
        new Single HoldTimerMin { get; set; }
        new Single HoldTimerMax { get; set; }
        new CombatStyle.Flag Flags { get; set; }
        new Byte AcrobaticDodgePercentChance { get; set; }
        new Single RangeMultOptimal { get; set; }
        new Single RangeMultMax { get; set; }
        new Single SwitchDistanceMelee { get; set; }
        new Single SwitchDistanceRanged { get; set; }
        new Single BuffStandoffDistance { get; set; }
        new Single RangedStandoffDistance { get; set; }
        new Single GroupStandoffDistance { get; set; }
        new Byte RushingAttackPercentChance { get; set; }
        new Single RushingAttackDistanceMult { get; set; }
    }

    public partial interface ICombatStyleDataGetter :
        ILoquiObject,
        ILoquiObject<ICombatStyleDataGetter>,
        IXmlItem,
        IBinaryItem
    {
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        object CommonInstance();
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        object? CommonSetterInstance();
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        object CommonSetterTranslationInstance();
        static ILoquiRegistration Registration => CombatStyleData_Registration.Instance;
        CombatStyleData.VersioningBreaks Versioning { get; }
        Byte DodgePercentChance { get; }
        Byte LeftRightPercentChance { get; }
        Single DodgeLeftRightTimerMin { get; }
        Single DodgeLeftRightTimerMax { get; }
        Single DodgeForwardTimerMin { get; }
        Single DodgeForwardTimerMax { get; }
        Single DodgeBackTimerMin { get; }
        Single DodgeBackTimerMax { get; }
        Single IdleTimerMin { get; }
        Single IdleTimerMax { get; }
        Byte BlockPercentChance { get; }
        Byte AttackPercentChance { get; }
        Single RecoilStaggerBonusToAttack { get; }
        Single UnconsciousBonusToAttack { get; }
        Single HandToHandBonusToAttack { get; }
        Byte PowerAttackPercentChance { get; }
        Single RecoilStaggerBonusToPowerAttack { get; }
        Single UnconsciousBonusToPowerAttack { get; }
        Byte PowerAttackNormal { get; }
        Byte PowerAttackForward { get; }
        Byte PowerAttackBack { get; }
        Byte PowerAttackLeft { get; }
        Byte PowerAttackRight { get; }
        Single HoldTimerMin { get; }
        Single HoldTimerMax { get; }
        CombatStyle.Flag Flags { get; }
        Byte AcrobaticDodgePercentChance { get; }
        Single RangeMultOptimal { get; }
        Single RangeMultMax { get; }
        Single SwitchDistanceMelee { get; }
        Single SwitchDistanceRanged { get; }
        Single BuffStandoffDistance { get; }
        Single RangedStandoffDistance { get; }
        Single GroupStandoffDistance { get; }
        Byte RushingAttackPercentChance { get; }
        Single RushingAttackDistanceMult { get; }

    }

    #endregion

    #region Common MixIn
    public static partial class CombatStyleDataMixIn
    {
        public static void Clear(this ICombatStyleData item)
        {
            ((CombatStyleDataSetterCommon)((ICombatStyleDataGetter)item).CommonSetterInstance()!).Clear(item: item);
        }

        public static CombatStyleData.Mask<bool> GetEqualsMask(
            this ICombatStyleDataGetter item,
            ICombatStyleDataGetter rhs,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            return ((CombatStyleDataCommon)((ICombatStyleDataGetter)item).CommonInstance()!).GetEqualsMask(
                item: item,
                rhs: rhs,
                include: include);
        }

        public static string ToString(
            this ICombatStyleDataGetter item,
            string? name = null,
            CombatStyleData.Mask<bool>? printMask = null)
        {
            return ((CombatStyleDataCommon)((ICombatStyleDataGetter)item).CommonInstance()!).ToString(
                item: item,
                name: name,
                printMask: printMask);
        }

        public static void ToString(
            this ICombatStyleDataGetter item,
            FileGeneration fg,
            string? name = null,
            CombatStyleData.Mask<bool>? printMask = null)
        {
            ((CombatStyleDataCommon)((ICombatStyleDataGetter)item).CommonInstance()!).ToString(
                item: item,
                fg: fg,
                name: name,
                printMask: printMask);
        }

        public static bool HasBeenSet(
            this ICombatStyleDataGetter item,
            CombatStyleData.Mask<bool?> checkMask)
        {
            return ((CombatStyleDataCommon)((ICombatStyleDataGetter)item).CommonInstance()!).HasBeenSet(
                item: item,
                checkMask: checkMask);
        }

        public static CombatStyleData.Mask<bool> GetHasBeenSetMask(this ICombatStyleDataGetter item)
        {
            var ret = new CombatStyleData.Mask<bool>(false);
            ((CombatStyleDataCommon)((ICombatStyleDataGetter)item).CommonInstance()!).FillHasBeenSetMask(
                item: item,
                mask: ret);
            return ret;
        }

        public static bool Equals(
            this ICombatStyleDataGetter item,
            ICombatStyleDataGetter rhs)
        {
            return ((CombatStyleDataCommon)((ICombatStyleDataGetter)item).CommonInstance()!).Equals(
                lhs: item,
                rhs: rhs);
        }

        public static void DeepCopyIn(
            this ICombatStyleData lhs,
            ICombatStyleDataGetter rhs)
        {
            ((CombatStyleDataSetterTranslationCommon)((ICombatStyleDataGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: default,
                copyMask: default);
        }

        public static void DeepCopyIn(
            this ICombatStyleData lhs,
            ICombatStyleDataGetter rhs,
            CombatStyleData.TranslationMask? copyMask = null)
        {
            ((CombatStyleDataSetterTranslationCommon)((ICombatStyleDataGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: default,
                copyMask: copyMask?.GetCrystal());
        }

        public static void DeepCopyIn(
            this ICombatStyleData lhs,
            ICombatStyleDataGetter rhs,
            out CombatStyleData.ErrorMask errorMask,
            CombatStyleData.TranslationMask? copyMask = null)
        {
            var errorMaskBuilder = new ErrorMaskBuilder();
            ((CombatStyleDataSetterTranslationCommon)((ICombatStyleDataGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: errorMaskBuilder,
                copyMask: copyMask?.GetCrystal());
            errorMask = CombatStyleData.ErrorMask.Factory(errorMaskBuilder);
        }

        public static void DeepCopyIn(
            this ICombatStyleData lhs,
            ICombatStyleDataGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask)
        {
            ((CombatStyleDataSetterTranslationCommon)((ICombatStyleDataGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: errorMask,
                copyMask: copyMask);
        }

        public static CombatStyleData DeepCopy(
            this ICombatStyleDataGetter item,
            CombatStyleData.TranslationMask? copyMask = null)
        {
            return ((CombatStyleDataSetterTranslationCommon)((ICombatStyleDataGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask);
        }

        public static CombatStyleData DeepCopy(
            this ICombatStyleDataGetter item,
            out CombatStyleData.ErrorMask errorMask,
            CombatStyleData.TranslationMask? copyMask = null)
        {
            return ((CombatStyleDataSetterTranslationCommon)((ICombatStyleDataGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask,
                errorMask: out errorMask);
        }

        public static CombatStyleData DeepCopy(
            this ICombatStyleDataGetter item,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask = null)
        {
            return ((CombatStyleDataSetterTranslationCommon)((ICombatStyleDataGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask,
                errorMask: errorMask);
        }

        #region Xml Translation
        [DebuggerStepThrough]
        public static void CopyInFromXml(
            this ICombatStyleData item,
            XElement node,
            CombatStyleData.TranslationMask? translationMask = null)
        {
            CopyInFromXml(
                item: item,
                node: node,
                errorMask: null,
                translationMask: translationMask?.GetCrystal());
        }

        [DebuggerStepThrough]
        public static void CopyInFromXml(
            this ICombatStyleData item,
            XElement node,
            out CombatStyleData.ErrorMask errorMask,
            CombatStyleData.TranslationMask? translationMask = null)
        {
            ErrorMaskBuilder errorMaskBuilder = new ErrorMaskBuilder();
            CopyInFromXml(
                item: item,
                node: node,
                errorMask: errorMaskBuilder,
                translationMask: translationMask?.GetCrystal());
            errorMask = CombatStyleData.ErrorMask.Factory(errorMaskBuilder);
        }

        public static void CopyInFromXml(
            this ICombatStyleData item,
            XElement node,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask)
        {
            ((CombatStyleDataSetterCommon)((ICombatStyleDataGetter)item).CommonSetterInstance()!).CopyInFromXml(
                item: item,
                node: node,
                errorMask: errorMask,
                translationMask: translationMask);
        }

        public static void CopyInFromXml(
            this ICombatStyleData item,
            string path,
            CombatStyleData.TranslationMask? translationMask = null)
        {
            var node = XDocument.Load(path).Root;
            CopyInFromXml(
                item: item,
                node: node,
                translationMask: translationMask);
        }

        public static void CopyInFromXml(
            this ICombatStyleData item,
            string path,
            out CombatStyleData.ErrorMask errorMask,
            CombatStyleData.TranslationMask? translationMask = null)
        {
            var node = XDocument.Load(path).Root;
            CopyInFromXml(
                item: item,
                node: node,
                errorMask: out errorMask,
                translationMask: translationMask);
        }

        public static void CopyInFromXml(
            this ICombatStyleData item,
            string path,
            ErrorMaskBuilder? errorMask,
            CombatStyleData.TranslationMask? translationMask = null)
        {
            var node = XDocument.Load(path).Root;
            CopyInFromXml(
                item: item,
                node: node,
                errorMask: errorMask,
                translationMask: translationMask?.GetCrystal());
        }

        public static void CopyInFromXml(
            this ICombatStyleData item,
            Stream stream,
            CombatStyleData.TranslationMask? translationMask = null)
        {
            var node = XDocument.Load(stream).Root;
            CopyInFromXml(
                item: item,
                node: node,
                translationMask: translationMask);
        }

        public static void CopyInFromXml(
            this ICombatStyleData item,
            Stream stream,
            out CombatStyleData.ErrorMask errorMask,
            CombatStyleData.TranslationMask? translationMask = null)
        {
            var node = XDocument.Load(stream).Root;
            CopyInFromXml(
                item: item,
                node: node,
                errorMask: out errorMask,
                translationMask: translationMask);
        }

        public static void CopyInFromXml(
            this ICombatStyleData item,
            Stream stream,
            ErrorMaskBuilder? errorMask,
            CombatStyleData.TranslationMask? translationMask = null)
        {
            var node = XDocument.Load(stream).Root;
            CopyInFromXml(
                item: item,
                node: node,
                errorMask: errorMask,
                translationMask: translationMask?.GetCrystal());
        }

        #endregion

        #region Binary Translation
        [DebuggerStepThrough]
        public static void CopyInFromBinary(
            this ICombatStyleData item,
            MutagenFrame frame)
        {
            CopyInFromBinary(
                item: item,
                frame: frame,
                recordTypeConverter: null);
        }

        public static void CopyInFromBinary(
            this ICombatStyleData item,
            MutagenFrame frame,
            RecordTypeConverter? recordTypeConverter = null)
        {
            ((CombatStyleDataSetterCommon)((ICombatStyleDataGetter)item).CommonSetterInstance()!).CopyInFromBinary(
                item: item,
                frame: frame,
                recordTypeConverter: recordTypeConverter);
        }

        #endregion

    }
    #endregion

}

namespace Mutagen.Bethesda.Oblivion.Internals
{
    #region Field Index
    public enum CombatStyleData_FieldIndex
    {
        Versioning = 0,
        DodgePercentChance = 1,
        LeftRightPercentChance = 2,
        DodgeLeftRightTimerMin = 3,
        DodgeLeftRightTimerMax = 4,
        DodgeForwardTimerMin = 5,
        DodgeForwardTimerMax = 6,
        DodgeBackTimerMin = 7,
        DodgeBackTimerMax = 8,
        IdleTimerMin = 9,
        IdleTimerMax = 10,
        BlockPercentChance = 11,
        AttackPercentChance = 12,
        RecoilStaggerBonusToAttack = 13,
        UnconsciousBonusToAttack = 14,
        HandToHandBonusToAttack = 15,
        PowerAttackPercentChance = 16,
        RecoilStaggerBonusToPowerAttack = 17,
        UnconsciousBonusToPowerAttack = 18,
        PowerAttackNormal = 19,
        PowerAttackForward = 20,
        PowerAttackBack = 21,
        PowerAttackLeft = 22,
        PowerAttackRight = 23,
        HoldTimerMin = 24,
        HoldTimerMax = 25,
        Flags = 26,
        AcrobaticDodgePercentChance = 27,
        RangeMultOptimal = 28,
        RangeMultMax = 29,
        SwitchDistanceMelee = 30,
        SwitchDistanceRanged = 31,
        BuffStandoffDistance = 32,
        RangedStandoffDistance = 33,
        GroupStandoffDistance = 34,
        RushingAttackPercentChance = 35,
        RushingAttackDistanceMult = 36,
    }
    #endregion

    #region Registration
    public partial class CombatStyleData_Registration : ILoquiRegistration
    {
        public static readonly CombatStyleData_Registration Instance = new CombatStyleData_Registration();

        public static ProtocolKey ProtocolKey => ProtocolDefinition_Oblivion.ProtocolKey;

        public static readonly ObjectKey ObjectKey = new ObjectKey(
            protocolKey: ProtocolDefinition_Oblivion.ProtocolKey,
            msgID: 181,
            version: 0);

        public const string GUID = "e011eee4-3551-4cd2-82ef-34a1038a1fc2";

        public const ushort AdditionalFieldCount = 37;

        public const ushort FieldCount = 37;

        public static readonly Type MaskType = typeof(CombatStyleData.Mask<>);

        public static readonly Type ErrorMaskType = typeof(CombatStyleData.ErrorMask);

        public static readonly Type ClassType = typeof(CombatStyleData);

        public static readonly Type GetterType = typeof(ICombatStyleDataGetter);

        public static readonly Type? InternalGetterType = null;

        public static readonly Type SetterType = typeof(ICombatStyleData);

        public static readonly Type? InternalSetterType = null;

        public const string FullName = "Mutagen.Bethesda.Oblivion.CombatStyleData";

        public const string Name = "CombatStyleData";

        public const string Namespace = "Mutagen.Bethesda.Oblivion";

        public const byte GenericCount = 0;

        public static readonly Type? GenericRegistrationType = null;

        public static ushort? GetNameIndex(StringCaseAgnostic str)
        {
            switch (str.Upper)
            {
                case "VERSIONING":
                    return (ushort)CombatStyleData_FieldIndex.Versioning;
                case "DODGEPERCENTCHANCE":
                    return (ushort)CombatStyleData_FieldIndex.DodgePercentChance;
                case "LEFTRIGHTPERCENTCHANCE":
                    return (ushort)CombatStyleData_FieldIndex.LeftRightPercentChance;
                case "DODGELEFTRIGHTTIMERMIN":
                    return (ushort)CombatStyleData_FieldIndex.DodgeLeftRightTimerMin;
                case "DODGELEFTRIGHTTIMERMAX":
                    return (ushort)CombatStyleData_FieldIndex.DodgeLeftRightTimerMax;
                case "DODGEFORWARDTIMERMIN":
                    return (ushort)CombatStyleData_FieldIndex.DodgeForwardTimerMin;
                case "DODGEFORWARDTIMERMAX":
                    return (ushort)CombatStyleData_FieldIndex.DodgeForwardTimerMax;
                case "DODGEBACKTIMERMIN":
                    return (ushort)CombatStyleData_FieldIndex.DodgeBackTimerMin;
                case "DODGEBACKTIMERMAX":
                    return (ushort)CombatStyleData_FieldIndex.DodgeBackTimerMax;
                case "IDLETIMERMIN":
                    return (ushort)CombatStyleData_FieldIndex.IdleTimerMin;
                case "IDLETIMERMAX":
                    return (ushort)CombatStyleData_FieldIndex.IdleTimerMax;
                case "BLOCKPERCENTCHANCE":
                    return (ushort)CombatStyleData_FieldIndex.BlockPercentChance;
                case "ATTACKPERCENTCHANCE":
                    return (ushort)CombatStyleData_FieldIndex.AttackPercentChance;
                case "RECOILSTAGGERBONUSTOATTACK":
                    return (ushort)CombatStyleData_FieldIndex.RecoilStaggerBonusToAttack;
                case "UNCONSCIOUSBONUSTOATTACK":
                    return (ushort)CombatStyleData_FieldIndex.UnconsciousBonusToAttack;
                case "HANDTOHANDBONUSTOATTACK":
                    return (ushort)CombatStyleData_FieldIndex.HandToHandBonusToAttack;
                case "POWERATTACKPERCENTCHANCE":
                    return (ushort)CombatStyleData_FieldIndex.PowerAttackPercentChance;
                case "RECOILSTAGGERBONUSTOPOWERATTACK":
                    return (ushort)CombatStyleData_FieldIndex.RecoilStaggerBonusToPowerAttack;
                case "UNCONSCIOUSBONUSTOPOWERATTACK":
                    return (ushort)CombatStyleData_FieldIndex.UnconsciousBonusToPowerAttack;
                case "POWERATTACKNORMAL":
                    return (ushort)CombatStyleData_FieldIndex.PowerAttackNormal;
                case "POWERATTACKFORWARD":
                    return (ushort)CombatStyleData_FieldIndex.PowerAttackForward;
                case "POWERATTACKBACK":
                    return (ushort)CombatStyleData_FieldIndex.PowerAttackBack;
                case "POWERATTACKLEFT":
                    return (ushort)CombatStyleData_FieldIndex.PowerAttackLeft;
                case "POWERATTACKRIGHT":
                    return (ushort)CombatStyleData_FieldIndex.PowerAttackRight;
                case "HOLDTIMERMIN":
                    return (ushort)CombatStyleData_FieldIndex.HoldTimerMin;
                case "HOLDTIMERMAX":
                    return (ushort)CombatStyleData_FieldIndex.HoldTimerMax;
                case "FLAGS":
                    return (ushort)CombatStyleData_FieldIndex.Flags;
                case "ACROBATICDODGEPERCENTCHANCE":
                    return (ushort)CombatStyleData_FieldIndex.AcrobaticDodgePercentChance;
                case "RANGEMULTOPTIMAL":
                    return (ushort)CombatStyleData_FieldIndex.RangeMultOptimal;
                case "RANGEMULTMAX":
                    return (ushort)CombatStyleData_FieldIndex.RangeMultMax;
                case "SWITCHDISTANCEMELEE":
                    return (ushort)CombatStyleData_FieldIndex.SwitchDistanceMelee;
                case "SWITCHDISTANCERANGED":
                    return (ushort)CombatStyleData_FieldIndex.SwitchDistanceRanged;
                case "BUFFSTANDOFFDISTANCE":
                    return (ushort)CombatStyleData_FieldIndex.BuffStandoffDistance;
                case "RANGEDSTANDOFFDISTANCE":
                    return (ushort)CombatStyleData_FieldIndex.RangedStandoffDistance;
                case "GROUPSTANDOFFDISTANCE":
                    return (ushort)CombatStyleData_FieldIndex.GroupStandoffDistance;
                case "RUSHINGATTACKPERCENTCHANCE":
                    return (ushort)CombatStyleData_FieldIndex.RushingAttackPercentChance;
                case "RUSHINGATTACKDISTANCEMULT":
                    return (ushort)CombatStyleData_FieldIndex.RushingAttackDistanceMult;
                default:
                    return null;
            }
        }

        public static bool GetNthIsEnumerable(ushort index)
        {
            CombatStyleData_FieldIndex enu = (CombatStyleData_FieldIndex)index;
            switch (enu)
            {
                case CombatStyleData_FieldIndex.Versioning:
                case CombatStyleData_FieldIndex.DodgePercentChance:
                case CombatStyleData_FieldIndex.LeftRightPercentChance:
                case CombatStyleData_FieldIndex.DodgeLeftRightTimerMin:
                case CombatStyleData_FieldIndex.DodgeLeftRightTimerMax:
                case CombatStyleData_FieldIndex.DodgeForwardTimerMin:
                case CombatStyleData_FieldIndex.DodgeForwardTimerMax:
                case CombatStyleData_FieldIndex.DodgeBackTimerMin:
                case CombatStyleData_FieldIndex.DodgeBackTimerMax:
                case CombatStyleData_FieldIndex.IdleTimerMin:
                case CombatStyleData_FieldIndex.IdleTimerMax:
                case CombatStyleData_FieldIndex.BlockPercentChance:
                case CombatStyleData_FieldIndex.AttackPercentChance:
                case CombatStyleData_FieldIndex.RecoilStaggerBonusToAttack:
                case CombatStyleData_FieldIndex.UnconsciousBonusToAttack:
                case CombatStyleData_FieldIndex.HandToHandBonusToAttack:
                case CombatStyleData_FieldIndex.PowerAttackPercentChance:
                case CombatStyleData_FieldIndex.RecoilStaggerBonusToPowerAttack:
                case CombatStyleData_FieldIndex.UnconsciousBonusToPowerAttack:
                case CombatStyleData_FieldIndex.PowerAttackNormal:
                case CombatStyleData_FieldIndex.PowerAttackForward:
                case CombatStyleData_FieldIndex.PowerAttackBack:
                case CombatStyleData_FieldIndex.PowerAttackLeft:
                case CombatStyleData_FieldIndex.PowerAttackRight:
                case CombatStyleData_FieldIndex.HoldTimerMin:
                case CombatStyleData_FieldIndex.HoldTimerMax:
                case CombatStyleData_FieldIndex.Flags:
                case CombatStyleData_FieldIndex.AcrobaticDodgePercentChance:
                case CombatStyleData_FieldIndex.RangeMultOptimal:
                case CombatStyleData_FieldIndex.RangeMultMax:
                case CombatStyleData_FieldIndex.SwitchDistanceMelee:
                case CombatStyleData_FieldIndex.SwitchDistanceRanged:
                case CombatStyleData_FieldIndex.BuffStandoffDistance:
                case CombatStyleData_FieldIndex.RangedStandoffDistance:
                case CombatStyleData_FieldIndex.GroupStandoffDistance:
                case CombatStyleData_FieldIndex.RushingAttackPercentChance:
                case CombatStyleData_FieldIndex.RushingAttackDistanceMult:
                    return false;
                default:
                    throw new ArgumentException($"Index is out of range: {index}");
            }
        }

        public static bool GetNthIsLoqui(ushort index)
        {
            CombatStyleData_FieldIndex enu = (CombatStyleData_FieldIndex)index;
            switch (enu)
            {
                case CombatStyleData_FieldIndex.Versioning:
                case CombatStyleData_FieldIndex.DodgePercentChance:
                case CombatStyleData_FieldIndex.LeftRightPercentChance:
                case CombatStyleData_FieldIndex.DodgeLeftRightTimerMin:
                case CombatStyleData_FieldIndex.DodgeLeftRightTimerMax:
                case CombatStyleData_FieldIndex.DodgeForwardTimerMin:
                case CombatStyleData_FieldIndex.DodgeForwardTimerMax:
                case CombatStyleData_FieldIndex.DodgeBackTimerMin:
                case CombatStyleData_FieldIndex.DodgeBackTimerMax:
                case CombatStyleData_FieldIndex.IdleTimerMin:
                case CombatStyleData_FieldIndex.IdleTimerMax:
                case CombatStyleData_FieldIndex.BlockPercentChance:
                case CombatStyleData_FieldIndex.AttackPercentChance:
                case CombatStyleData_FieldIndex.RecoilStaggerBonusToAttack:
                case CombatStyleData_FieldIndex.UnconsciousBonusToAttack:
                case CombatStyleData_FieldIndex.HandToHandBonusToAttack:
                case CombatStyleData_FieldIndex.PowerAttackPercentChance:
                case CombatStyleData_FieldIndex.RecoilStaggerBonusToPowerAttack:
                case CombatStyleData_FieldIndex.UnconsciousBonusToPowerAttack:
                case CombatStyleData_FieldIndex.PowerAttackNormal:
                case CombatStyleData_FieldIndex.PowerAttackForward:
                case CombatStyleData_FieldIndex.PowerAttackBack:
                case CombatStyleData_FieldIndex.PowerAttackLeft:
                case CombatStyleData_FieldIndex.PowerAttackRight:
                case CombatStyleData_FieldIndex.HoldTimerMin:
                case CombatStyleData_FieldIndex.HoldTimerMax:
                case CombatStyleData_FieldIndex.Flags:
                case CombatStyleData_FieldIndex.AcrobaticDodgePercentChance:
                case CombatStyleData_FieldIndex.RangeMultOptimal:
                case CombatStyleData_FieldIndex.RangeMultMax:
                case CombatStyleData_FieldIndex.SwitchDistanceMelee:
                case CombatStyleData_FieldIndex.SwitchDistanceRanged:
                case CombatStyleData_FieldIndex.BuffStandoffDistance:
                case CombatStyleData_FieldIndex.RangedStandoffDistance:
                case CombatStyleData_FieldIndex.GroupStandoffDistance:
                case CombatStyleData_FieldIndex.RushingAttackPercentChance:
                case CombatStyleData_FieldIndex.RushingAttackDistanceMult:
                    return false;
                default:
                    throw new ArgumentException($"Index is out of range: {index}");
            }
        }

        public static bool GetNthIsSingleton(ushort index)
        {
            CombatStyleData_FieldIndex enu = (CombatStyleData_FieldIndex)index;
            switch (enu)
            {
                case CombatStyleData_FieldIndex.Versioning:
                case CombatStyleData_FieldIndex.DodgePercentChance:
                case CombatStyleData_FieldIndex.LeftRightPercentChance:
                case CombatStyleData_FieldIndex.DodgeLeftRightTimerMin:
                case CombatStyleData_FieldIndex.DodgeLeftRightTimerMax:
                case CombatStyleData_FieldIndex.DodgeForwardTimerMin:
                case CombatStyleData_FieldIndex.DodgeForwardTimerMax:
                case CombatStyleData_FieldIndex.DodgeBackTimerMin:
                case CombatStyleData_FieldIndex.DodgeBackTimerMax:
                case CombatStyleData_FieldIndex.IdleTimerMin:
                case CombatStyleData_FieldIndex.IdleTimerMax:
                case CombatStyleData_FieldIndex.BlockPercentChance:
                case CombatStyleData_FieldIndex.AttackPercentChance:
                case CombatStyleData_FieldIndex.RecoilStaggerBonusToAttack:
                case CombatStyleData_FieldIndex.UnconsciousBonusToAttack:
                case CombatStyleData_FieldIndex.HandToHandBonusToAttack:
                case CombatStyleData_FieldIndex.PowerAttackPercentChance:
                case CombatStyleData_FieldIndex.RecoilStaggerBonusToPowerAttack:
                case CombatStyleData_FieldIndex.UnconsciousBonusToPowerAttack:
                case CombatStyleData_FieldIndex.PowerAttackNormal:
                case CombatStyleData_FieldIndex.PowerAttackForward:
                case CombatStyleData_FieldIndex.PowerAttackBack:
                case CombatStyleData_FieldIndex.PowerAttackLeft:
                case CombatStyleData_FieldIndex.PowerAttackRight:
                case CombatStyleData_FieldIndex.HoldTimerMin:
                case CombatStyleData_FieldIndex.HoldTimerMax:
                case CombatStyleData_FieldIndex.Flags:
                case CombatStyleData_FieldIndex.AcrobaticDodgePercentChance:
                case CombatStyleData_FieldIndex.RangeMultOptimal:
                case CombatStyleData_FieldIndex.RangeMultMax:
                case CombatStyleData_FieldIndex.SwitchDistanceMelee:
                case CombatStyleData_FieldIndex.SwitchDistanceRanged:
                case CombatStyleData_FieldIndex.BuffStandoffDistance:
                case CombatStyleData_FieldIndex.RangedStandoffDistance:
                case CombatStyleData_FieldIndex.GroupStandoffDistance:
                case CombatStyleData_FieldIndex.RushingAttackPercentChance:
                case CombatStyleData_FieldIndex.RushingAttackDistanceMult:
                    return false;
                default:
                    throw new ArgumentException($"Index is out of range: {index}");
            }
        }

        public static string GetNthName(ushort index)
        {
            CombatStyleData_FieldIndex enu = (CombatStyleData_FieldIndex)index;
            switch (enu)
            {
                case CombatStyleData_FieldIndex.Versioning:
                    return "Versioning";
                case CombatStyleData_FieldIndex.DodgePercentChance:
                    return "DodgePercentChance";
                case CombatStyleData_FieldIndex.LeftRightPercentChance:
                    return "LeftRightPercentChance";
                case CombatStyleData_FieldIndex.DodgeLeftRightTimerMin:
                    return "DodgeLeftRightTimerMin";
                case CombatStyleData_FieldIndex.DodgeLeftRightTimerMax:
                    return "DodgeLeftRightTimerMax";
                case CombatStyleData_FieldIndex.DodgeForwardTimerMin:
                    return "DodgeForwardTimerMin";
                case CombatStyleData_FieldIndex.DodgeForwardTimerMax:
                    return "DodgeForwardTimerMax";
                case CombatStyleData_FieldIndex.DodgeBackTimerMin:
                    return "DodgeBackTimerMin";
                case CombatStyleData_FieldIndex.DodgeBackTimerMax:
                    return "DodgeBackTimerMax";
                case CombatStyleData_FieldIndex.IdleTimerMin:
                    return "IdleTimerMin";
                case CombatStyleData_FieldIndex.IdleTimerMax:
                    return "IdleTimerMax";
                case CombatStyleData_FieldIndex.BlockPercentChance:
                    return "BlockPercentChance";
                case CombatStyleData_FieldIndex.AttackPercentChance:
                    return "AttackPercentChance";
                case CombatStyleData_FieldIndex.RecoilStaggerBonusToAttack:
                    return "RecoilStaggerBonusToAttack";
                case CombatStyleData_FieldIndex.UnconsciousBonusToAttack:
                    return "UnconsciousBonusToAttack";
                case CombatStyleData_FieldIndex.HandToHandBonusToAttack:
                    return "HandToHandBonusToAttack";
                case CombatStyleData_FieldIndex.PowerAttackPercentChance:
                    return "PowerAttackPercentChance";
                case CombatStyleData_FieldIndex.RecoilStaggerBonusToPowerAttack:
                    return "RecoilStaggerBonusToPowerAttack";
                case CombatStyleData_FieldIndex.UnconsciousBonusToPowerAttack:
                    return "UnconsciousBonusToPowerAttack";
                case CombatStyleData_FieldIndex.PowerAttackNormal:
                    return "PowerAttackNormal";
                case CombatStyleData_FieldIndex.PowerAttackForward:
                    return "PowerAttackForward";
                case CombatStyleData_FieldIndex.PowerAttackBack:
                    return "PowerAttackBack";
                case CombatStyleData_FieldIndex.PowerAttackLeft:
                    return "PowerAttackLeft";
                case CombatStyleData_FieldIndex.PowerAttackRight:
                    return "PowerAttackRight";
                case CombatStyleData_FieldIndex.HoldTimerMin:
                    return "HoldTimerMin";
                case CombatStyleData_FieldIndex.HoldTimerMax:
                    return "HoldTimerMax";
                case CombatStyleData_FieldIndex.Flags:
                    return "Flags";
                case CombatStyleData_FieldIndex.AcrobaticDodgePercentChance:
                    return "AcrobaticDodgePercentChance";
                case CombatStyleData_FieldIndex.RangeMultOptimal:
                    return "RangeMultOptimal";
                case CombatStyleData_FieldIndex.RangeMultMax:
                    return "RangeMultMax";
                case CombatStyleData_FieldIndex.SwitchDistanceMelee:
                    return "SwitchDistanceMelee";
                case CombatStyleData_FieldIndex.SwitchDistanceRanged:
                    return "SwitchDistanceRanged";
                case CombatStyleData_FieldIndex.BuffStandoffDistance:
                    return "BuffStandoffDistance";
                case CombatStyleData_FieldIndex.RangedStandoffDistance:
                    return "RangedStandoffDistance";
                case CombatStyleData_FieldIndex.GroupStandoffDistance:
                    return "GroupStandoffDistance";
                case CombatStyleData_FieldIndex.RushingAttackPercentChance:
                    return "RushingAttackPercentChance";
                case CombatStyleData_FieldIndex.RushingAttackDistanceMult:
                    return "RushingAttackDistanceMult";
                default:
                    throw new ArgumentException($"Index is out of range: {index}");
            }
        }

        public static bool IsNthDerivative(ushort index)
        {
            CombatStyleData_FieldIndex enu = (CombatStyleData_FieldIndex)index;
            switch (enu)
            {
                case CombatStyleData_FieldIndex.Versioning:
                case CombatStyleData_FieldIndex.DodgePercentChance:
                case CombatStyleData_FieldIndex.LeftRightPercentChance:
                case CombatStyleData_FieldIndex.DodgeLeftRightTimerMin:
                case CombatStyleData_FieldIndex.DodgeLeftRightTimerMax:
                case CombatStyleData_FieldIndex.DodgeForwardTimerMin:
                case CombatStyleData_FieldIndex.DodgeForwardTimerMax:
                case CombatStyleData_FieldIndex.DodgeBackTimerMin:
                case CombatStyleData_FieldIndex.DodgeBackTimerMax:
                case CombatStyleData_FieldIndex.IdleTimerMin:
                case CombatStyleData_FieldIndex.IdleTimerMax:
                case CombatStyleData_FieldIndex.BlockPercentChance:
                case CombatStyleData_FieldIndex.AttackPercentChance:
                case CombatStyleData_FieldIndex.RecoilStaggerBonusToAttack:
                case CombatStyleData_FieldIndex.UnconsciousBonusToAttack:
                case CombatStyleData_FieldIndex.HandToHandBonusToAttack:
                case CombatStyleData_FieldIndex.PowerAttackPercentChance:
                case CombatStyleData_FieldIndex.RecoilStaggerBonusToPowerAttack:
                case CombatStyleData_FieldIndex.UnconsciousBonusToPowerAttack:
                case CombatStyleData_FieldIndex.PowerAttackNormal:
                case CombatStyleData_FieldIndex.PowerAttackForward:
                case CombatStyleData_FieldIndex.PowerAttackBack:
                case CombatStyleData_FieldIndex.PowerAttackLeft:
                case CombatStyleData_FieldIndex.PowerAttackRight:
                case CombatStyleData_FieldIndex.HoldTimerMin:
                case CombatStyleData_FieldIndex.HoldTimerMax:
                case CombatStyleData_FieldIndex.Flags:
                case CombatStyleData_FieldIndex.AcrobaticDodgePercentChance:
                case CombatStyleData_FieldIndex.RangeMultOptimal:
                case CombatStyleData_FieldIndex.RangeMultMax:
                case CombatStyleData_FieldIndex.SwitchDistanceMelee:
                case CombatStyleData_FieldIndex.SwitchDistanceRanged:
                case CombatStyleData_FieldIndex.BuffStandoffDistance:
                case CombatStyleData_FieldIndex.RangedStandoffDistance:
                case CombatStyleData_FieldIndex.GroupStandoffDistance:
                case CombatStyleData_FieldIndex.RushingAttackPercentChance:
                case CombatStyleData_FieldIndex.RushingAttackDistanceMult:
                    return false;
                default:
                    throw new ArgumentException($"Index is out of range: {index}");
            }
        }

        public static bool IsProtected(ushort index)
        {
            CombatStyleData_FieldIndex enu = (CombatStyleData_FieldIndex)index;
            switch (enu)
            {
                case CombatStyleData_FieldIndex.Versioning:
                case CombatStyleData_FieldIndex.DodgePercentChance:
                case CombatStyleData_FieldIndex.LeftRightPercentChance:
                case CombatStyleData_FieldIndex.DodgeLeftRightTimerMin:
                case CombatStyleData_FieldIndex.DodgeLeftRightTimerMax:
                case CombatStyleData_FieldIndex.DodgeForwardTimerMin:
                case CombatStyleData_FieldIndex.DodgeForwardTimerMax:
                case CombatStyleData_FieldIndex.DodgeBackTimerMin:
                case CombatStyleData_FieldIndex.DodgeBackTimerMax:
                case CombatStyleData_FieldIndex.IdleTimerMin:
                case CombatStyleData_FieldIndex.IdleTimerMax:
                case CombatStyleData_FieldIndex.BlockPercentChance:
                case CombatStyleData_FieldIndex.AttackPercentChance:
                case CombatStyleData_FieldIndex.RecoilStaggerBonusToAttack:
                case CombatStyleData_FieldIndex.UnconsciousBonusToAttack:
                case CombatStyleData_FieldIndex.HandToHandBonusToAttack:
                case CombatStyleData_FieldIndex.PowerAttackPercentChance:
                case CombatStyleData_FieldIndex.RecoilStaggerBonusToPowerAttack:
                case CombatStyleData_FieldIndex.UnconsciousBonusToPowerAttack:
                case CombatStyleData_FieldIndex.PowerAttackNormal:
                case CombatStyleData_FieldIndex.PowerAttackForward:
                case CombatStyleData_FieldIndex.PowerAttackBack:
                case CombatStyleData_FieldIndex.PowerAttackLeft:
                case CombatStyleData_FieldIndex.PowerAttackRight:
                case CombatStyleData_FieldIndex.HoldTimerMin:
                case CombatStyleData_FieldIndex.HoldTimerMax:
                case CombatStyleData_FieldIndex.Flags:
                case CombatStyleData_FieldIndex.AcrobaticDodgePercentChance:
                case CombatStyleData_FieldIndex.RangeMultOptimal:
                case CombatStyleData_FieldIndex.RangeMultMax:
                case CombatStyleData_FieldIndex.SwitchDistanceMelee:
                case CombatStyleData_FieldIndex.SwitchDistanceRanged:
                case CombatStyleData_FieldIndex.BuffStandoffDistance:
                case CombatStyleData_FieldIndex.RangedStandoffDistance:
                case CombatStyleData_FieldIndex.GroupStandoffDistance:
                case CombatStyleData_FieldIndex.RushingAttackPercentChance:
                case CombatStyleData_FieldIndex.RushingAttackDistanceMult:
                    return false;
                default:
                    throw new ArgumentException($"Index is out of range: {index}");
            }
        }

        public static Type GetNthType(ushort index)
        {
            CombatStyleData_FieldIndex enu = (CombatStyleData_FieldIndex)index;
            switch (enu)
            {
                case CombatStyleData_FieldIndex.Versioning:
                    return typeof(CombatStyleData.VersioningBreaks);
                case CombatStyleData_FieldIndex.DodgePercentChance:
                    return typeof(Byte);
                case CombatStyleData_FieldIndex.LeftRightPercentChance:
                    return typeof(Byte);
                case CombatStyleData_FieldIndex.DodgeLeftRightTimerMin:
                    return typeof(Single);
                case CombatStyleData_FieldIndex.DodgeLeftRightTimerMax:
                    return typeof(Single);
                case CombatStyleData_FieldIndex.DodgeForwardTimerMin:
                    return typeof(Single);
                case CombatStyleData_FieldIndex.DodgeForwardTimerMax:
                    return typeof(Single);
                case CombatStyleData_FieldIndex.DodgeBackTimerMin:
                    return typeof(Single);
                case CombatStyleData_FieldIndex.DodgeBackTimerMax:
                    return typeof(Single);
                case CombatStyleData_FieldIndex.IdleTimerMin:
                    return typeof(Single);
                case CombatStyleData_FieldIndex.IdleTimerMax:
                    return typeof(Single);
                case CombatStyleData_FieldIndex.BlockPercentChance:
                    return typeof(Byte);
                case CombatStyleData_FieldIndex.AttackPercentChance:
                    return typeof(Byte);
                case CombatStyleData_FieldIndex.RecoilStaggerBonusToAttack:
                    return typeof(Single);
                case CombatStyleData_FieldIndex.UnconsciousBonusToAttack:
                    return typeof(Single);
                case CombatStyleData_FieldIndex.HandToHandBonusToAttack:
                    return typeof(Single);
                case CombatStyleData_FieldIndex.PowerAttackPercentChance:
                    return typeof(Byte);
                case CombatStyleData_FieldIndex.RecoilStaggerBonusToPowerAttack:
                    return typeof(Single);
                case CombatStyleData_FieldIndex.UnconsciousBonusToPowerAttack:
                    return typeof(Single);
                case CombatStyleData_FieldIndex.PowerAttackNormal:
                    return typeof(Byte);
                case CombatStyleData_FieldIndex.PowerAttackForward:
                    return typeof(Byte);
                case CombatStyleData_FieldIndex.PowerAttackBack:
                    return typeof(Byte);
                case CombatStyleData_FieldIndex.PowerAttackLeft:
                    return typeof(Byte);
                case CombatStyleData_FieldIndex.PowerAttackRight:
                    return typeof(Byte);
                case CombatStyleData_FieldIndex.HoldTimerMin:
                    return typeof(Single);
                case CombatStyleData_FieldIndex.HoldTimerMax:
                    return typeof(Single);
                case CombatStyleData_FieldIndex.Flags:
                    return typeof(CombatStyle.Flag);
                case CombatStyleData_FieldIndex.AcrobaticDodgePercentChance:
                    return typeof(Byte);
                case CombatStyleData_FieldIndex.RangeMultOptimal:
                    return typeof(Single);
                case CombatStyleData_FieldIndex.RangeMultMax:
                    return typeof(Single);
                case CombatStyleData_FieldIndex.SwitchDistanceMelee:
                    return typeof(Single);
                case CombatStyleData_FieldIndex.SwitchDistanceRanged:
                    return typeof(Single);
                case CombatStyleData_FieldIndex.BuffStandoffDistance:
                    return typeof(Single);
                case CombatStyleData_FieldIndex.RangedStandoffDistance:
                    return typeof(Single);
                case CombatStyleData_FieldIndex.GroupStandoffDistance:
                    return typeof(Single);
                case CombatStyleData_FieldIndex.RushingAttackPercentChance:
                    return typeof(Byte);
                case CombatStyleData_FieldIndex.RushingAttackDistanceMult:
                    return typeof(Single);
                default:
                    throw new ArgumentException($"Index is out of range: {index}");
            }
        }

        public static readonly Type XmlWriteTranslation = typeof(CombatStyleDataXmlWriteTranslation);
        public static readonly RecordType CSTD_HEADER = new RecordType("CSTD");
        public static readonly RecordType TriggeringRecordType = CSTD_HEADER;
        public const int NumStructFields = 36;
        public const int NumTypedFields = 0;
        public static readonly Type BinaryWriteTranslation = typeof(CombatStyleDataBinaryWriteTranslation);
        #region Interface
        ProtocolKey ILoquiRegistration.ProtocolKey => ProtocolKey;
        ObjectKey ILoquiRegistration.ObjectKey => ObjectKey;
        string ILoquiRegistration.GUID => GUID;
        ushort ILoquiRegistration.FieldCount => FieldCount;
        ushort ILoquiRegistration.AdditionalFieldCount => AdditionalFieldCount;
        Type ILoquiRegistration.MaskType => MaskType;
        Type ILoquiRegistration.ErrorMaskType => ErrorMaskType;
        Type ILoquiRegistration.ClassType => ClassType;
        Type ILoquiRegistration.SetterType => SetterType;
        Type? ILoquiRegistration.InternalSetterType => InternalSetterType;
        Type ILoquiRegistration.GetterType => GetterType;
        Type? ILoquiRegistration.InternalGetterType => InternalGetterType;
        string ILoquiRegistration.FullName => FullName;
        string ILoquiRegistration.Name => Name;
        string ILoquiRegistration.Namespace => Namespace;
        byte ILoquiRegistration.GenericCount => GenericCount;
        Type? ILoquiRegistration.GenericRegistrationType => GenericRegistrationType;
        ushort? ILoquiRegistration.GetNameIndex(StringCaseAgnostic name) => GetNameIndex(name);
        bool ILoquiRegistration.GetNthIsEnumerable(ushort index) => GetNthIsEnumerable(index);
        bool ILoquiRegistration.GetNthIsLoqui(ushort index) => GetNthIsLoqui(index);
        bool ILoquiRegistration.GetNthIsSingleton(ushort index) => GetNthIsSingleton(index);
        string ILoquiRegistration.GetNthName(ushort index) => GetNthName(index);
        bool ILoquiRegistration.IsNthDerivative(ushort index) => IsNthDerivative(index);
        bool ILoquiRegistration.IsProtected(ushort index) => IsProtected(index);
        Type ILoquiRegistration.GetNthType(ushort index) => GetNthType(index);
        #endregion

    }
    #endregion

    #region Common
    public partial class CombatStyleDataSetterCommon
    {
        public static readonly CombatStyleDataSetterCommon Instance = new CombatStyleDataSetterCommon();

        partial void ClearPartial();
        
        public void Clear(ICombatStyleData item)
        {
            ClearPartial();
            item.Versioning = default;
            item.DodgePercentChance = default;
            item.LeftRightPercentChance = default;
            item.DodgeLeftRightTimerMin = default;
            item.DodgeLeftRightTimerMax = default;
            item.DodgeForwardTimerMin = default;
            item.DodgeForwardTimerMax = default;
            item.DodgeBackTimerMin = default;
            item.DodgeBackTimerMax = default;
            item.IdleTimerMin = default;
            item.IdleTimerMax = default;
            item.BlockPercentChance = default;
            item.AttackPercentChance = default;
            item.RecoilStaggerBonusToAttack = default;
            item.UnconsciousBonusToAttack = default;
            item.HandToHandBonusToAttack = default;
            item.PowerAttackPercentChance = default;
            item.RecoilStaggerBonusToPowerAttack = default;
            item.UnconsciousBonusToPowerAttack = default;
            item.PowerAttackNormal = default;
            item.PowerAttackForward = default;
            item.PowerAttackBack = default;
            item.PowerAttackLeft = default;
            item.PowerAttackRight = default;
            item.HoldTimerMin = default;
            item.HoldTimerMax = default;
            item.Flags = default;
            item.AcrobaticDodgePercentChance = default;
            item.RangeMultOptimal = default;
            item.RangeMultMax = default;
            item.SwitchDistanceMelee = default;
            item.SwitchDistanceRanged = default;
            item.BuffStandoffDistance = default;
            item.RangedStandoffDistance = default;
            item.GroupStandoffDistance = default;
            item.RushingAttackPercentChance = default;
            item.RushingAttackDistanceMult = default;
        }
        
        #region Xml Translation
        public virtual void CopyInFromXml(
            ICombatStyleData item,
            XElement node,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask)
        {
            try
            {
                foreach (var elem in node.Elements())
                {
                    CombatStyleDataXmlCreateTranslation.FillPublicElementXml(
                        item: item,
                        node: elem,
                        name: elem.Name.LocalName,
                        errorMask: errorMask,
                        translationMask: translationMask);
                }
            }
            catch (Exception ex)
            when (errorMask != null)
            {
                errorMask.ReportException(ex);
            }
        }
        
        #endregion
        
        #region Binary Translation
        protected static void FillBinaryStructs(
            ICombatStyleData item,
            MutagenFrame frame)
        {
            item.DodgePercentChance = frame.ReadUInt8();
            item.LeftRightPercentChance = frame.ReadUInt8();
            frame.SetPosition(frame.Position + 2);
            item.DodgeLeftRightTimerMin = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
            item.DodgeLeftRightTimerMax = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
            item.DodgeForwardTimerMin = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
            item.DodgeForwardTimerMax = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
            item.DodgeBackTimerMin = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
            item.DodgeBackTimerMax = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
            item.IdleTimerMin = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
            item.IdleTimerMax = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
            item.BlockPercentChance = frame.ReadUInt8();
            item.AttackPercentChance = frame.ReadUInt8();
            frame.SetPosition(frame.Position + 2);
            item.RecoilStaggerBonusToAttack = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
            item.UnconsciousBonusToAttack = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
            item.HandToHandBonusToAttack = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
            item.PowerAttackPercentChance = frame.ReadUInt8();
            frame.SetPosition(frame.Position + 3);
            item.RecoilStaggerBonusToPowerAttack = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
            item.UnconsciousBonusToPowerAttack = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
            item.PowerAttackNormal = frame.ReadUInt8();
            item.PowerAttackForward = frame.ReadUInt8();
            item.PowerAttackBack = frame.ReadUInt8();
            item.PowerAttackLeft = frame.ReadUInt8();
            item.PowerAttackRight = frame.ReadUInt8();
            frame.SetPosition(frame.Position + 3);
            item.HoldTimerMin = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
            item.HoldTimerMax = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
            item.Flags = EnumBinaryTranslation<CombatStyle.Flag>.Instance.Parse(frame: frame.SpawnWithLength(1));
            item.AcrobaticDodgePercentChance = frame.ReadUInt8();
            frame.SetPosition(frame.Position + 2);
            if (frame.Complete)
            {
                item.Versioning |= CombatStyleData.VersioningBreaks.Break0;
                return;
            }
            item.RangeMultOptimal = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
            item.RangeMultMax = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
            if (frame.Complete)
            {
                item.Versioning |= CombatStyleData.VersioningBreaks.Break1;
                return;
            }
            item.SwitchDistanceMelee = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
            item.SwitchDistanceRanged = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
            item.BuffStandoffDistance = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
            if (frame.Complete)
            {
                item.Versioning |= CombatStyleData.VersioningBreaks.Break2;
                return;
            }
            item.RangedStandoffDistance = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
            item.GroupStandoffDistance = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
            if (frame.Complete)
            {
                item.Versioning |= CombatStyleData.VersioningBreaks.Break3;
                return;
            }
            item.RushingAttackPercentChance = frame.ReadUInt8();
            frame.SetPosition(frame.Position + 3);
            item.RushingAttackDistanceMult = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
            if (frame.Complete)
            {
                item.Versioning |= CombatStyleData.VersioningBreaks.Break4;
                return;
            }
            CombatStyleDataBinaryCreateTranslation.FillBinarySecondaryFlagsCustomPublic(
                frame: frame,
                item: item);
        }
        
        public virtual void CopyInFromBinary(
            ICombatStyleData item,
            MutagenFrame frame,
            RecordTypeConverter? recordTypeConverter = null)
        {
            frame = frame.SpawnWithFinalPosition(HeaderTranslation.ParseSubrecord(
                frame.Reader,
                recordTypeConverter.ConvertToCustom(CombatStyleData_Registration.CSTD_HEADER)));
            UtilityTranslation.SubrecordParse(
                record: item,
                frame: frame,
                recordTypeConverter: recordTypeConverter,
                fillStructs: FillBinaryStructs);
        }
        
        #endregion
        
    }
    public partial class CombatStyleDataCommon
    {
        public static readonly CombatStyleDataCommon Instance = new CombatStyleDataCommon();

        public CombatStyleData.Mask<bool> GetEqualsMask(
            ICombatStyleDataGetter item,
            ICombatStyleDataGetter rhs,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            var ret = new CombatStyleData.Mask<bool>(false);
            ((CombatStyleDataCommon)((ICombatStyleDataGetter)item).CommonInstance()!).FillEqualsMask(
                item: item,
                rhs: rhs,
                ret: ret,
                include: include);
            return ret;
        }
        
        public void FillEqualsMask(
            ICombatStyleDataGetter item,
            ICombatStyleDataGetter rhs,
            CombatStyleData.Mask<bool> ret,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            if (rhs == null) return;
            ret.Versioning = item.Versioning == rhs.Versioning;
            ret.DodgePercentChance = item.DodgePercentChance == rhs.DodgePercentChance;
            ret.LeftRightPercentChance = item.LeftRightPercentChance == rhs.LeftRightPercentChance;
            ret.DodgeLeftRightTimerMin = item.DodgeLeftRightTimerMin.EqualsWithin(rhs.DodgeLeftRightTimerMin);
            ret.DodgeLeftRightTimerMax = item.DodgeLeftRightTimerMax.EqualsWithin(rhs.DodgeLeftRightTimerMax);
            ret.DodgeForwardTimerMin = item.DodgeForwardTimerMin.EqualsWithin(rhs.DodgeForwardTimerMin);
            ret.DodgeForwardTimerMax = item.DodgeForwardTimerMax.EqualsWithin(rhs.DodgeForwardTimerMax);
            ret.DodgeBackTimerMin = item.DodgeBackTimerMin.EqualsWithin(rhs.DodgeBackTimerMin);
            ret.DodgeBackTimerMax = item.DodgeBackTimerMax.EqualsWithin(rhs.DodgeBackTimerMax);
            ret.IdleTimerMin = item.IdleTimerMin.EqualsWithin(rhs.IdleTimerMin);
            ret.IdleTimerMax = item.IdleTimerMax.EqualsWithin(rhs.IdleTimerMax);
            ret.BlockPercentChance = item.BlockPercentChance == rhs.BlockPercentChance;
            ret.AttackPercentChance = item.AttackPercentChance == rhs.AttackPercentChance;
            ret.RecoilStaggerBonusToAttack = item.RecoilStaggerBonusToAttack.EqualsWithin(rhs.RecoilStaggerBonusToAttack);
            ret.UnconsciousBonusToAttack = item.UnconsciousBonusToAttack.EqualsWithin(rhs.UnconsciousBonusToAttack);
            ret.HandToHandBonusToAttack = item.HandToHandBonusToAttack.EqualsWithin(rhs.HandToHandBonusToAttack);
            ret.PowerAttackPercentChance = item.PowerAttackPercentChance == rhs.PowerAttackPercentChance;
            ret.RecoilStaggerBonusToPowerAttack = item.RecoilStaggerBonusToPowerAttack.EqualsWithin(rhs.RecoilStaggerBonusToPowerAttack);
            ret.UnconsciousBonusToPowerAttack = item.UnconsciousBonusToPowerAttack.EqualsWithin(rhs.UnconsciousBonusToPowerAttack);
            ret.PowerAttackNormal = item.PowerAttackNormal == rhs.PowerAttackNormal;
            ret.PowerAttackForward = item.PowerAttackForward == rhs.PowerAttackForward;
            ret.PowerAttackBack = item.PowerAttackBack == rhs.PowerAttackBack;
            ret.PowerAttackLeft = item.PowerAttackLeft == rhs.PowerAttackLeft;
            ret.PowerAttackRight = item.PowerAttackRight == rhs.PowerAttackRight;
            ret.HoldTimerMin = item.HoldTimerMin.EqualsWithin(rhs.HoldTimerMin);
            ret.HoldTimerMax = item.HoldTimerMax.EqualsWithin(rhs.HoldTimerMax);
            ret.Flags = item.Flags == rhs.Flags;
            ret.AcrobaticDodgePercentChance = item.AcrobaticDodgePercentChance == rhs.AcrobaticDodgePercentChance;
            ret.RangeMultOptimal = item.RangeMultOptimal.EqualsWithin(rhs.RangeMultOptimal);
            ret.RangeMultMax = item.RangeMultMax.EqualsWithin(rhs.RangeMultMax);
            ret.SwitchDistanceMelee = item.SwitchDistanceMelee.EqualsWithin(rhs.SwitchDistanceMelee);
            ret.SwitchDistanceRanged = item.SwitchDistanceRanged.EqualsWithin(rhs.SwitchDistanceRanged);
            ret.BuffStandoffDistance = item.BuffStandoffDistance.EqualsWithin(rhs.BuffStandoffDistance);
            ret.RangedStandoffDistance = item.RangedStandoffDistance.EqualsWithin(rhs.RangedStandoffDistance);
            ret.GroupStandoffDistance = item.GroupStandoffDistance.EqualsWithin(rhs.GroupStandoffDistance);
            ret.RushingAttackPercentChance = item.RushingAttackPercentChance == rhs.RushingAttackPercentChance;
            ret.RushingAttackDistanceMult = item.RushingAttackDistanceMult.EqualsWithin(rhs.RushingAttackDistanceMult);
        }
        
        public string ToString(
            ICombatStyleDataGetter item,
            string? name = null,
            CombatStyleData.Mask<bool>? printMask = null)
        {
            var fg = new FileGeneration();
            ToString(
                item: item,
                fg: fg,
                name: name,
                printMask: printMask);
            return fg.ToString();
        }
        
        public void ToString(
            ICombatStyleDataGetter item,
            FileGeneration fg,
            string? name = null,
            CombatStyleData.Mask<bool>? printMask = null)
        {
            if (name == null)
            {
                fg.AppendLine($"CombatStyleData =>");
            }
            else
            {
                fg.AppendLine($"{name} (CombatStyleData) =>");
            }
            fg.AppendLine("[");
            using (new DepthWrapper(fg))
            {
                ToStringFields(
                    item: item,
                    fg: fg,
                    printMask: printMask);
            }
            fg.AppendLine("]");
        }
        
        protected static void ToStringFields(
            ICombatStyleDataGetter item,
            FileGeneration fg,
            CombatStyleData.Mask<bool>? printMask = null)
        {
            if (printMask?.Versioning ?? true)
            {
                fg.AppendItem(item.Versioning, "Versioning");
            }
            if (printMask?.DodgePercentChance ?? true)
            {
                fg.AppendItem(item.DodgePercentChance, "DodgePercentChance");
            }
            if (printMask?.LeftRightPercentChance ?? true)
            {
                fg.AppendItem(item.LeftRightPercentChance, "LeftRightPercentChance");
            }
            if (printMask?.DodgeLeftRightTimerMin ?? true)
            {
                fg.AppendItem(item.DodgeLeftRightTimerMin, "DodgeLeftRightTimerMin");
            }
            if (printMask?.DodgeLeftRightTimerMax ?? true)
            {
                fg.AppendItem(item.DodgeLeftRightTimerMax, "DodgeLeftRightTimerMax");
            }
            if (printMask?.DodgeForwardTimerMin ?? true)
            {
                fg.AppendItem(item.DodgeForwardTimerMin, "DodgeForwardTimerMin");
            }
            if (printMask?.DodgeForwardTimerMax ?? true)
            {
                fg.AppendItem(item.DodgeForwardTimerMax, "DodgeForwardTimerMax");
            }
            if (printMask?.DodgeBackTimerMin ?? true)
            {
                fg.AppendItem(item.DodgeBackTimerMin, "DodgeBackTimerMin");
            }
            if (printMask?.DodgeBackTimerMax ?? true)
            {
                fg.AppendItem(item.DodgeBackTimerMax, "DodgeBackTimerMax");
            }
            if (printMask?.IdleTimerMin ?? true)
            {
                fg.AppendItem(item.IdleTimerMin, "IdleTimerMin");
            }
            if (printMask?.IdleTimerMax ?? true)
            {
                fg.AppendItem(item.IdleTimerMax, "IdleTimerMax");
            }
            if (printMask?.BlockPercentChance ?? true)
            {
                fg.AppendItem(item.BlockPercentChance, "BlockPercentChance");
            }
            if (printMask?.AttackPercentChance ?? true)
            {
                fg.AppendItem(item.AttackPercentChance, "AttackPercentChance");
            }
            if (printMask?.RecoilStaggerBonusToAttack ?? true)
            {
                fg.AppendItem(item.RecoilStaggerBonusToAttack, "RecoilStaggerBonusToAttack");
            }
            if (printMask?.UnconsciousBonusToAttack ?? true)
            {
                fg.AppendItem(item.UnconsciousBonusToAttack, "UnconsciousBonusToAttack");
            }
            if (printMask?.HandToHandBonusToAttack ?? true)
            {
                fg.AppendItem(item.HandToHandBonusToAttack, "HandToHandBonusToAttack");
            }
            if (printMask?.PowerAttackPercentChance ?? true)
            {
                fg.AppendItem(item.PowerAttackPercentChance, "PowerAttackPercentChance");
            }
            if (printMask?.RecoilStaggerBonusToPowerAttack ?? true)
            {
                fg.AppendItem(item.RecoilStaggerBonusToPowerAttack, "RecoilStaggerBonusToPowerAttack");
            }
            if (printMask?.UnconsciousBonusToPowerAttack ?? true)
            {
                fg.AppendItem(item.UnconsciousBonusToPowerAttack, "UnconsciousBonusToPowerAttack");
            }
            if (printMask?.PowerAttackNormal ?? true)
            {
                fg.AppendItem(item.PowerAttackNormal, "PowerAttackNormal");
            }
            if (printMask?.PowerAttackForward ?? true)
            {
                fg.AppendItem(item.PowerAttackForward, "PowerAttackForward");
            }
            if (printMask?.PowerAttackBack ?? true)
            {
                fg.AppendItem(item.PowerAttackBack, "PowerAttackBack");
            }
            if (printMask?.PowerAttackLeft ?? true)
            {
                fg.AppendItem(item.PowerAttackLeft, "PowerAttackLeft");
            }
            if (printMask?.PowerAttackRight ?? true)
            {
                fg.AppendItem(item.PowerAttackRight, "PowerAttackRight");
            }
            if (printMask?.HoldTimerMin ?? true)
            {
                fg.AppendItem(item.HoldTimerMin, "HoldTimerMin");
            }
            if (printMask?.HoldTimerMax ?? true)
            {
                fg.AppendItem(item.HoldTimerMax, "HoldTimerMax");
            }
            if (printMask?.Flags ?? true)
            {
                fg.AppendItem(item.Flags, "Flags");
            }
            if (printMask?.AcrobaticDodgePercentChance ?? true)
            {
                fg.AppendItem(item.AcrobaticDodgePercentChance, "AcrobaticDodgePercentChance");
            }
            if (printMask?.RangeMultOptimal ?? true)
            {
                fg.AppendItem(item.RangeMultOptimal, "RangeMultOptimal");
            }
            if (printMask?.RangeMultMax ?? true)
            {
                fg.AppendItem(item.RangeMultMax, "RangeMultMax");
            }
            if (printMask?.SwitchDistanceMelee ?? true)
            {
                fg.AppendItem(item.SwitchDistanceMelee, "SwitchDistanceMelee");
            }
            if (printMask?.SwitchDistanceRanged ?? true)
            {
                fg.AppendItem(item.SwitchDistanceRanged, "SwitchDistanceRanged");
            }
            if (printMask?.BuffStandoffDistance ?? true)
            {
                fg.AppendItem(item.BuffStandoffDistance, "BuffStandoffDistance");
            }
            if (printMask?.RangedStandoffDistance ?? true)
            {
                fg.AppendItem(item.RangedStandoffDistance, "RangedStandoffDistance");
            }
            if (printMask?.GroupStandoffDistance ?? true)
            {
                fg.AppendItem(item.GroupStandoffDistance, "GroupStandoffDistance");
            }
            if (printMask?.RushingAttackPercentChance ?? true)
            {
                fg.AppendItem(item.RushingAttackPercentChance, "RushingAttackPercentChance");
            }
            if (printMask?.RushingAttackDistanceMult ?? true)
            {
                fg.AppendItem(item.RushingAttackDistanceMult, "RushingAttackDistanceMult");
            }
        }
        
        public bool HasBeenSet(
            ICombatStyleDataGetter item,
            CombatStyleData.Mask<bool?> checkMask)
        {
            return true;
        }
        
        public void FillHasBeenSetMask(
            ICombatStyleDataGetter item,
            CombatStyleData.Mask<bool> mask)
        {
            mask.Versioning = true;
            mask.DodgePercentChance = true;
            mask.LeftRightPercentChance = true;
            mask.DodgeLeftRightTimerMin = true;
            mask.DodgeLeftRightTimerMax = true;
            mask.DodgeForwardTimerMin = true;
            mask.DodgeForwardTimerMax = true;
            mask.DodgeBackTimerMin = true;
            mask.DodgeBackTimerMax = true;
            mask.IdleTimerMin = true;
            mask.IdleTimerMax = true;
            mask.BlockPercentChance = true;
            mask.AttackPercentChance = true;
            mask.RecoilStaggerBonusToAttack = true;
            mask.UnconsciousBonusToAttack = true;
            mask.HandToHandBonusToAttack = true;
            mask.PowerAttackPercentChance = true;
            mask.RecoilStaggerBonusToPowerAttack = true;
            mask.UnconsciousBonusToPowerAttack = true;
            mask.PowerAttackNormal = true;
            mask.PowerAttackForward = true;
            mask.PowerAttackBack = true;
            mask.PowerAttackLeft = true;
            mask.PowerAttackRight = true;
            mask.HoldTimerMin = true;
            mask.HoldTimerMax = true;
            mask.Flags = true;
            mask.AcrobaticDodgePercentChance = true;
            mask.RangeMultOptimal = true;
            mask.RangeMultMax = true;
            mask.SwitchDistanceMelee = true;
            mask.SwitchDistanceRanged = true;
            mask.BuffStandoffDistance = true;
            mask.RangedStandoffDistance = true;
            mask.GroupStandoffDistance = true;
            mask.RushingAttackPercentChance = true;
            mask.RushingAttackDistanceMult = true;
        }
        
        #region Equals and Hash
        public virtual bool Equals(
            ICombatStyleDataGetter? lhs,
            ICombatStyleDataGetter? rhs)
        {
            if (lhs == null && rhs == null) return false;
            if (lhs == null || rhs == null) return false;
            if (lhs.Versioning != rhs.Versioning) return false;
            if (lhs.DodgePercentChance != rhs.DodgePercentChance) return false;
            if (lhs.LeftRightPercentChance != rhs.LeftRightPercentChance) return false;
            if (!lhs.DodgeLeftRightTimerMin.EqualsWithin(rhs.DodgeLeftRightTimerMin)) return false;
            if (!lhs.DodgeLeftRightTimerMax.EqualsWithin(rhs.DodgeLeftRightTimerMax)) return false;
            if (!lhs.DodgeForwardTimerMin.EqualsWithin(rhs.DodgeForwardTimerMin)) return false;
            if (!lhs.DodgeForwardTimerMax.EqualsWithin(rhs.DodgeForwardTimerMax)) return false;
            if (!lhs.DodgeBackTimerMin.EqualsWithin(rhs.DodgeBackTimerMin)) return false;
            if (!lhs.DodgeBackTimerMax.EqualsWithin(rhs.DodgeBackTimerMax)) return false;
            if (!lhs.IdleTimerMin.EqualsWithin(rhs.IdleTimerMin)) return false;
            if (!lhs.IdleTimerMax.EqualsWithin(rhs.IdleTimerMax)) return false;
            if (lhs.BlockPercentChance != rhs.BlockPercentChance) return false;
            if (lhs.AttackPercentChance != rhs.AttackPercentChance) return false;
            if (!lhs.RecoilStaggerBonusToAttack.EqualsWithin(rhs.RecoilStaggerBonusToAttack)) return false;
            if (!lhs.UnconsciousBonusToAttack.EqualsWithin(rhs.UnconsciousBonusToAttack)) return false;
            if (!lhs.HandToHandBonusToAttack.EqualsWithin(rhs.HandToHandBonusToAttack)) return false;
            if (lhs.PowerAttackPercentChance != rhs.PowerAttackPercentChance) return false;
            if (!lhs.RecoilStaggerBonusToPowerAttack.EqualsWithin(rhs.RecoilStaggerBonusToPowerAttack)) return false;
            if (!lhs.UnconsciousBonusToPowerAttack.EqualsWithin(rhs.UnconsciousBonusToPowerAttack)) return false;
            if (lhs.PowerAttackNormal != rhs.PowerAttackNormal) return false;
            if (lhs.PowerAttackForward != rhs.PowerAttackForward) return false;
            if (lhs.PowerAttackBack != rhs.PowerAttackBack) return false;
            if (lhs.PowerAttackLeft != rhs.PowerAttackLeft) return false;
            if (lhs.PowerAttackRight != rhs.PowerAttackRight) return false;
            if (!lhs.HoldTimerMin.EqualsWithin(rhs.HoldTimerMin)) return false;
            if (!lhs.HoldTimerMax.EqualsWithin(rhs.HoldTimerMax)) return false;
            if (lhs.Flags != rhs.Flags) return false;
            if (lhs.AcrobaticDodgePercentChance != rhs.AcrobaticDodgePercentChance) return false;
            if (!lhs.RangeMultOptimal.EqualsWithin(rhs.RangeMultOptimal)) return false;
            if (!lhs.RangeMultMax.EqualsWithin(rhs.RangeMultMax)) return false;
            if (!lhs.SwitchDistanceMelee.EqualsWithin(rhs.SwitchDistanceMelee)) return false;
            if (!lhs.SwitchDistanceRanged.EqualsWithin(rhs.SwitchDistanceRanged)) return false;
            if (!lhs.BuffStandoffDistance.EqualsWithin(rhs.BuffStandoffDistance)) return false;
            if (!lhs.RangedStandoffDistance.EqualsWithin(rhs.RangedStandoffDistance)) return false;
            if (!lhs.GroupStandoffDistance.EqualsWithin(rhs.GroupStandoffDistance)) return false;
            if (lhs.RushingAttackPercentChance != rhs.RushingAttackPercentChance) return false;
            if (!lhs.RushingAttackDistanceMult.EqualsWithin(rhs.RushingAttackDistanceMult)) return false;
            return true;
        }
        
        public virtual int GetHashCode(ICombatStyleDataGetter item)
        {
            var hash = new HashCode();
            hash.Add(item.Versioning);
            hash.Add(item.DodgePercentChance);
            hash.Add(item.LeftRightPercentChance);
            hash.Add(item.DodgeLeftRightTimerMin);
            hash.Add(item.DodgeLeftRightTimerMax);
            hash.Add(item.DodgeForwardTimerMin);
            hash.Add(item.DodgeForwardTimerMax);
            hash.Add(item.DodgeBackTimerMin);
            hash.Add(item.DodgeBackTimerMax);
            hash.Add(item.IdleTimerMin);
            hash.Add(item.IdleTimerMax);
            hash.Add(item.BlockPercentChance);
            hash.Add(item.AttackPercentChance);
            hash.Add(item.RecoilStaggerBonusToAttack);
            hash.Add(item.UnconsciousBonusToAttack);
            hash.Add(item.HandToHandBonusToAttack);
            hash.Add(item.PowerAttackPercentChance);
            hash.Add(item.RecoilStaggerBonusToPowerAttack);
            hash.Add(item.UnconsciousBonusToPowerAttack);
            hash.Add(item.PowerAttackNormal);
            hash.Add(item.PowerAttackForward);
            hash.Add(item.PowerAttackBack);
            hash.Add(item.PowerAttackLeft);
            hash.Add(item.PowerAttackRight);
            hash.Add(item.HoldTimerMin);
            hash.Add(item.HoldTimerMax);
            hash.Add(item.Flags);
            hash.Add(item.AcrobaticDodgePercentChance);
            hash.Add(item.RangeMultOptimal);
            hash.Add(item.RangeMultMax);
            hash.Add(item.SwitchDistanceMelee);
            hash.Add(item.SwitchDistanceRanged);
            hash.Add(item.BuffStandoffDistance);
            hash.Add(item.RangedStandoffDistance);
            hash.Add(item.GroupStandoffDistance);
            hash.Add(item.RushingAttackPercentChance);
            hash.Add(item.RushingAttackDistanceMult);
            return hash.ToHashCode();
        }
        
        #endregion
        
        
        public object GetNew()
        {
            return CombatStyleData.GetNew();
        }
        
        #region Mutagen
        public IEnumerable<FormKey> GetLinkFormKeys(ICombatStyleDataGetter obj)
        {
            yield break;
        }
        
        public void RemapLinks(ICombatStyleDataGetter obj, IReadOnlyDictionary<FormKey, FormKey> mapping) => throw new NotImplementedException();
        #endregion
        
    }
    public partial class CombatStyleDataSetterTranslationCommon
    {
        public static readonly CombatStyleDataSetterTranslationCommon Instance = new CombatStyleDataSetterTranslationCommon();

        #region Deep Copy Fields From
        public void DeepCopyIn(
            ICombatStyleData item,
            ICombatStyleDataGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask)
        {
            if ((copyMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.Versioning) ?? true))
            {
                item.Versioning = rhs.Versioning;
            }
            if ((copyMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.DodgePercentChance) ?? true))
            {
                item.DodgePercentChance = rhs.DodgePercentChance;
            }
            if ((copyMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.LeftRightPercentChance) ?? true))
            {
                item.LeftRightPercentChance = rhs.LeftRightPercentChance;
            }
            if ((copyMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.DodgeLeftRightTimerMin) ?? true))
            {
                item.DodgeLeftRightTimerMin = rhs.DodgeLeftRightTimerMin;
            }
            if ((copyMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.DodgeLeftRightTimerMax) ?? true))
            {
                item.DodgeLeftRightTimerMax = rhs.DodgeLeftRightTimerMax;
            }
            if ((copyMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.DodgeForwardTimerMin) ?? true))
            {
                item.DodgeForwardTimerMin = rhs.DodgeForwardTimerMin;
            }
            if ((copyMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.DodgeForwardTimerMax) ?? true))
            {
                item.DodgeForwardTimerMax = rhs.DodgeForwardTimerMax;
            }
            if ((copyMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.DodgeBackTimerMin) ?? true))
            {
                item.DodgeBackTimerMin = rhs.DodgeBackTimerMin;
            }
            if ((copyMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.DodgeBackTimerMax) ?? true))
            {
                item.DodgeBackTimerMax = rhs.DodgeBackTimerMax;
            }
            if ((copyMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.IdleTimerMin) ?? true))
            {
                item.IdleTimerMin = rhs.IdleTimerMin;
            }
            if ((copyMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.IdleTimerMax) ?? true))
            {
                item.IdleTimerMax = rhs.IdleTimerMax;
            }
            if ((copyMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.BlockPercentChance) ?? true))
            {
                item.BlockPercentChance = rhs.BlockPercentChance;
            }
            if ((copyMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.AttackPercentChance) ?? true))
            {
                item.AttackPercentChance = rhs.AttackPercentChance;
            }
            if ((copyMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.RecoilStaggerBonusToAttack) ?? true))
            {
                item.RecoilStaggerBonusToAttack = rhs.RecoilStaggerBonusToAttack;
            }
            if ((copyMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.UnconsciousBonusToAttack) ?? true))
            {
                item.UnconsciousBonusToAttack = rhs.UnconsciousBonusToAttack;
            }
            if ((copyMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.HandToHandBonusToAttack) ?? true))
            {
                item.HandToHandBonusToAttack = rhs.HandToHandBonusToAttack;
            }
            if ((copyMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.PowerAttackPercentChance) ?? true))
            {
                item.PowerAttackPercentChance = rhs.PowerAttackPercentChance;
            }
            if ((copyMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.RecoilStaggerBonusToPowerAttack) ?? true))
            {
                item.RecoilStaggerBonusToPowerAttack = rhs.RecoilStaggerBonusToPowerAttack;
            }
            if ((copyMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.UnconsciousBonusToPowerAttack) ?? true))
            {
                item.UnconsciousBonusToPowerAttack = rhs.UnconsciousBonusToPowerAttack;
            }
            if ((copyMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.PowerAttackNormal) ?? true))
            {
                item.PowerAttackNormal = rhs.PowerAttackNormal;
            }
            if ((copyMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.PowerAttackForward) ?? true))
            {
                item.PowerAttackForward = rhs.PowerAttackForward;
            }
            if ((copyMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.PowerAttackBack) ?? true))
            {
                item.PowerAttackBack = rhs.PowerAttackBack;
            }
            if ((copyMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.PowerAttackLeft) ?? true))
            {
                item.PowerAttackLeft = rhs.PowerAttackLeft;
            }
            if ((copyMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.PowerAttackRight) ?? true))
            {
                item.PowerAttackRight = rhs.PowerAttackRight;
            }
            if ((copyMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.HoldTimerMin) ?? true))
            {
                item.HoldTimerMin = rhs.HoldTimerMin;
            }
            if ((copyMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.HoldTimerMax) ?? true))
            {
                item.HoldTimerMax = rhs.HoldTimerMax;
            }
            if ((copyMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.Flags) ?? true))
            {
                item.Flags = rhs.Flags;
            }
            if ((copyMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.AcrobaticDodgePercentChance) ?? true))
            {
                item.AcrobaticDodgePercentChance = rhs.AcrobaticDodgePercentChance;
            }
            if (rhs.Versioning.HasFlag(CombatStyleData.VersioningBreaks.Break0)) return;
            if ((copyMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.RangeMultOptimal) ?? true))
            {
                item.RangeMultOptimal = rhs.RangeMultOptimal;
            }
            if ((copyMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.RangeMultMax) ?? true))
            {
                item.RangeMultMax = rhs.RangeMultMax;
            }
            if (rhs.Versioning.HasFlag(CombatStyleData.VersioningBreaks.Break1)) return;
            if ((copyMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.SwitchDistanceMelee) ?? true))
            {
                item.SwitchDistanceMelee = rhs.SwitchDistanceMelee;
            }
            if ((copyMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.SwitchDistanceRanged) ?? true))
            {
                item.SwitchDistanceRanged = rhs.SwitchDistanceRanged;
            }
            if ((copyMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.BuffStandoffDistance) ?? true))
            {
                item.BuffStandoffDistance = rhs.BuffStandoffDistance;
            }
            if (rhs.Versioning.HasFlag(CombatStyleData.VersioningBreaks.Break2)) return;
            if ((copyMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.RangedStandoffDistance) ?? true))
            {
                item.RangedStandoffDistance = rhs.RangedStandoffDistance;
            }
            if ((copyMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.GroupStandoffDistance) ?? true))
            {
                item.GroupStandoffDistance = rhs.GroupStandoffDistance;
            }
            if (rhs.Versioning.HasFlag(CombatStyleData.VersioningBreaks.Break3)) return;
            if ((copyMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.RushingAttackPercentChance) ?? true))
            {
                item.RushingAttackPercentChance = rhs.RushingAttackPercentChance;
            }
            if ((copyMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.RushingAttackDistanceMult) ?? true))
            {
                item.RushingAttackDistanceMult = rhs.RushingAttackDistanceMult;
            }
            if (rhs.Versioning.HasFlag(CombatStyleData.VersioningBreaks.Break4)) return;
        }
        
        #endregion
        
        public CombatStyleData DeepCopy(
            ICombatStyleDataGetter item,
            CombatStyleData.TranslationMask? copyMask = null)
        {
            CombatStyleData ret = (CombatStyleData)((CombatStyleDataCommon)((ICombatStyleDataGetter)item).CommonInstance()!).GetNew();
            ret.DeepCopyIn(
                item,
                copyMask: copyMask);
            return ret;
        }
        
        public CombatStyleData DeepCopy(
            ICombatStyleDataGetter item,
            out CombatStyleData.ErrorMask errorMask,
            CombatStyleData.TranslationMask? copyMask = null)
        {
            CombatStyleData ret = (CombatStyleData)((CombatStyleDataCommon)((ICombatStyleDataGetter)item).CommonInstance()!).GetNew();
            ret.DeepCopyIn(
                item,
                errorMask: out errorMask,
                copyMask: copyMask);
            return ret;
        }
        
        public CombatStyleData DeepCopy(
            ICombatStyleDataGetter item,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask = null)
        {
            CombatStyleData ret = (CombatStyleData)((CombatStyleDataCommon)((ICombatStyleDataGetter)item).CommonInstance()!).GetNew();
            ret.DeepCopyIn(
                item,
                errorMask: errorMask,
                copyMask: copyMask);
            return ret;
        }
        
    }
    #endregion

}

namespace Mutagen.Bethesda.Oblivion
{
    public partial class CombatStyleData
    {
        #region Common Routing
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILoquiRegistration ILoquiObject.Registration => CombatStyleData_Registration.Instance;
        public static CombatStyleData_Registration Registration => CombatStyleData_Registration.Instance;
        [DebuggerStepThrough]
        protected object CommonInstance() => CombatStyleDataCommon.Instance;
        [DebuggerStepThrough]
        protected object CommonSetterInstance()
        {
            return CombatStyleDataSetterCommon.Instance;
        }
        [DebuggerStepThrough]
        protected object CommonSetterTranslationInstance() => CombatStyleDataSetterTranslationCommon.Instance;
        [DebuggerStepThrough]
        object ICombatStyleDataGetter.CommonInstance() => this.CommonInstance();
        [DebuggerStepThrough]
        object ICombatStyleDataGetter.CommonSetterInstance() => this.CommonSetterInstance();
        [DebuggerStepThrough]
        object ICombatStyleDataGetter.CommonSetterTranslationInstance() => this.CommonSetterTranslationInstance();

        #endregion

    }
}

#region Modules
#region Xml Translation
namespace Mutagen.Bethesda.Oblivion.Internals
{
    public partial class CombatStyleDataXmlWriteTranslation : IXmlWriteTranslator
    {
        public readonly static CombatStyleDataXmlWriteTranslation Instance = new CombatStyleDataXmlWriteTranslation();

        public static void WriteToNodeXml(
            ICombatStyleDataGetter item,
            XElement node,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask)
        {
            if ((translationMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.Versioning) ?? true))
            {
                EnumXmlTranslation<CombatStyleData.VersioningBreaks>.Instance.Write(
                    node: node,
                    name: nameof(item.Versioning),
                    item: item.Versioning,
                    fieldIndex: (int)CombatStyleData_FieldIndex.Versioning,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.DodgePercentChance) ?? true))
            {
                ByteXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.DodgePercentChance),
                    item: item.DodgePercentChance,
                    fieldIndex: (int)CombatStyleData_FieldIndex.DodgePercentChance,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.LeftRightPercentChance) ?? true))
            {
                ByteXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.LeftRightPercentChance),
                    item: item.LeftRightPercentChance,
                    fieldIndex: (int)CombatStyleData_FieldIndex.LeftRightPercentChance,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.DodgeLeftRightTimerMin) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.DodgeLeftRightTimerMin),
                    item: item.DodgeLeftRightTimerMin,
                    fieldIndex: (int)CombatStyleData_FieldIndex.DodgeLeftRightTimerMin,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.DodgeLeftRightTimerMax) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.DodgeLeftRightTimerMax),
                    item: item.DodgeLeftRightTimerMax,
                    fieldIndex: (int)CombatStyleData_FieldIndex.DodgeLeftRightTimerMax,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.DodgeForwardTimerMin) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.DodgeForwardTimerMin),
                    item: item.DodgeForwardTimerMin,
                    fieldIndex: (int)CombatStyleData_FieldIndex.DodgeForwardTimerMin,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.DodgeForwardTimerMax) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.DodgeForwardTimerMax),
                    item: item.DodgeForwardTimerMax,
                    fieldIndex: (int)CombatStyleData_FieldIndex.DodgeForwardTimerMax,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.DodgeBackTimerMin) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.DodgeBackTimerMin),
                    item: item.DodgeBackTimerMin,
                    fieldIndex: (int)CombatStyleData_FieldIndex.DodgeBackTimerMin,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.DodgeBackTimerMax) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.DodgeBackTimerMax),
                    item: item.DodgeBackTimerMax,
                    fieldIndex: (int)CombatStyleData_FieldIndex.DodgeBackTimerMax,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.IdleTimerMin) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.IdleTimerMin),
                    item: item.IdleTimerMin,
                    fieldIndex: (int)CombatStyleData_FieldIndex.IdleTimerMin,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.IdleTimerMax) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.IdleTimerMax),
                    item: item.IdleTimerMax,
                    fieldIndex: (int)CombatStyleData_FieldIndex.IdleTimerMax,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.BlockPercentChance) ?? true))
            {
                ByteXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.BlockPercentChance),
                    item: item.BlockPercentChance,
                    fieldIndex: (int)CombatStyleData_FieldIndex.BlockPercentChance,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.AttackPercentChance) ?? true))
            {
                ByteXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.AttackPercentChance),
                    item: item.AttackPercentChance,
                    fieldIndex: (int)CombatStyleData_FieldIndex.AttackPercentChance,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.RecoilStaggerBonusToAttack) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.RecoilStaggerBonusToAttack),
                    item: item.RecoilStaggerBonusToAttack,
                    fieldIndex: (int)CombatStyleData_FieldIndex.RecoilStaggerBonusToAttack,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.UnconsciousBonusToAttack) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.UnconsciousBonusToAttack),
                    item: item.UnconsciousBonusToAttack,
                    fieldIndex: (int)CombatStyleData_FieldIndex.UnconsciousBonusToAttack,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.HandToHandBonusToAttack) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.HandToHandBonusToAttack),
                    item: item.HandToHandBonusToAttack,
                    fieldIndex: (int)CombatStyleData_FieldIndex.HandToHandBonusToAttack,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.PowerAttackPercentChance) ?? true))
            {
                ByteXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.PowerAttackPercentChance),
                    item: item.PowerAttackPercentChance,
                    fieldIndex: (int)CombatStyleData_FieldIndex.PowerAttackPercentChance,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.RecoilStaggerBonusToPowerAttack) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.RecoilStaggerBonusToPowerAttack),
                    item: item.RecoilStaggerBonusToPowerAttack,
                    fieldIndex: (int)CombatStyleData_FieldIndex.RecoilStaggerBonusToPowerAttack,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.UnconsciousBonusToPowerAttack) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.UnconsciousBonusToPowerAttack),
                    item: item.UnconsciousBonusToPowerAttack,
                    fieldIndex: (int)CombatStyleData_FieldIndex.UnconsciousBonusToPowerAttack,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.PowerAttackNormal) ?? true))
            {
                ByteXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.PowerAttackNormal),
                    item: item.PowerAttackNormal,
                    fieldIndex: (int)CombatStyleData_FieldIndex.PowerAttackNormal,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.PowerAttackForward) ?? true))
            {
                ByteXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.PowerAttackForward),
                    item: item.PowerAttackForward,
                    fieldIndex: (int)CombatStyleData_FieldIndex.PowerAttackForward,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.PowerAttackBack) ?? true))
            {
                ByteXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.PowerAttackBack),
                    item: item.PowerAttackBack,
                    fieldIndex: (int)CombatStyleData_FieldIndex.PowerAttackBack,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.PowerAttackLeft) ?? true))
            {
                ByteXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.PowerAttackLeft),
                    item: item.PowerAttackLeft,
                    fieldIndex: (int)CombatStyleData_FieldIndex.PowerAttackLeft,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.PowerAttackRight) ?? true))
            {
                ByteXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.PowerAttackRight),
                    item: item.PowerAttackRight,
                    fieldIndex: (int)CombatStyleData_FieldIndex.PowerAttackRight,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.HoldTimerMin) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.HoldTimerMin),
                    item: item.HoldTimerMin,
                    fieldIndex: (int)CombatStyleData_FieldIndex.HoldTimerMin,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.HoldTimerMax) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.HoldTimerMax),
                    item: item.HoldTimerMax,
                    fieldIndex: (int)CombatStyleData_FieldIndex.HoldTimerMax,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.Flags) ?? true))
            {
                EnumXmlTranslation<CombatStyle.Flag>.Instance.Write(
                    node: node,
                    name: nameof(item.Flags),
                    item: item.Flags,
                    fieldIndex: (int)CombatStyleData_FieldIndex.Flags,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.AcrobaticDodgePercentChance) ?? true))
            {
                ByteXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.AcrobaticDodgePercentChance),
                    item: item.AcrobaticDodgePercentChance,
                    fieldIndex: (int)CombatStyleData_FieldIndex.AcrobaticDodgePercentChance,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.RangeMultOptimal) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.RangeMultOptimal),
                    item: item.RangeMultOptimal,
                    fieldIndex: (int)CombatStyleData_FieldIndex.RangeMultOptimal,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.RangeMultMax) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.RangeMultMax),
                    item: item.RangeMultMax,
                    fieldIndex: (int)CombatStyleData_FieldIndex.RangeMultMax,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.SwitchDistanceMelee) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.SwitchDistanceMelee),
                    item: item.SwitchDistanceMelee,
                    fieldIndex: (int)CombatStyleData_FieldIndex.SwitchDistanceMelee,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.SwitchDistanceRanged) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.SwitchDistanceRanged),
                    item: item.SwitchDistanceRanged,
                    fieldIndex: (int)CombatStyleData_FieldIndex.SwitchDistanceRanged,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.BuffStandoffDistance) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.BuffStandoffDistance),
                    item: item.BuffStandoffDistance,
                    fieldIndex: (int)CombatStyleData_FieldIndex.BuffStandoffDistance,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.RangedStandoffDistance) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.RangedStandoffDistance),
                    item: item.RangedStandoffDistance,
                    fieldIndex: (int)CombatStyleData_FieldIndex.RangedStandoffDistance,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.GroupStandoffDistance) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.GroupStandoffDistance),
                    item: item.GroupStandoffDistance,
                    fieldIndex: (int)CombatStyleData_FieldIndex.GroupStandoffDistance,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.RushingAttackPercentChance) ?? true))
            {
                ByteXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.RushingAttackPercentChance),
                    item: item.RushingAttackPercentChance,
                    fieldIndex: (int)CombatStyleData_FieldIndex.RushingAttackPercentChance,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)CombatStyleData_FieldIndex.RushingAttackDistanceMult) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.RushingAttackDistanceMult),
                    item: item.RushingAttackDistanceMult,
                    fieldIndex: (int)CombatStyleData_FieldIndex.RushingAttackDistanceMult,
                    errorMask: errorMask);
            }
        }

        public void Write(
            XElement node,
            ICombatStyleDataGetter item,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask,
            string? name = null)
        {
            var elem = new XElement(name ?? "Mutagen.Bethesda.Oblivion.CombatStyleData");
            node.Add(elem);
            if (name != null)
            {
                elem.SetAttributeValue("type", "Mutagen.Bethesda.Oblivion.CombatStyleData");
            }
            WriteToNodeXml(
                item: item,
                node: elem,
                errorMask: errorMask,
                translationMask: translationMask);
        }

        public void Write(
            XElement node,
            object item,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask,
            string? name = null)
        {
            Write(
                item: (ICombatStyleDataGetter)item,
                name: name,
                node: node,
                errorMask: errorMask,
                translationMask: translationMask);
        }

        public void Write(
            XElement node,
            ICombatStyleDataGetter item,
            ErrorMaskBuilder? errorMask,
            int fieldIndex,
            TranslationCrystal? translationMask,
            string? name = null)
        {
            errorMask?.PushIndex(fieldIndex);
            try
            {
                Write(
                    item: (ICombatStyleDataGetter)item,
                    name: name,
                    node: node,
                    errorMask: errorMask,
                    translationMask: translationMask);
            }
            catch (Exception ex)
            when (errorMask != null)
            {
                errorMask.ReportException(ex);
            }
            finally
            {
                errorMask?.PopIndex();
            }
        }

    }

    public partial class CombatStyleDataXmlCreateTranslation
    {
        public readonly static CombatStyleDataXmlCreateTranslation Instance = new CombatStyleDataXmlCreateTranslation();

        public static void FillPublicXml(
            ICombatStyleData item,
            XElement node,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask)
        {
            try
            {
                foreach (var elem in node.Elements())
                {
                    CombatStyleDataXmlCreateTranslation.FillPublicElementXml(
                        item: item,
                        node: elem,
                        name: elem.Name.LocalName,
                        errorMask: errorMask,
                        translationMask: translationMask);
                }
            }
            catch (Exception ex)
            when (errorMask != null)
            {
                errorMask.ReportException(ex);
            }
        }

        public static void FillPublicElementXml(
            ICombatStyleData item,
            XElement node,
            string name,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask)
        {
            switch (name)
            {
                case "Versioning":
                    errorMask?.PushIndex((int)CombatStyleData_FieldIndex.Versioning);
                    try
                    {
                        item.Versioning = EnumXmlTranslation<CombatStyleData.VersioningBreaks>.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "DodgePercentChance":
                    errorMask?.PushIndex((int)CombatStyleData_FieldIndex.DodgePercentChance);
                    try
                    {
                        item.DodgePercentChance = ByteXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "LeftRightPercentChance":
                    errorMask?.PushIndex((int)CombatStyleData_FieldIndex.LeftRightPercentChance);
                    try
                    {
                        item.LeftRightPercentChance = ByteXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "DodgeLeftRightTimerMin":
                    errorMask?.PushIndex((int)CombatStyleData_FieldIndex.DodgeLeftRightTimerMin);
                    try
                    {
                        item.DodgeLeftRightTimerMin = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "DodgeLeftRightTimerMax":
                    errorMask?.PushIndex((int)CombatStyleData_FieldIndex.DodgeLeftRightTimerMax);
                    try
                    {
                        item.DodgeLeftRightTimerMax = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "DodgeForwardTimerMin":
                    errorMask?.PushIndex((int)CombatStyleData_FieldIndex.DodgeForwardTimerMin);
                    try
                    {
                        item.DodgeForwardTimerMin = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "DodgeForwardTimerMax":
                    errorMask?.PushIndex((int)CombatStyleData_FieldIndex.DodgeForwardTimerMax);
                    try
                    {
                        item.DodgeForwardTimerMax = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "DodgeBackTimerMin":
                    errorMask?.PushIndex((int)CombatStyleData_FieldIndex.DodgeBackTimerMin);
                    try
                    {
                        item.DodgeBackTimerMin = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "DodgeBackTimerMax":
                    errorMask?.PushIndex((int)CombatStyleData_FieldIndex.DodgeBackTimerMax);
                    try
                    {
                        item.DodgeBackTimerMax = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "IdleTimerMin":
                    errorMask?.PushIndex((int)CombatStyleData_FieldIndex.IdleTimerMin);
                    try
                    {
                        item.IdleTimerMin = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "IdleTimerMax":
                    errorMask?.PushIndex((int)CombatStyleData_FieldIndex.IdleTimerMax);
                    try
                    {
                        item.IdleTimerMax = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "BlockPercentChance":
                    errorMask?.PushIndex((int)CombatStyleData_FieldIndex.BlockPercentChance);
                    try
                    {
                        item.BlockPercentChance = ByteXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "AttackPercentChance":
                    errorMask?.PushIndex((int)CombatStyleData_FieldIndex.AttackPercentChance);
                    try
                    {
                        item.AttackPercentChance = ByteXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "RecoilStaggerBonusToAttack":
                    errorMask?.PushIndex((int)CombatStyleData_FieldIndex.RecoilStaggerBonusToAttack);
                    try
                    {
                        item.RecoilStaggerBonusToAttack = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "UnconsciousBonusToAttack":
                    errorMask?.PushIndex((int)CombatStyleData_FieldIndex.UnconsciousBonusToAttack);
                    try
                    {
                        item.UnconsciousBonusToAttack = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "HandToHandBonusToAttack":
                    errorMask?.PushIndex((int)CombatStyleData_FieldIndex.HandToHandBonusToAttack);
                    try
                    {
                        item.HandToHandBonusToAttack = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "PowerAttackPercentChance":
                    errorMask?.PushIndex((int)CombatStyleData_FieldIndex.PowerAttackPercentChance);
                    try
                    {
                        item.PowerAttackPercentChance = ByteXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "RecoilStaggerBonusToPowerAttack":
                    errorMask?.PushIndex((int)CombatStyleData_FieldIndex.RecoilStaggerBonusToPowerAttack);
                    try
                    {
                        item.RecoilStaggerBonusToPowerAttack = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "UnconsciousBonusToPowerAttack":
                    errorMask?.PushIndex((int)CombatStyleData_FieldIndex.UnconsciousBonusToPowerAttack);
                    try
                    {
                        item.UnconsciousBonusToPowerAttack = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "PowerAttackNormal":
                    errorMask?.PushIndex((int)CombatStyleData_FieldIndex.PowerAttackNormal);
                    try
                    {
                        item.PowerAttackNormal = ByteXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "PowerAttackForward":
                    errorMask?.PushIndex((int)CombatStyleData_FieldIndex.PowerAttackForward);
                    try
                    {
                        item.PowerAttackForward = ByteXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "PowerAttackBack":
                    errorMask?.PushIndex((int)CombatStyleData_FieldIndex.PowerAttackBack);
                    try
                    {
                        item.PowerAttackBack = ByteXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "PowerAttackLeft":
                    errorMask?.PushIndex((int)CombatStyleData_FieldIndex.PowerAttackLeft);
                    try
                    {
                        item.PowerAttackLeft = ByteXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "PowerAttackRight":
                    errorMask?.PushIndex((int)CombatStyleData_FieldIndex.PowerAttackRight);
                    try
                    {
                        item.PowerAttackRight = ByteXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "HoldTimerMin":
                    errorMask?.PushIndex((int)CombatStyleData_FieldIndex.HoldTimerMin);
                    try
                    {
                        item.HoldTimerMin = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "HoldTimerMax":
                    errorMask?.PushIndex((int)CombatStyleData_FieldIndex.HoldTimerMax);
                    try
                    {
                        item.HoldTimerMax = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "Flags":
                    errorMask?.PushIndex((int)CombatStyleData_FieldIndex.Flags);
                    try
                    {
                        item.Flags = EnumXmlTranslation<CombatStyle.Flag>.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "AcrobaticDodgePercentChance":
                    errorMask?.PushIndex((int)CombatStyleData_FieldIndex.AcrobaticDodgePercentChance);
                    try
                    {
                        item.AcrobaticDodgePercentChance = ByteXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "RangeMultOptimal":
                    errorMask?.PushIndex((int)CombatStyleData_FieldIndex.RangeMultOptimal);
                    try
                    {
                        item.RangeMultOptimal = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "RangeMultMax":
                    errorMask?.PushIndex((int)CombatStyleData_FieldIndex.RangeMultMax);
                    try
                    {
                        item.RangeMultMax = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "SwitchDistanceMelee":
                    errorMask?.PushIndex((int)CombatStyleData_FieldIndex.SwitchDistanceMelee);
                    try
                    {
                        item.SwitchDistanceMelee = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "SwitchDistanceRanged":
                    errorMask?.PushIndex((int)CombatStyleData_FieldIndex.SwitchDistanceRanged);
                    try
                    {
                        item.SwitchDistanceRanged = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "BuffStandoffDistance":
                    errorMask?.PushIndex((int)CombatStyleData_FieldIndex.BuffStandoffDistance);
                    try
                    {
                        item.BuffStandoffDistance = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "RangedStandoffDistance":
                    errorMask?.PushIndex((int)CombatStyleData_FieldIndex.RangedStandoffDistance);
                    try
                    {
                        item.RangedStandoffDistance = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "GroupStandoffDistance":
                    errorMask?.PushIndex((int)CombatStyleData_FieldIndex.GroupStandoffDistance);
                    try
                    {
                        item.GroupStandoffDistance = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "RushingAttackPercentChance":
                    errorMask?.PushIndex((int)CombatStyleData_FieldIndex.RushingAttackPercentChance);
                    try
                    {
                        item.RushingAttackPercentChance = ByteXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "RushingAttackDistanceMult":
                    errorMask?.PushIndex((int)CombatStyleData_FieldIndex.RushingAttackDistanceMult);
                    try
                    {
                        item.RushingAttackDistanceMult = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                default:
                    break;
            }
        }

    }

}
namespace Mutagen.Bethesda.Oblivion
{
    #region Xml Write Mixins
    public static class CombatStyleDataXmlTranslationMixIn
    {
        public static void WriteToXml(
            this ICombatStyleDataGetter item,
            XElement node,
            out CombatStyleData.ErrorMask errorMask,
            CombatStyleData.TranslationMask? translationMask = null,
            string? name = null)
        {
            ErrorMaskBuilder errorMaskBuilder = new ErrorMaskBuilder();
            ((CombatStyleDataXmlWriteTranslation)item.XmlWriteTranslator).Write(
                item: item,
                name: name,
                node: node,
                errorMask: errorMaskBuilder,
                translationMask: translationMask?.GetCrystal());
            errorMask = CombatStyleData.ErrorMask.Factory(errorMaskBuilder);
        }

        public static void WriteToXml(
            this ICombatStyleDataGetter item,
            string path,
            out CombatStyleData.ErrorMask errorMask,
            CombatStyleData.TranslationMask? translationMask = null,
            string? name = null)
        {
            var node = new XElement("topnode");
            WriteToXml(
                item: item,
                name: name,
                node: node,
                errorMask: out errorMask,
                translationMask: translationMask);
            node.Elements().First().SaveIfChanged(path);
        }

        public static void WriteToXml(
            this ICombatStyleDataGetter item,
            string path,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask = null,
            string? name = null)
        {
            var node = new XElement("topnode");
            WriteToXml(
                item: item,
                name: name,
                node: node,
                errorMask: errorMask,
                translationMask: translationMask);
            node.Elements().First().SaveIfChanged(path);
        }

        public static void WriteToXml(
            this ICombatStyleDataGetter item,
            Stream stream,
            out CombatStyleData.ErrorMask errorMask,
            CombatStyleData.TranslationMask? translationMask = null,
            string? name = null)
        {
            var node = new XElement("topnode");
            WriteToXml(
                item: item,
                name: name,
                node: node,
                errorMask: out errorMask,
                translationMask: translationMask);
            node.Elements().First().Save(stream);
        }

        public static void WriteToXml(
            this ICombatStyleDataGetter item,
            Stream stream,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask = null,
            string? name = null)
        {
            var node = new XElement("topnode");
            WriteToXml(
                item: item,
                name: name,
                node: node,
                errorMask: errorMask,
                translationMask: translationMask);
            node.Elements().First().Save(stream);
        }

        public static void WriteToXml(
            this ICombatStyleDataGetter item,
            XElement node,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask = null,
            string? name = null)
        {
            ((CombatStyleDataXmlWriteTranslation)item.XmlWriteTranslator).Write(
                item: item,
                name: name,
                node: node,
                errorMask: errorMask,
                translationMask: translationMask);
        }

        public static void WriteToXml(
            this ICombatStyleDataGetter item,
            XElement node,
            string? name = null,
            CombatStyleData.TranslationMask? translationMask = null)
        {
            ((CombatStyleDataXmlWriteTranslation)item.XmlWriteTranslator).Write(
                item: item,
                name: name,
                node: node,
                errorMask: null,
                translationMask: translationMask?.GetCrystal());
        }

        public static void WriteToXml(
            this ICombatStyleDataGetter item,
            string path,
            string? name = null)
        {
            var node = new XElement("topnode");
            ((CombatStyleDataXmlWriteTranslation)item.XmlWriteTranslator).Write(
                item: item,
                name: name,
                node: node,
                errorMask: null,
                translationMask: null);
            node.Elements().First().SaveIfChanged(path);
        }

        public static void WriteToXml(
            this ICombatStyleDataGetter item,
            Stream stream,
            string? name = null)
        {
            var node = new XElement("topnode");
            ((CombatStyleDataXmlWriteTranslation)item.XmlWriteTranslator).Write(
                item: item,
                name: name,
                node: node,
                errorMask: null,
                translationMask: null);
            node.Elements().First().Save(stream);
        }

    }
    #endregion


}
#endregion

#region Binary Translation
namespace Mutagen.Bethesda.Oblivion.Internals
{
    public partial class CombatStyleDataBinaryWriteTranslation : IBinaryWriteTranslator
    {
        public readonly static CombatStyleDataBinaryWriteTranslation Instance = new CombatStyleDataBinaryWriteTranslation();

        static partial void WriteBinarySecondaryFlagsCustom(
            MutagenWriter writer,
            ICombatStyleDataGetter item);

        public static void WriteBinarySecondaryFlags(
            MutagenWriter writer,
            ICombatStyleDataGetter item)
        {
            WriteBinarySecondaryFlagsCustom(
                writer: writer,
                item: item);
        }

        public static void WriteEmbedded(
            ICombatStyleDataGetter item,
            MutagenWriter writer)
        {
            writer.Write(item.DodgePercentChance);
            writer.Write(item.LeftRightPercentChance);
            writer.WriteZeros(2);
            Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.DodgeLeftRightTimerMin);
            Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.DodgeLeftRightTimerMax);
            Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.DodgeForwardTimerMin);
            Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.DodgeForwardTimerMax);
            Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.DodgeBackTimerMin);
            Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.DodgeBackTimerMax);
            Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.IdleTimerMin);
            Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.IdleTimerMax);
            writer.Write(item.BlockPercentChance);
            writer.Write(item.AttackPercentChance);
            writer.WriteZeros(2);
            Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.RecoilStaggerBonusToAttack);
            Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.UnconsciousBonusToAttack);
            Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.HandToHandBonusToAttack);
            writer.Write(item.PowerAttackPercentChance);
            writer.WriteZeros(3);
            Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.RecoilStaggerBonusToPowerAttack);
            Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.UnconsciousBonusToPowerAttack);
            writer.Write(item.PowerAttackNormal);
            writer.Write(item.PowerAttackForward);
            writer.Write(item.PowerAttackBack);
            writer.Write(item.PowerAttackLeft);
            writer.Write(item.PowerAttackRight);
            writer.WriteZeros(3);
            Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.HoldTimerMin);
            Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.HoldTimerMax);
            Mutagen.Bethesda.Binary.EnumBinaryTranslation<CombatStyle.Flag>.Instance.Write(
                writer,
                item.Flags,
                length: 1);
            writer.Write(item.AcrobaticDodgePercentChance);
            writer.WriteZeros(2);
            if (!item.Versioning.HasFlag(CombatStyleData.VersioningBreaks.Break0))
            {
                Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                    writer: writer,
                    item: item.RangeMultOptimal);
                Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                    writer: writer,
                    item: item.RangeMultMax);
                if (!item.Versioning.HasFlag(CombatStyleData.VersioningBreaks.Break1))
                {
                    Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                        writer: writer,
                        item: item.SwitchDistanceMelee);
                    Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                        writer: writer,
                        item: item.SwitchDistanceRanged);
                    Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                        writer: writer,
                        item: item.BuffStandoffDistance);
                    if (!item.Versioning.HasFlag(CombatStyleData.VersioningBreaks.Break2))
                    {
                        Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                            writer: writer,
                            item: item.RangedStandoffDistance);
                        Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                            writer: writer,
                            item: item.GroupStandoffDistance);
                        if (!item.Versioning.HasFlag(CombatStyleData.VersioningBreaks.Break3))
                        {
                            writer.Write(item.RushingAttackPercentChance);
                            writer.WriteZeros(3);
                            Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                                writer: writer,
                                item: item.RushingAttackDistanceMult);
                            if (!item.Versioning.HasFlag(CombatStyleData.VersioningBreaks.Break4))
                            {
                                CombatStyleDataBinaryWriteTranslation.WriteBinarySecondaryFlags(
                                    writer: writer,
                                    item: item);
                            }
                        }
                    }
                }
            }
        }

        public void Write(
            MutagenWriter writer,
            ICombatStyleDataGetter item,
            RecordTypeConverter? recordTypeConverter = null)
        {
            using (HeaderExport.ExportHeader(
                writer: writer,
                record: recordTypeConverter.ConvertToCustom(CombatStyleData_Registration.CSTD_HEADER),
                type: Mutagen.Bethesda.Binary.ObjectType.Subrecord))
            {
                WriteEmbedded(
                    item: item,
                    writer: writer);
            }
        }

        public void Write(
            MutagenWriter writer,
            object item,
            RecordTypeConverter? recordTypeConverter = null)
        {
            Write(
                item: (ICombatStyleDataGetter)item,
                writer: writer,
                recordTypeConverter: recordTypeConverter);
        }

    }

    public partial class CombatStyleDataBinaryCreateTranslation
    {
        public readonly static CombatStyleDataBinaryCreateTranslation Instance = new CombatStyleDataBinaryCreateTranslation();

        static partial void FillBinarySecondaryFlagsCustom(
            MutagenFrame frame,
            ICombatStyleData item);

        public static void FillBinarySecondaryFlagsCustomPublic(
            MutagenFrame frame,
            ICombatStyleData item)
        {
            FillBinarySecondaryFlagsCustom(
                frame: frame,
                item: item);
        }

    }

}
namespace Mutagen.Bethesda.Oblivion
{
    #region Binary Write Mixins
    public static class CombatStyleDataBinaryTranslationMixIn
    {
        public static void WriteToBinary(
            this ICombatStyleDataGetter item,
            MutagenWriter writer)
        {
            ((CombatStyleDataBinaryWriteTranslation)item.BinaryWriteTranslator).Write(
                item: item,
                writer: writer,
                recordTypeConverter: null);
        }

    }
    #endregion


}
namespace Mutagen.Bethesda.Oblivion.Internals
{
    public partial class CombatStyleDataBinaryOverlay :
        BinaryOverlay,
        ICombatStyleDataGetter
    {
        #region Common Routing
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILoquiRegistration ILoquiObject.Registration => CombatStyleData_Registration.Instance;
        public static CombatStyleData_Registration Registration => CombatStyleData_Registration.Instance;
        [DebuggerStepThrough]
        protected object CommonInstance() => CombatStyleDataCommon.Instance;
        [DebuggerStepThrough]
        protected object CommonSetterTranslationInstance() => CombatStyleDataSetterTranslationCommon.Instance;
        [DebuggerStepThrough]
        object ICombatStyleDataGetter.CommonInstance() => this.CommonInstance();
        [DebuggerStepThrough]
        object? ICombatStyleDataGetter.CommonSetterInstance() => null;
        [DebuggerStepThrough]
        object ICombatStyleDataGetter.CommonSetterTranslationInstance() => this.CommonSetterTranslationInstance();

        #endregion

        void IPrintable.ToString(FileGeneration fg, string? name) => this.ToString(fg, name);
        IMask<bool> ILoquiObjectGetter.GetHasBeenSetIMask() => this.GetHasBeenSetMask();
        IMask<bool> IEqualsMask.GetEqualsIMask(object rhs, EqualsMaskHelper.Include include) => this.GetEqualsMask((ICombatStyleDataGetter)rhs, include);

        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected object XmlWriteTranslator => CombatStyleDataXmlWriteTranslation.Instance;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        object IXmlItem.XmlWriteTranslator => this.XmlWriteTranslator;
        void IXmlItem.WriteToXml(
            XElement node,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask,
            string? name = null)
        {
            ((CombatStyleDataXmlWriteTranslation)this.XmlWriteTranslator).Write(
                item: this,
                name: name,
                node: node,
                errorMask: errorMask,
                translationMask: translationMask);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected object BinaryWriteTranslator => CombatStyleDataBinaryWriteTranslation.Instance;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        object IBinaryItem.BinaryWriteTranslator => this.BinaryWriteTranslator;
        void IBinaryItem.WriteToBinary(
            MutagenWriter writer,
            RecordTypeConverter? recordTypeConverter = null)
        {
            ((CombatStyleDataBinaryWriteTranslation)this.BinaryWriteTranslator).Write(
                item: this,
                writer: writer,
                recordTypeConverter: recordTypeConverter);
        }

        public CombatStyleData.VersioningBreaks Versioning { get; private set; }
        public Byte DodgePercentChance => _data.Span[0x0];
        public Byte LeftRightPercentChance => _data.Span[0x1];
        public Single DodgeLeftRightTimerMin => SpanExt.GetFloat(_data.Slice(0x4, 0x4));
        public Single DodgeLeftRightTimerMax => SpanExt.GetFloat(_data.Slice(0x8, 0x4));
        public Single DodgeForwardTimerMin => SpanExt.GetFloat(_data.Slice(0xC, 0x4));
        public Single DodgeForwardTimerMax => SpanExt.GetFloat(_data.Slice(0x10, 0x4));
        public Single DodgeBackTimerMin => SpanExt.GetFloat(_data.Slice(0x14, 0x4));
        public Single DodgeBackTimerMax => SpanExt.GetFloat(_data.Slice(0x18, 0x4));
        public Single IdleTimerMin => SpanExt.GetFloat(_data.Slice(0x1C, 0x4));
        public Single IdleTimerMax => SpanExt.GetFloat(_data.Slice(0x20, 0x4));
        public Byte BlockPercentChance => _data.Span[0x24];
        public Byte AttackPercentChance => _data.Span[0x25];
        public Single RecoilStaggerBonusToAttack => SpanExt.GetFloat(_data.Slice(0x28, 0x4));
        public Single UnconsciousBonusToAttack => SpanExt.GetFloat(_data.Slice(0x2C, 0x4));
        public Single HandToHandBonusToAttack => SpanExt.GetFloat(_data.Slice(0x30, 0x4));
        public Byte PowerAttackPercentChance => _data.Span[0x34];
        public Single RecoilStaggerBonusToPowerAttack => SpanExt.GetFloat(_data.Slice(0x38, 0x4));
        public Single UnconsciousBonusToPowerAttack => SpanExt.GetFloat(_data.Slice(0x3C, 0x4));
        public Byte PowerAttackNormal => _data.Span[0x40];
        public Byte PowerAttackForward => _data.Span[0x41];
        public Byte PowerAttackBack => _data.Span[0x42];
        public Byte PowerAttackLeft => _data.Span[0x43];
        public Byte PowerAttackRight => _data.Span[0x44];
        public Single HoldTimerMin => SpanExt.GetFloat(_data.Slice(0x48, 0x4));
        public Single HoldTimerMax => SpanExt.GetFloat(_data.Slice(0x4C, 0x4));
        public CombatStyle.Flag Flags => GetFlagsCustom(location: 0x50);
        public Byte AcrobaticDodgePercentChance => _data.Span[0x51];
        public Single RangeMultOptimal => SpanExt.GetFloat(_data.Slice(0x54, 0x4));
        public Single RangeMultMax => SpanExt.GetFloat(_data.Slice(0x58, 0x4));
        public Single SwitchDistanceMelee => SpanExt.GetFloat(_data.Slice(0x5C, 0x4));
        public Single SwitchDistanceRanged => SpanExt.GetFloat(_data.Slice(0x60, 0x4));
        public Single BuffStandoffDistance => SpanExt.GetFloat(_data.Slice(0x64, 0x4));
        public Single RangedStandoffDistance => SpanExt.GetFloat(_data.Slice(0x68, 0x4));
        public Single GroupStandoffDistance => SpanExt.GetFloat(_data.Slice(0x6C, 0x4));
        public Byte RushingAttackPercentChance => _data.Span[0x70];
        public Single RushingAttackDistanceMult => SpanExt.GetFloat(_data.Slice(0x74, 0x4));
        #region SecondaryFlags
        partial void SecondaryFlagsCustomParse(
            BinaryMemoryReadStream stream,
            int offset);
        #endregion
        partial void CustomCtor(
            BinaryMemoryReadStream stream,
            int finalPos,
            int offset);

        protected CombatStyleDataBinaryOverlay(
            ReadOnlyMemorySlice<byte> bytes,
            BinaryOverlayFactoryPackage package)
            : base(
                bytes: bytes,
                package: package)
        {
        }

        public static CombatStyleDataBinaryOverlay CombatStyleDataFactory(
            BinaryMemoryReadStream stream,
            BinaryOverlayFactoryPackage package,
            RecordTypeConverter? recordTypeConverter = null)
        {
            var ret = new CombatStyleDataBinaryOverlay(
                bytes: HeaderTranslation.ExtractSubrecordMemory(stream.RemainingMemory, package.MetaData.Constants),
                package: package);
            var finalPos = checked((int)(stream.Position + package.MetaData.Constants.Subrecord(stream.RemainingSpan).TotalLength));
            int offset = stream.Position + package.MetaData.Constants.SubConstants.TypeAndLengthLength;
            if (ret._data.Length <= 0x54)
            {
                ret.Versioning |= CombatStyleData.VersioningBreaks.Break0;
            }
            if (ret._data.Length <= 0x5C)
            {
                ret.Versioning |= CombatStyleData.VersioningBreaks.Break1;
            }
            if (ret._data.Length <= 0x68)
            {
                ret.Versioning |= CombatStyleData.VersioningBreaks.Break2;
            }
            if (ret._data.Length <= 0x70)
            {
                ret.Versioning |= CombatStyleData.VersioningBreaks.Break3;
            }
            if (ret._data.Length <= 0x78)
            {
                ret.Versioning |= CombatStyleData.VersioningBreaks.Break4;
            }
            ret.CustomCtor(
                stream: stream,
                finalPos: stream.Length,
                offset: offset);
            return ret;
        }

        public static CombatStyleDataBinaryOverlay CombatStyleDataFactory(
            ReadOnlyMemorySlice<byte> slice,
            BinaryOverlayFactoryPackage package,
            RecordTypeConverter? recordTypeConverter = null)
        {
            return CombatStyleDataFactory(
                stream: new BinaryMemoryReadStream(slice),
                package: package,
                recordTypeConverter: recordTypeConverter);
        }

        #region To String

        public void ToString(
            FileGeneration fg,
            string? name = null)
        {
            CombatStyleDataMixIn.ToString(
                item: this,
                name: name);
        }

        #endregion

    }

}
#endregion

#endregion

