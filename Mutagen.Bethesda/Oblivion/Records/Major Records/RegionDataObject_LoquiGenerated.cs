/*
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
 * Autogenerated by Loqui.  Do not manually change.
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
*/
#region Usings
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Loqui;
using Loqui.Internal;
using Noggog;
using Mutagen.Bethesda.Oblivion.Internals;
using System.Reactive.Disposables;
using System.Reactive.Linq;
using System.Xml;
using System.Xml.Linq;
using System.IO;
using Noggog.Xml;
using Loqui.Xml;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using Mutagen.Bethesda.Binary;
using System.Buffers.Binary;
using Mutagen.Bethesda.Internals;
#endregion

#nullable enable
namespace Mutagen.Bethesda.Oblivion
{
    #region Class
    public partial class RegionDataObject :
        IRegionDataObject,
        ILoquiObjectSetter<RegionDataObject>,
        IEquatable<RegionDataObject>,
        IEqualsMask
    {
        #region Ctor
        public RegionDataObject()
        {
            CustomCtor();
        }
        partial void CustomCtor();
        #endregion

        #region Object
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected IFormLink<OblivionMajorRecord> _Object = new FormLink<OblivionMajorRecord>();
        public IFormLink<OblivionMajorRecord> Object => this._Object;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkGetter<IOblivionMajorRecordGetter> IRegionDataObjectGetter.Object => this.Object;
        #endregion
        #region ParentIndex
        public UInt16 ParentIndex { get; set; } = default;
        #endregion
        #region Unknown1
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private Byte[] _Unknown1 = new byte[2];
        public Byte[] Unknown1
        {
            get => _Unknown1;
            set => this._Unknown1 = value ?? new byte[2];
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ReadOnlyMemorySlice<Byte> IRegionDataObjectGetter.Unknown1 => this.Unknown1;
        #endregion
        #region Density
        public Single Density { get; set; } = default;
        #endregion
        #region Clustering
        public Byte Clustering { get; set; } = default;
        #endregion
        #region MinSlope
        public Byte MinSlope { get; set; } = default;
        #endregion
        #region MaxSlope
        public Byte MaxSlope { get; set; } = default;
        #endregion
        #region Flags
        public RegionDataObject.Flag Flags { get; set; } = default;
        #endregion
        #region RadiusWrtPercent
        public UInt16 RadiusWrtPercent { get; set; } = default;
        #endregion
        #region Radius
        public UInt16 Radius { get; set; } = default;
        #endregion
        #region MinHeight
        public Single MinHeight { get; set; } = default;
        #endregion
        #region MaxHeight
        public Single MaxHeight { get; set; } = default;
        #endregion
        #region Sink
        public Single Sink { get; set; } = default;
        #endregion
        #region SinkVariance
        public Single SinkVariance { get; set; } = default;
        #endregion
        #region SizeVariance
        public Single SizeVariance { get; set; } = default;
        #endregion
        #region AngleVariance
        public P3UInt16 AngleVariance { get; set; } = default;
        #endregion
        #region Unknown2
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private Byte[] _Unknown2 = new byte[6];
        public Byte[] Unknown2
        {
            get => _Unknown2;
            set => this._Unknown2 = value ?? new byte[6];
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ReadOnlyMemorySlice<Byte> IRegionDataObjectGetter.Unknown2 => this.Unknown2;
        #endregion

        #region To String

        public void ToString(
            FileGeneration fg,
            string? name = null)
        {
            RegionDataObjectMixIn.ToString(
                item: this,
                name: name);
        }

        #endregion

        #region Equals and Hash
        public override bool Equals(object? obj)
        {
            if (!(obj is IRegionDataObjectGetter rhs)) return false;
            return ((RegionDataObjectCommon)((IRegionDataObjectGetter)this).CommonInstance()!).Equals(this, rhs);
        }

        public bool Equals(RegionDataObject obj)
        {
            return ((RegionDataObjectCommon)((IRegionDataObjectGetter)this).CommonInstance()!).Equals(this, obj);
        }

        public override int GetHashCode() => ((RegionDataObjectCommon)((IRegionDataObjectGetter)this).CommonInstance()!).GetHashCode(this);

        #endregion

        #region Xml Translation
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected object XmlWriteTranslator => RegionDataObjectXmlWriteTranslation.Instance;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        object IXmlItem.XmlWriteTranslator => this.XmlWriteTranslator;
        void IXmlItem.WriteToXml(
            XElement node,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask,
            string? name = null)
        {
            ((RegionDataObjectXmlWriteTranslation)this.XmlWriteTranslator).Write(
                item: this,
                name: name,
                node: node,
                errorMask: errorMask,
                translationMask: translationMask);
        }
        #region Xml Create
        [DebuggerStepThrough]
        public static RegionDataObject CreateFromXml(
            XElement node,
            RegionDataObject.TranslationMask? translationMask = null)
        {
            return CreateFromXml(
                node: node,
                errorMask: null,
                translationMask: translationMask?.GetCrystal());
        }

        [DebuggerStepThrough]
        public static RegionDataObject CreateFromXml(
            XElement node,
            out RegionDataObject.ErrorMask errorMask,
            RegionDataObject.TranslationMask? translationMask = null)
        {
            ErrorMaskBuilder errorMaskBuilder = new ErrorMaskBuilder();
            var ret = CreateFromXml(
                node: node,
                errorMask: errorMaskBuilder,
                translationMask: translationMask?.GetCrystal());
            errorMask = RegionDataObject.ErrorMask.Factory(errorMaskBuilder);
            return ret;
        }

        public static RegionDataObject CreateFromXml(
            XElement node,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask)
        {
            var ret = new RegionDataObject();
            ((RegionDataObjectSetterCommon)((IRegionDataObjectGetter)ret).CommonSetterInstance()!).CopyInFromXml(
                item: ret,
                node: node,
                errorMask: errorMask,
                translationMask: translationMask);
            return ret;
        }

        public static RegionDataObject CreateFromXml(
            string path,
            RegionDataObject.TranslationMask? translationMask = null)
        {
            var node = XDocument.Load(path).Root;
            return CreateFromXml(
                node: node,
                translationMask: translationMask);
        }

        public static RegionDataObject CreateFromXml(
            string path,
            out RegionDataObject.ErrorMask errorMask,
            RegionDataObject.TranslationMask? translationMask = null)
        {
            var node = XDocument.Load(path).Root;
            return CreateFromXml(
                node: node,
                errorMask: out errorMask,
                translationMask: translationMask);
        }

        public static RegionDataObject CreateFromXml(
            string path,
            ErrorMaskBuilder? errorMask,
            RegionDataObject.TranslationMask? translationMask = null)
        {
            var node = XDocument.Load(path).Root;
            return CreateFromXml(
                node: node,
                errorMask: errorMask,
                translationMask: translationMask?.GetCrystal());
        }

        public static RegionDataObject CreateFromXml(
            Stream stream,
            RegionDataObject.TranslationMask? translationMask = null)
        {
            var node = XDocument.Load(stream).Root;
            return CreateFromXml(
                node: node,
                translationMask: translationMask);
        }

        public static RegionDataObject CreateFromXml(
            Stream stream,
            out RegionDataObject.ErrorMask errorMask,
            RegionDataObject.TranslationMask? translationMask = null)
        {
            var node = XDocument.Load(stream).Root;
            return CreateFromXml(
                node: node,
                errorMask: out errorMask,
                translationMask: translationMask);
        }

        public static RegionDataObject CreateFromXml(
            Stream stream,
            ErrorMaskBuilder? errorMask,
            RegionDataObject.TranslationMask? translationMask = null)
        {
            var node = XDocument.Load(stream).Root;
            return CreateFromXml(
                node: node,
                errorMask: errorMask,
                translationMask: translationMask?.GetCrystal());
        }

        #endregion

        #endregion

        #region Mask
        public class Mask<TItem> :
            IMask<TItem>,
            IEquatable<Mask<TItem>>
            where TItem : notnull
        {
            #region Ctors
            public Mask(TItem initialValue)
            {
                this.Object = initialValue;
                this.ParentIndex = initialValue;
                this.Unknown1 = initialValue;
                this.Density = initialValue;
                this.Clustering = initialValue;
                this.MinSlope = initialValue;
                this.MaxSlope = initialValue;
                this.Flags = initialValue;
                this.RadiusWrtPercent = initialValue;
                this.Radius = initialValue;
                this.MinHeight = initialValue;
                this.MaxHeight = initialValue;
                this.Sink = initialValue;
                this.SinkVariance = initialValue;
                this.SizeVariance = initialValue;
                this.AngleVariance = initialValue;
                this.Unknown2 = initialValue;
            }

            public Mask(
                TItem Object,
                TItem ParentIndex,
                TItem Unknown1,
                TItem Density,
                TItem Clustering,
                TItem MinSlope,
                TItem MaxSlope,
                TItem Flags,
                TItem RadiusWrtPercent,
                TItem Radius,
                TItem MinHeight,
                TItem MaxHeight,
                TItem Sink,
                TItem SinkVariance,
                TItem SizeVariance,
                TItem AngleVariance,
                TItem Unknown2)
            {
                this.Object = Object;
                this.ParentIndex = ParentIndex;
                this.Unknown1 = Unknown1;
                this.Density = Density;
                this.Clustering = Clustering;
                this.MinSlope = MinSlope;
                this.MaxSlope = MaxSlope;
                this.Flags = Flags;
                this.RadiusWrtPercent = RadiusWrtPercent;
                this.Radius = Radius;
                this.MinHeight = MinHeight;
                this.MaxHeight = MaxHeight;
                this.Sink = Sink;
                this.SinkVariance = SinkVariance;
                this.SizeVariance = SizeVariance;
                this.AngleVariance = AngleVariance;
                this.Unknown2 = Unknown2;
            }

            #pragma warning disable CS8618
            protected Mask()
            {
            }
            #pragma warning restore CS8618

            #endregion

            #region Members
            public TItem Object;
            public TItem ParentIndex;
            public TItem Unknown1;
            public TItem Density;
            public TItem Clustering;
            public TItem MinSlope;
            public TItem MaxSlope;
            public TItem Flags;
            public TItem RadiusWrtPercent;
            public TItem Radius;
            public TItem MinHeight;
            public TItem MaxHeight;
            public TItem Sink;
            public TItem SinkVariance;
            public TItem SizeVariance;
            public TItem AngleVariance;
            public TItem Unknown2;
            #endregion

            #region Equals
            public override bool Equals(object? obj)
            {
                if (!(obj is Mask<TItem> rhs)) return false;
                return Equals(rhs);
            }

            public bool Equals(Mask<TItem> rhs)
            {
                if (rhs == null) return false;
                if (!object.Equals(this.Object, rhs.Object)) return false;
                if (!object.Equals(this.ParentIndex, rhs.ParentIndex)) return false;
                if (!object.Equals(this.Unknown1, rhs.Unknown1)) return false;
                if (!object.Equals(this.Density, rhs.Density)) return false;
                if (!object.Equals(this.Clustering, rhs.Clustering)) return false;
                if (!object.Equals(this.MinSlope, rhs.MinSlope)) return false;
                if (!object.Equals(this.MaxSlope, rhs.MaxSlope)) return false;
                if (!object.Equals(this.Flags, rhs.Flags)) return false;
                if (!object.Equals(this.RadiusWrtPercent, rhs.RadiusWrtPercent)) return false;
                if (!object.Equals(this.Radius, rhs.Radius)) return false;
                if (!object.Equals(this.MinHeight, rhs.MinHeight)) return false;
                if (!object.Equals(this.MaxHeight, rhs.MaxHeight)) return false;
                if (!object.Equals(this.Sink, rhs.Sink)) return false;
                if (!object.Equals(this.SinkVariance, rhs.SinkVariance)) return false;
                if (!object.Equals(this.SizeVariance, rhs.SizeVariance)) return false;
                if (!object.Equals(this.AngleVariance, rhs.AngleVariance)) return false;
                if (!object.Equals(this.Unknown2, rhs.Unknown2)) return false;
                return true;
            }
            public override int GetHashCode()
            {
                var hash = new HashCode();
                hash.Add(this.Object);
                hash.Add(this.ParentIndex);
                hash.Add(this.Unknown1);
                hash.Add(this.Density);
                hash.Add(this.Clustering);
                hash.Add(this.MinSlope);
                hash.Add(this.MaxSlope);
                hash.Add(this.Flags);
                hash.Add(this.RadiusWrtPercent);
                hash.Add(this.Radius);
                hash.Add(this.MinHeight);
                hash.Add(this.MaxHeight);
                hash.Add(this.Sink);
                hash.Add(this.SinkVariance);
                hash.Add(this.SizeVariance);
                hash.Add(this.AngleVariance);
                hash.Add(this.Unknown2);
                return hash.ToHashCode();
            }

            #endregion

            #region All
            public bool All(Func<TItem, bool> eval)
            {
                if (!eval(this.Object)) return false;
                if (!eval(this.ParentIndex)) return false;
                if (!eval(this.Unknown1)) return false;
                if (!eval(this.Density)) return false;
                if (!eval(this.Clustering)) return false;
                if (!eval(this.MinSlope)) return false;
                if (!eval(this.MaxSlope)) return false;
                if (!eval(this.Flags)) return false;
                if (!eval(this.RadiusWrtPercent)) return false;
                if (!eval(this.Radius)) return false;
                if (!eval(this.MinHeight)) return false;
                if (!eval(this.MaxHeight)) return false;
                if (!eval(this.Sink)) return false;
                if (!eval(this.SinkVariance)) return false;
                if (!eval(this.SizeVariance)) return false;
                if (!eval(this.AngleVariance)) return false;
                if (!eval(this.Unknown2)) return false;
                return true;
            }
            #endregion

            #region Any
            public bool Any(Func<TItem, bool> eval)
            {
                if (eval(this.Object)) return true;
                if (eval(this.ParentIndex)) return true;
                if (eval(this.Unknown1)) return true;
                if (eval(this.Density)) return true;
                if (eval(this.Clustering)) return true;
                if (eval(this.MinSlope)) return true;
                if (eval(this.MaxSlope)) return true;
                if (eval(this.Flags)) return true;
                if (eval(this.RadiusWrtPercent)) return true;
                if (eval(this.Radius)) return true;
                if (eval(this.MinHeight)) return true;
                if (eval(this.MaxHeight)) return true;
                if (eval(this.Sink)) return true;
                if (eval(this.SinkVariance)) return true;
                if (eval(this.SizeVariance)) return true;
                if (eval(this.AngleVariance)) return true;
                if (eval(this.Unknown2)) return true;
                return false;
            }
            #endregion

            #region Translate
            public Mask<R> Translate<R>(Func<TItem, R> eval)
            {
                var ret = new RegionDataObject.Mask<R>();
                this.Translate_InternalFill(ret, eval);
                return ret;
            }

            protected void Translate_InternalFill<R>(Mask<R> obj, Func<TItem, R> eval)
            {
                obj.Object = eval(this.Object);
                obj.ParentIndex = eval(this.ParentIndex);
                obj.Unknown1 = eval(this.Unknown1);
                obj.Density = eval(this.Density);
                obj.Clustering = eval(this.Clustering);
                obj.MinSlope = eval(this.MinSlope);
                obj.MaxSlope = eval(this.MaxSlope);
                obj.Flags = eval(this.Flags);
                obj.RadiusWrtPercent = eval(this.RadiusWrtPercent);
                obj.Radius = eval(this.Radius);
                obj.MinHeight = eval(this.MinHeight);
                obj.MaxHeight = eval(this.MaxHeight);
                obj.Sink = eval(this.Sink);
                obj.SinkVariance = eval(this.SinkVariance);
                obj.SizeVariance = eval(this.SizeVariance);
                obj.AngleVariance = eval(this.AngleVariance);
                obj.Unknown2 = eval(this.Unknown2);
            }
            #endregion

            #region To String
            public override string ToString()
            {
                return ToString(printMask: null);
            }

            public string ToString(RegionDataObject.Mask<bool>? printMask = null)
            {
                var fg = new FileGeneration();
                ToString(fg, printMask);
                return fg.ToString();
            }

            public void ToString(FileGeneration fg, RegionDataObject.Mask<bool>? printMask = null)
            {
                fg.AppendLine($"{nameof(RegionDataObject.Mask<TItem>)} =>");
                fg.AppendLine("[");
                using (new DepthWrapper(fg))
                {
                    if (printMask?.Object ?? true)
                    {
                        fg.AppendItem(Object, "Object");
                    }
                    if (printMask?.ParentIndex ?? true)
                    {
                        fg.AppendItem(ParentIndex, "ParentIndex");
                    }
                    if (printMask?.Unknown1 ?? true)
                    {
                        fg.AppendItem(Unknown1, "Unknown1");
                    }
                    if (printMask?.Density ?? true)
                    {
                        fg.AppendItem(Density, "Density");
                    }
                    if (printMask?.Clustering ?? true)
                    {
                        fg.AppendItem(Clustering, "Clustering");
                    }
                    if (printMask?.MinSlope ?? true)
                    {
                        fg.AppendItem(MinSlope, "MinSlope");
                    }
                    if (printMask?.MaxSlope ?? true)
                    {
                        fg.AppendItem(MaxSlope, "MaxSlope");
                    }
                    if (printMask?.Flags ?? true)
                    {
                        fg.AppendItem(Flags, "Flags");
                    }
                    if (printMask?.RadiusWrtPercent ?? true)
                    {
                        fg.AppendItem(RadiusWrtPercent, "RadiusWrtPercent");
                    }
                    if (printMask?.Radius ?? true)
                    {
                        fg.AppendItem(Radius, "Radius");
                    }
                    if (printMask?.MinHeight ?? true)
                    {
                        fg.AppendItem(MinHeight, "MinHeight");
                    }
                    if (printMask?.MaxHeight ?? true)
                    {
                        fg.AppendItem(MaxHeight, "MaxHeight");
                    }
                    if (printMask?.Sink ?? true)
                    {
                        fg.AppendItem(Sink, "Sink");
                    }
                    if (printMask?.SinkVariance ?? true)
                    {
                        fg.AppendItem(SinkVariance, "SinkVariance");
                    }
                    if (printMask?.SizeVariance ?? true)
                    {
                        fg.AppendItem(SizeVariance, "SizeVariance");
                    }
                    if (printMask?.AngleVariance ?? true)
                    {
                        fg.AppendItem(AngleVariance, "AngleVariance");
                    }
                    if (printMask?.Unknown2 ?? true)
                    {
                        fg.AppendItem(Unknown2, "Unknown2");
                    }
                }
                fg.AppendLine("]");
            }
            #endregion

        }

        public class ErrorMask :
            IErrorMask,
            IErrorMask<ErrorMask>
        {
            #region Members
            public Exception? Overall { get; set; }
            private List<string>? _warnings;
            public List<string> Warnings
            {
                get
                {
                    if (_warnings == null)
                    {
                        _warnings = new List<string>();
                    }
                    return _warnings;
                }
            }
            public Exception? Object;
            public Exception? ParentIndex;
            public Exception? Unknown1;
            public Exception? Density;
            public Exception? Clustering;
            public Exception? MinSlope;
            public Exception? MaxSlope;
            public Exception? Flags;
            public Exception? RadiusWrtPercent;
            public Exception? Radius;
            public Exception? MinHeight;
            public Exception? MaxHeight;
            public Exception? Sink;
            public Exception? SinkVariance;
            public Exception? SizeVariance;
            public Exception? AngleVariance;
            public Exception? Unknown2;
            #endregion

            #region IErrorMask
            public object? GetNthMask(int index)
            {
                RegionDataObject_FieldIndex enu = (RegionDataObject_FieldIndex)index;
                switch (enu)
                {
                    case RegionDataObject_FieldIndex.Object:
                        return Object;
                    case RegionDataObject_FieldIndex.ParentIndex:
                        return ParentIndex;
                    case RegionDataObject_FieldIndex.Unknown1:
                        return Unknown1;
                    case RegionDataObject_FieldIndex.Density:
                        return Density;
                    case RegionDataObject_FieldIndex.Clustering:
                        return Clustering;
                    case RegionDataObject_FieldIndex.MinSlope:
                        return MinSlope;
                    case RegionDataObject_FieldIndex.MaxSlope:
                        return MaxSlope;
                    case RegionDataObject_FieldIndex.Flags:
                        return Flags;
                    case RegionDataObject_FieldIndex.RadiusWrtPercent:
                        return RadiusWrtPercent;
                    case RegionDataObject_FieldIndex.Radius:
                        return Radius;
                    case RegionDataObject_FieldIndex.MinHeight:
                        return MinHeight;
                    case RegionDataObject_FieldIndex.MaxHeight:
                        return MaxHeight;
                    case RegionDataObject_FieldIndex.Sink:
                        return Sink;
                    case RegionDataObject_FieldIndex.SinkVariance:
                        return SinkVariance;
                    case RegionDataObject_FieldIndex.SizeVariance:
                        return SizeVariance;
                    case RegionDataObject_FieldIndex.AngleVariance:
                        return AngleVariance;
                    case RegionDataObject_FieldIndex.Unknown2:
                        return Unknown2;
                    default:
                        throw new ArgumentException($"Index is out of range: {index}");
                }
            }

            public void SetNthException(int index, Exception ex)
            {
                RegionDataObject_FieldIndex enu = (RegionDataObject_FieldIndex)index;
                switch (enu)
                {
                    case RegionDataObject_FieldIndex.Object:
                        this.Object = ex;
                        break;
                    case RegionDataObject_FieldIndex.ParentIndex:
                        this.ParentIndex = ex;
                        break;
                    case RegionDataObject_FieldIndex.Unknown1:
                        this.Unknown1 = ex;
                        break;
                    case RegionDataObject_FieldIndex.Density:
                        this.Density = ex;
                        break;
                    case RegionDataObject_FieldIndex.Clustering:
                        this.Clustering = ex;
                        break;
                    case RegionDataObject_FieldIndex.MinSlope:
                        this.MinSlope = ex;
                        break;
                    case RegionDataObject_FieldIndex.MaxSlope:
                        this.MaxSlope = ex;
                        break;
                    case RegionDataObject_FieldIndex.Flags:
                        this.Flags = ex;
                        break;
                    case RegionDataObject_FieldIndex.RadiusWrtPercent:
                        this.RadiusWrtPercent = ex;
                        break;
                    case RegionDataObject_FieldIndex.Radius:
                        this.Radius = ex;
                        break;
                    case RegionDataObject_FieldIndex.MinHeight:
                        this.MinHeight = ex;
                        break;
                    case RegionDataObject_FieldIndex.MaxHeight:
                        this.MaxHeight = ex;
                        break;
                    case RegionDataObject_FieldIndex.Sink:
                        this.Sink = ex;
                        break;
                    case RegionDataObject_FieldIndex.SinkVariance:
                        this.SinkVariance = ex;
                        break;
                    case RegionDataObject_FieldIndex.SizeVariance:
                        this.SizeVariance = ex;
                        break;
                    case RegionDataObject_FieldIndex.AngleVariance:
                        this.AngleVariance = ex;
                        break;
                    case RegionDataObject_FieldIndex.Unknown2:
                        this.Unknown2 = ex;
                        break;
                    default:
                        throw new ArgumentException($"Index is out of range: {index}");
                }
            }

            public void SetNthMask(int index, object obj)
            {
                RegionDataObject_FieldIndex enu = (RegionDataObject_FieldIndex)index;
                switch (enu)
                {
                    case RegionDataObject_FieldIndex.Object:
                        this.Object = (Exception?)obj;
                        break;
                    case RegionDataObject_FieldIndex.ParentIndex:
                        this.ParentIndex = (Exception?)obj;
                        break;
                    case RegionDataObject_FieldIndex.Unknown1:
                        this.Unknown1 = (Exception?)obj;
                        break;
                    case RegionDataObject_FieldIndex.Density:
                        this.Density = (Exception?)obj;
                        break;
                    case RegionDataObject_FieldIndex.Clustering:
                        this.Clustering = (Exception?)obj;
                        break;
                    case RegionDataObject_FieldIndex.MinSlope:
                        this.MinSlope = (Exception?)obj;
                        break;
                    case RegionDataObject_FieldIndex.MaxSlope:
                        this.MaxSlope = (Exception?)obj;
                        break;
                    case RegionDataObject_FieldIndex.Flags:
                        this.Flags = (Exception?)obj;
                        break;
                    case RegionDataObject_FieldIndex.RadiusWrtPercent:
                        this.RadiusWrtPercent = (Exception?)obj;
                        break;
                    case RegionDataObject_FieldIndex.Radius:
                        this.Radius = (Exception?)obj;
                        break;
                    case RegionDataObject_FieldIndex.MinHeight:
                        this.MinHeight = (Exception?)obj;
                        break;
                    case RegionDataObject_FieldIndex.MaxHeight:
                        this.MaxHeight = (Exception?)obj;
                        break;
                    case RegionDataObject_FieldIndex.Sink:
                        this.Sink = (Exception?)obj;
                        break;
                    case RegionDataObject_FieldIndex.SinkVariance:
                        this.SinkVariance = (Exception?)obj;
                        break;
                    case RegionDataObject_FieldIndex.SizeVariance:
                        this.SizeVariance = (Exception?)obj;
                        break;
                    case RegionDataObject_FieldIndex.AngleVariance:
                        this.AngleVariance = (Exception?)obj;
                        break;
                    case RegionDataObject_FieldIndex.Unknown2:
                        this.Unknown2 = (Exception?)obj;
                        break;
                    default:
                        throw new ArgumentException($"Index is out of range: {index}");
                }
            }

            public bool IsInError()
            {
                if (Overall != null) return true;
                if (Object != null) return true;
                if (ParentIndex != null) return true;
                if (Unknown1 != null) return true;
                if (Density != null) return true;
                if (Clustering != null) return true;
                if (MinSlope != null) return true;
                if (MaxSlope != null) return true;
                if (Flags != null) return true;
                if (RadiusWrtPercent != null) return true;
                if (Radius != null) return true;
                if (MinHeight != null) return true;
                if (MaxHeight != null) return true;
                if (Sink != null) return true;
                if (SinkVariance != null) return true;
                if (SizeVariance != null) return true;
                if (AngleVariance != null) return true;
                if (Unknown2 != null) return true;
                return false;
            }
            #endregion

            #region To String
            public override string ToString()
            {
                var fg = new FileGeneration();
                ToString(fg, null);
                return fg.ToString();
            }

            public void ToString(FileGeneration fg, string? name = null)
            {
                fg.AppendLine($"{(name ?? "ErrorMask")} =>");
                fg.AppendLine("[");
                using (new DepthWrapper(fg))
                {
                    if (this.Overall != null)
                    {
                        fg.AppendLine("Overall =>");
                        fg.AppendLine("[");
                        using (new DepthWrapper(fg))
                        {
                            fg.AppendLine($"{this.Overall}");
                        }
                        fg.AppendLine("]");
                    }
                    ToString_FillInternal(fg);
                }
                fg.AppendLine("]");
            }
            protected void ToString_FillInternal(FileGeneration fg)
            {
                fg.AppendItem(Object, "Object");
                fg.AppendItem(ParentIndex, "ParentIndex");
                fg.AppendItem(Unknown1, "Unknown1");
                fg.AppendItem(Density, "Density");
                fg.AppendItem(Clustering, "Clustering");
                fg.AppendItem(MinSlope, "MinSlope");
                fg.AppendItem(MaxSlope, "MaxSlope");
                fg.AppendItem(Flags, "Flags");
                fg.AppendItem(RadiusWrtPercent, "RadiusWrtPercent");
                fg.AppendItem(Radius, "Radius");
                fg.AppendItem(MinHeight, "MinHeight");
                fg.AppendItem(MaxHeight, "MaxHeight");
                fg.AppendItem(Sink, "Sink");
                fg.AppendItem(SinkVariance, "SinkVariance");
                fg.AppendItem(SizeVariance, "SizeVariance");
                fg.AppendItem(AngleVariance, "AngleVariance");
                fg.AppendItem(Unknown2, "Unknown2");
            }
            #endregion

            #region Combine
            public ErrorMask Combine(ErrorMask? rhs)
            {
                if (rhs == null) return this;
                var ret = new ErrorMask();
                ret.Object = this.Object.Combine(rhs.Object);
                ret.ParentIndex = this.ParentIndex.Combine(rhs.ParentIndex);
                ret.Unknown1 = this.Unknown1.Combine(rhs.Unknown1);
                ret.Density = this.Density.Combine(rhs.Density);
                ret.Clustering = this.Clustering.Combine(rhs.Clustering);
                ret.MinSlope = this.MinSlope.Combine(rhs.MinSlope);
                ret.MaxSlope = this.MaxSlope.Combine(rhs.MaxSlope);
                ret.Flags = this.Flags.Combine(rhs.Flags);
                ret.RadiusWrtPercent = this.RadiusWrtPercent.Combine(rhs.RadiusWrtPercent);
                ret.Radius = this.Radius.Combine(rhs.Radius);
                ret.MinHeight = this.MinHeight.Combine(rhs.MinHeight);
                ret.MaxHeight = this.MaxHeight.Combine(rhs.MaxHeight);
                ret.Sink = this.Sink.Combine(rhs.Sink);
                ret.SinkVariance = this.SinkVariance.Combine(rhs.SinkVariance);
                ret.SizeVariance = this.SizeVariance.Combine(rhs.SizeVariance);
                ret.AngleVariance = this.AngleVariance.Combine(rhs.AngleVariance);
                ret.Unknown2 = this.Unknown2.Combine(rhs.Unknown2);
                return ret;
            }
            public static ErrorMask? Combine(ErrorMask? lhs, ErrorMask? rhs)
            {
                if (lhs != null && rhs != null) return lhs.Combine(rhs);
                return lhs ?? rhs;
            }
            #endregion

            #region Factory
            public static ErrorMask Factory(ErrorMaskBuilder errorMask)
            {
                return new ErrorMask();
            }
            #endregion

        }
        public class TranslationMask : ITranslationMask
        {
            #region Members
            private TranslationCrystal? _crystal;
            public bool Object;
            public bool ParentIndex;
            public bool Unknown1;
            public bool Density;
            public bool Clustering;
            public bool MinSlope;
            public bool MaxSlope;
            public bool Flags;
            public bool RadiusWrtPercent;
            public bool Radius;
            public bool MinHeight;
            public bool MaxHeight;
            public bool Sink;
            public bool SinkVariance;
            public bool SizeVariance;
            public bool AngleVariance;
            public bool Unknown2;
            #endregion

            #region Ctors
            public TranslationMask(bool defaultOn)
            {
                this.Object = defaultOn;
                this.ParentIndex = defaultOn;
                this.Unknown1 = defaultOn;
                this.Density = defaultOn;
                this.Clustering = defaultOn;
                this.MinSlope = defaultOn;
                this.MaxSlope = defaultOn;
                this.Flags = defaultOn;
                this.RadiusWrtPercent = defaultOn;
                this.Radius = defaultOn;
                this.MinHeight = defaultOn;
                this.MaxHeight = defaultOn;
                this.Sink = defaultOn;
                this.SinkVariance = defaultOn;
                this.SizeVariance = defaultOn;
                this.AngleVariance = defaultOn;
                this.Unknown2 = defaultOn;
            }

            #endregion

            public TranslationCrystal GetCrystal()
            {
                if (_crystal != null) return _crystal;
                var ret = new List<(bool On, TranslationCrystal? SubCrystal)>();
                GetCrystal(ret);
                _crystal = new TranslationCrystal(ret.ToArray());
                return _crystal;
            }

            protected void GetCrystal(List<(bool On, TranslationCrystal? SubCrystal)> ret)
            {
                ret.Add((Object, null));
                ret.Add((ParentIndex, null));
                ret.Add((Unknown1, null));
                ret.Add((Density, null));
                ret.Add((Clustering, null));
                ret.Add((MinSlope, null));
                ret.Add((MaxSlope, null));
                ret.Add((Flags, null));
                ret.Add((RadiusWrtPercent, null));
                ret.Add((Radius, null));
                ret.Add((MinHeight, null));
                ret.Add((MaxHeight, null));
                ret.Add((Sink, null));
                ret.Add((SinkVariance, null));
                ret.Add((SizeVariance, null));
                ret.Add((AngleVariance, null));
                ret.Add((Unknown2, null));
            }
        }
        #endregion

        #region Mutagen
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        public IEnumerable<ILinkGetter> Links => RegionDataObjectCommon.Instance.GetLinks(this);
        #endregion

        #region Binary Translation
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected object BinaryWriteTranslator => RegionDataObjectBinaryWriteTranslation.Instance;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        object IBinaryItem.BinaryWriteTranslator => this.BinaryWriteTranslator;
        void IBinaryItem.WriteToBinary(
            MutagenWriter writer,
            RecordTypeConverter? recordTypeConverter = null)
        {
            ((RegionDataObjectBinaryWriteTranslation)this.BinaryWriteTranslator).Write(
                item: this,
                writer: writer,
                recordTypeConverter: recordTypeConverter);
        }
        #region Binary Create
        [DebuggerStepThrough]
        public static RegionDataObject CreateFromBinary(MutagenFrame frame)
        {
            return CreateFromBinary(
                frame: frame,
                recordTypeConverter: null);
        }

        public static RegionDataObject CreateFromBinary(
            MutagenFrame frame,
            RecordTypeConverter? recordTypeConverter = null)
        {
            var ret = new RegionDataObject();
            ((RegionDataObjectSetterCommon)((IRegionDataObjectGetter)ret).CommonSetterInstance()!).CopyInFromBinary(
                item: ret,
                frame: frame,
                recordTypeConverter: recordTypeConverter);
            return ret;
        }

        #endregion

        #endregion

        void IPrintable.ToString(FileGeneration fg, string? name) => this.ToString(fg, name);
        IMask<bool> ILoquiObjectGetter.GetHasBeenSetIMask() => this.GetHasBeenSetMask();
        IMask<bool> IEqualsMask.GetEqualsIMask(object rhs, EqualsMaskHelper.Include include) => this.GetEqualsMask((IRegionDataObjectGetter)rhs, include);

        void IClearable.Clear()
        {
            ((RegionDataObjectSetterCommon)((IRegionDataObjectGetter)this).CommonSetterInstance()!).Clear(this);
        }

        internal static RegionDataObject GetNew()
        {
            return new RegionDataObject();
        }

    }
    #endregion

    #region Interface
    public partial interface IRegionDataObject :
        IRegionDataObjectGetter,
        ILoquiObjectSetter<IRegionDataObject>
    {
        new IFormLink<OblivionMajorRecord> Object { get; }
        new UInt16 ParentIndex { get; set; }
        new Byte[] Unknown1 { get; set; }
        new Single Density { get; set; }
        new Byte Clustering { get; set; }
        new Byte MinSlope { get; set; }
        new Byte MaxSlope { get; set; }
        new RegionDataObject.Flag Flags { get; set; }
        new UInt16 RadiusWrtPercent { get; set; }
        new UInt16 Radius { get; set; }
        new Single MinHeight { get; set; }
        new Single MaxHeight { get; set; }
        new Single Sink { get; set; }
        new Single SinkVariance { get; set; }
        new Single SizeVariance { get; set; }
        new P3UInt16 AngleVariance { get; set; }
        new Byte[] Unknown2 { get; set; }
    }

    public partial interface IRegionDataObjectGetter :
        ILoquiObject,
        ILoquiObject<IRegionDataObjectGetter>,
        IXmlItem,
        ILinkContainer,
        IBinaryItem
    {
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        object CommonInstance();
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        object? CommonSetterInstance();
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        object CommonSetterTranslationInstance();
        IFormLinkGetter<IOblivionMajorRecordGetter> Object { get; }
        UInt16 ParentIndex { get; }
        ReadOnlyMemorySlice<Byte> Unknown1 { get; }
        Single Density { get; }
        Byte Clustering { get; }
        Byte MinSlope { get; }
        Byte MaxSlope { get; }
        RegionDataObject.Flag Flags { get; }
        UInt16 RadiusWrtPercent { get; }
        UInt16 Radius { get; }
        Single MinHeight { get; }
        Single MaxHeight { get; }
        Single Sink { get; }
        Single SinkVariance { get; }
        Single SizeVariance { get; }
        P3UInt16 AngleVariance { get; }
        ReadOnlyMemorySlice<Byte> Unknown2 { get; }

    }

    #endregion

    #region Common MixIn
    public static partial class RegionDataObjectMixIn
    {
        public static void Clear(this IRegionDataObject item)
        {
            ((RegionDataObjectSetterCommon)((IRegionDataObjectGetter)item).CommonSetterInstance()!).Clear(item: item);
        }

        public static RegionDataObject.Mask<bool> GetEqualsMask(
            this IRegionDataObjectGetter item,
            IRegionDataObjectGetter rhs,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            return ((RegionDataObjectCommon)((IRegionDataObjectGetter)item).CommonInstance()!).GetEqualsMask(
                item: item,
                rhs: rhs,
                include: include);
        }

        public static string ToString(
            this IRegionDataObjectGetter item,
            string? name = null,
            RegionDataObject.Mask<bool>? printMask = null)
        {
            return ((RegionDataObjectCommon)((IRegionDataObjectGetter)item).CommonInstance()!).ToString(
                item: item,
                name: name,
                printMask: printMask);
        }

        public static void ToString(
            this IRegionDataObjectGetter item,
            FileGeneration fg,
            string? name = null,
            RegionDataObject.Mask<bool>? printMask = null)
        {
            ((RegionDataObjectCommon)((IRegionDataObjectGetter)item).CommonInstance()!).ToString(
                item: item,
                fg: fg,
                name: name,
                printMask: printMask);
        }

        public static bool HasBeenSet(
            this IRegionDataObjectGetter item,
            RegionDataObject.Mask<bool?> checkMask)
        {
            return ((RegionDataObjectCommon)((IRegionDataObjectGetter)item).CommonInstance()!).HasBeenSet(
                item: item,
                checkMask: checkMask);
        }

        public static RegionDataObject.Mask<bool> GetHasBeenSetMask(this IRegionDataObjectGetter item)
        {
            var ret = new RegionDataObject.Mask<bool>(false);
            ((RegionDataObjectCommon)((IRegionDataObjectGetter)item).CommonInstance()!).FillHasBeenSetMask(
                item: item,
                mask: ret);
            return ret;
        }

        public static bool Equals(
            this IRegionDataObjectGetter item,
            IRegionDataObjectGetter rhs)
        {
            return ((RegionDataObjectCommon)((IRegionDataObjectGetter)item).CommonInstance()!).Equals(
                lhs: item,
                rhs: rhs);
        }

        public static void DeepCopyIn(
            this IRegionDataObject lhs,
            IRegionDataObjectGetter rhs,
            RegionDataObject.TranslationMask? copyMask = null)
        {
            ((RegionDataObjectSetterTranslationCommon)((IRegionDataObjectGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: default,
                copyMask: default);
        }

        public static void DeepCopyIn(
            this IRegionDataObject lhs,
            IRegionDataObjectGetter rhs,
            out RegionDataObject.ErrorMask errorMask,
            RegionDataObject.TranslationMask? copyMask = null)
        {
            var errorMaskBuilder = new ErrorMaskBuilder();
            ((RegionDataObjectSetterTranslationCommon)((IRegionDataObjectGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: errorMaskBuilder,
                copyMask: copyMask?.GetCrystal());
            errorMask = RegionDataObject.ErrorMask.Factory(errorMaskBuilder);
        }

        public static void DeepCopyIn(
            this IRegionDataObject lhs,
            IRegionDataObjectGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask)
        {
            ((RegionDataObjectSetterTranslationCommon)((IRegionDataObjectGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: errorMask,
                copyMask: copyMask);
        }

        public static RegionDataObject DeepCopy(
            this IRegionDataObjectGetter item,
            RegionDataObject.TranslationMask? copyMask = null)
        {
            return ((RegionDataObjectSetterTranslationCommon)((IRegionDataObjectGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask);
        }

        public static RegionDataObject DeepCopy(
            this IRegionDataObjectGetter item,
            out RegionDataObject.ErrorMask errorMask,
            RegionDataObject.TranslationMask? copyMask = null)
        {
            return ((RegionDataObjectSetterTranslationCommon)((IRegionDataObjectGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask,
                errorMask: out errorMask);
        }

        public static RegionDataObject DeepCopy(
            this IRegionDataObjectGetter item,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask = null)
        {
            return ((RegionDataObjectSetterTranslationCommon)((IRegionDataObjectGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask,
                errorMask: errorMask);
        }

        #region Xml Translation
        [DebuggerStepThrough]
        public static void CopyInFromXml(
            this IRegionDataObject item,
            XElement node,
            RegionDataObject.TranslationMask? translationMask = null)
        {
            CopyInFromXml(
                item: item,
                node: node,
                errorMask: null,
                translationMask: translationMask?.GetCrystal());
        }

        [DebuggerStepThrough]
        public static void CopyInFromXml(
            this IRegionDataObject item,
            XElement node,
            out RegionDataObject.ErrorMask errorMask,
            RegionDataObject.TranslationMask? translationMask = null)
        {
            ErrorMaskBuilder errorMaskBuilder = new ErrorMaskBuilder();
            CopyInFromXml(
                item: item,
                node: node,
                errorMask: errorMaskBuilder,
                translationMask: translationMask?.GetCrystal());
            errorMask = RegionDataObject.ErrorMask.Factory(errorMaskBuilder);
        }

        public static void CopyInFromXml(
            this IRegionDataObject item,
            XElement node,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask)
        {
            ((RegionDataObjectSetterCommon)((IRegionDataObjectGetter)item).CommonSetterInstance()!).CopyInFromXml(
                item: item,
                node: node,
                errorMask: errorMask,
                translationMask: translationMask);
        }

        public static void CopyInFromXml(
            this IRegionDataObject item,
            string path,
            RegionDataObject.TranslationMask? translationMask = null)
        {
            var node = XDocument.Load(path).Root;
            CopyInFromXml(
                item: item,
                node: node,
                translationMask: translationMask);
        }

        public static void CopyInFromXml(
            this IRegionDataObject item,
            string path,
            out RegionDataObject.ErrorMask errorMask,
            RegionDataObject.TranslationMask? translationMask = null)
        {
            var node = XDocument.Load(path).Root;
            CopyInFromXml(
                item: item,
                node: node,
                errorMask: out errorMask,
                translationMask: translationMask);
        }

        public static void CopyInFromXml(
            this IRegionDataObject item,
            string path,
            ErrorMaskBuilder? errorMask,
            RegionDataObject.TranslationMask? translationMask = null)
        {
            var node = XDocument.Load(path).Root;
            CopyInFromXml(
                item: item,
                node: node,
                errorMask: errorMask,
                translationMask: translationMask?.GetCrystal());
        }

        public static void CopyInFromXml(
            this IRegionDataObject item,
            Stream stream,
            RegionDataObject.TranslationMask? translationMask = null)
        {
            var node = XDocument.Load(stream).Root;
            CopyInFromXml(
                item: item,
                node: node,
                translationMask: translationMask);
        }

        public static void CopyInFromXml(
            this IRegionDataObject item,
            Stream stream,
            out RegionDataObject.ErrorMask errorMask,
            RegionDataObject.TranslationMask? translationMask = null)
        {
            var node = XDocument.Load(stream).Root;
            CopyInFromXml(
                item: item,
                node: node,
                errorMask: out errorMask,
                translationMask: translationMask);
        }

        public static void CopyInFromXml(
            this IRegionDataObject item,
            Stream stream,
            ErrorMaskBuilder? errorMask,
            RegionDataObject.TranslationMask? translationMask = null)
        {
            var node = XDocument.Load(stream).Root;
            CopyInFromXml(
                item: item,
                node: node,
                errorMask: errorMask,
                translationMask: translationMask?.GetCrystal());
        }

        #endregion

        #region Binary Translation
        [DebuggerStepThrough]
        public static void CopyInFromBinary(
            this IRegionDataObject item,
            MutagenFrame frame)
        {
            CopyInFromBinary(
                item: item,
                frame: frame,
                recordTypeConverter: null);
        }

        public static void CopyInFromBinary(
            this IRegionDataObject item,
            MutagenFrame frame,
            RecordTypeConverter? recordTypeConverter = null)
        {
            ((RegionDataObjectSetterCommon)((IRegionDataObjectGetter)item).CommonSetterInstance()!).CopyInFromBinary(
                item: item,
                frame: frame,
                recordTypeConverter: recordTypeConverter);
        }

        #endregion

    }
    #endregion

}

namespace Mutagen.Bethesda.Oblivion.Internals
{
    #region Field Index
    public enum RegionDataObject_FieldIndex
    {
        Object = 0,
        ParentIndex = 1,
        Unknown1 = 2,
        Density = 3,
        Clustering = 4,
        MinSlope = 5,
        MaxSlope = 6,
        Flags = 7,
        RadiusWrtPercent = 8,
        Radius = 9,
        MinHeight = 10,
        MaxHeight = 11,
        Sink = 12,
        SinkVariance = 13,
        SizeVariance = 14,
        AngleVariance = 15,
        Unknown2 = 16,
    }
    #endregion

    #region Registration
    public partial class RegionDataObject_Registration : ILoquiRegistration
    {
        public static readonly RegionDataObject_Registration Instance = new RegionDataObject_Registration();

        public static ProtocolKey ProtocolKey => ProtocolDefinition_Oblivion.ProtocolKey;

        public static readonly ObjectKey ObjectKey = new ObjectKey(
            protocolKey: ProtocolDefinition_Oblivion.ProtocolKey,
            msgID: 117,
            version: 0);

        public const string GUID = "e814f192-a945-4518-bfd0-00e67eae8105";

        public const ushort AdditionalFieldCount = 17;

        public const ushort FieldCount = 17;

        public static readonly Type MaskType = typeof(RegionDataObject.Mask<>);

        public static readonly Type ErrorMaskType = typeof(RegionDataObject.ErrorMask);

        public static readonly Type ClassType = typeof(RegionDataObject);

        public static readonly Type GetterType = typeof(IRegionDataObjectGetter);

        public static readonly Type? InternalGetterType = null;

        public static readonly Type SetterType = typeof(IRegionDataObject);

        public static readonly Type? InternalSetterType = null;

        public const string FullName = "Mutagen.Bethesda.Oblivion.RegionDataObject";

        public const string Name = "RegionDataObject";

        public const string Namespace = "Mutagen.Bethesda.Oblivion";

        public const byte GenericCount = 0;

        public static readonly Type? GenericRegistrationType = null;

        public static ushort? GetNameIndex(StringCaseAgnostic str)
        {
            switch (str.Upper)
            {
                case "OBJECT":
                    return (ushort)RegionDataObject_FieldIndex.Object;
                case "PARENTINDEX":
                    return (ushort)RegionDataObject_FieldIndex.ParentIndex;
                case "UNKNOWN1":
                    return (ushort)RegionDataObject_FieldIndex.Unknown1;
                case "DENSITY":
                    return (ushort)RegionDataObject_FieldIndex.Density;
                case "CLUSTERING":
                    return (ushort)RegionDataObject_FieldIndex.Clustering;
                case "MINSLOPE":
                    return (ushort)RegionDataObject_FieldIndex.MinSlope;
                case "MAXSLOPE":
                    return (ushort)RegionDataObject_FieldIndex.MaxSlope;
                case "FLAGS":
                    return (ushort)RegionDataObject_FieldIndex.Flags;
                case "RADIUSWRTPERCENT":
                    return (ushort)RegionDataObject_FieldIndex.RadiusWrtPercent;
                case "RADIUS":
                    return (ushort)RegionDataObject_FieldIndex.Radius;
                case "MINHEIGHT":
                    return (ushort)RegionDataObject_FieldIndex.MinHeight;
                case "MAXHEIGHT":
                    return (ushort)RegionDataObject_FieldIndex.MaxHeight;
                case "SINK":
                    return (ushort)RegionDataObject_FieldIndex.Sink;
                case "SINKVARIANCE":
                    return (ushort)RegionDataObject_FieldIndex.SinkVariance;
                case "SIZEVARIANCE":
                    return (ushort)RegionDataObject_FieldIndex.SizeVariance;
                case "ANGLEVARIANCE":
                    return (ushort)RegionDataObject_FieldIndex.AngleVariance;
                case "UNKNOWN2":
                    return (ushort)RegionDataObject_FieldIndex.Unknown2;
                default:
                    return null;
            }
        }

        public static bool GetNthIsEnumerable(ushort index)
        {
            RegionDataObject_FieldIndex enu = (RegionDataObject_FieldIndex)index;
            switch (enu)
            {
                case RegionDataObject_FieldIndex.Object:
                case RegionDataObject_FieldIndex.ParentIndex:
                case RegionDataObject_FieldIndex.Unknown1:
                case RegionDataObject_FieldIndex.Density:
                case RegionDataObject_FieldIndex.Clustering:
                case RegionDataObject_FieldIndex.MinSlope:
                case RegionDataObject_FieldIndex.MaxSlope:
                case RegionDataObject_FieldIndex.Flags:
                case RegionDataObject_FieldIndex.RadiusWrtPercent:
                case RegionDataObject_FieldIndex.Radius:
                case RegionDataObject_FieldIndex.MinHeight:
                case RegionDataObject_FieldIndex.MaxHeight:
                case RegionDataObject_FieldIndex.Sink:
                case RegionDataObject_FieldIndex.SinkVariance:
                case RegionDataObject_FieldIndex.SizeVariance:
                case RegionDataObject_FieldIndex.AngleVariance:
                case RegionDataObject_FieldIndex.Unknown2:
                    return false;
                default:
                    throw new ArgumentException($"Index is out of range: {index}");
            }
        }

        public static bool GetNthIsLoqui(ushort index)
        {
            RegionDataObject_FieldIndex enu = (RegionDataObject_FieldIndex)index;
            switch (enu)
            {
                case RegionDataObject_FieldIndex.Object:
                case RegionDataObject_FieldIndex.ParentIndex:
                case RegionDataObject_FieldIndex.Unknown1:
                case RegionDataObject_FieldIndex.Density:
                case RegionDataObject_FieldIndex.Clustering:
                case RegionDataObject_FieldIndex.MinSlope:
                case RegionDataObject_FieldIndex.MaxSlope:
                case RegionDataObject_FieldIndex.Flags:
                case RegionDataObject_FieldIndex.RadiusWrtPercent:
                case RegionDataObject_FieldIndex.Radius:
                case RegionDataObject_FieldIndex.MinHeight:
                case RegionDataObject_FieldIndex.MaxHeight:
                case RegionDataObject_FieldIndex.Sink:
                case RegionDataObject_FieldIndex.SinkVariance:
                case RegionDataObject_FieldIndex.SizeVariance:
                case RegionDataObject_FieldIndex.AngleVariance:
                case RegionDataObject_FieldIndex.Unknown2:
                    return false;
                default:
                    throw new ArgumentException($"Index is out of range: {index}");
            }
        }

        public static bool GetNthIsSingleton(ushort index)
        {
            RegionDataObject_FieldIndex enu = (RegionDataObject_FieldIndex)index;
            switch (enu)
            {
                case RegionDataObject_FieldIndex.Object:
                case RegionDataObject_FieldIndex.ParentIndex:
                case RegionDataObject_FieldIndex.Unknown1:
                case RegionDataObject_FieldIndex.Density:
                case RegionDataObject_FieldIndex.Clustering:
                case RegionDataObject_FieldIndex.MinSlope:
                case RegionDataObject_FieldIndex.MaxSlope:
                case RegionDataObject_FieldIndex.Flags:
                case RegionDataObject_FieldIndex.RadiusWrtPercent:
                case RegionDataObject_FieldIndex.Radius:
                case RegionDataObject_FieldIndex.MinHeight:
                case RegionDataObject_FieldIndex.MaxHeight:
                case RegionDataObject_FieldIndex.Sink:
                case RegionDataObject_FieldIndex.SinkVariance:
                case RegionDataObject_FieldIndex.SizeVariance:
                case RegionDataObject_FieldIndex.AngleVariance:
                case RegionDataObject_FieldIndex.Unknown2:
                    return false;
                default:
                    throw new ArgumentException($"Index is out of range: {index}");
            }
        }

        public static string GetNthName(ushort index)
        {
            RegionDataObject_FieldIndex enu = (RegionDataObject_FieldIndex)index;
            switch (enu)
            {
                case RegionDataObject_FieldIndex.Object:
                    return "Object";
                case RegionDataObject_FieldIndex.ParentIndex:
                    return "ParentIndex";
                case RegionDataObject_FieldIndex.Unknown1:
                    return "Unknown1";
                case RegionDataObject_FieldIndex.Density:
                    return "Density";
                case RegionDataObject_FieldIndex.Clustering:
                    return "Clustering";
                case RegionDataObject_FieldIndex.MinSlope:
                    return "MinSlope";
                case RegionDataObject_FieldIndex.MaxSlope:
                    return "MaxSlope";
                case RegionDataObject_FieldIndex.Flags:
                    return "Flags";
                case RegionDataObject_FieldIndex.RadiusWrtPercent:
                    return "RadiusWrtPercent";
                case RegionDataObject_FieldIndex.Radius:
                    return "Radius";
                case RegionDataObject_FieldIndex.MinHeight:
                    return "MinHeight";
                case RegionDataObject_FieldIndex.MaxHeight:
                    return "MaxHeight";
                case RegionDataObject_FieldIndex.Sink:
                    return "Sink";
                case RegionDataObject_FieldIndex.SinkVariance:
                    return "SinkVariance";
                case RegionDataObject_FieldIndex.SizeVariance:
                    return "SizeVariance";
                case RegionDataObject_FieldIndex.AngleVariance:
                    return "AngleVariance";
                case RegionDataObject_FieldIndex.Unknown2:
                    return "Unknown2";
                default:
                    throw new ArgumentException($"Index is out of range: {index}");
            }
        }

        public static bool IsNthDerivative(ushort index)
        {
            RegionDataObject_FieldIndex enu = (RegionDataObject_FieldIndex)index;
            switch (enu)
            {
                case RegionDataObject_FieldIndex.Object:
                case RegionDataObject_FieldIndex.ParentIndex:
                case RegionDataObject_FieldIndex.Unknown1:
                case RegionDataObject_FieldIndex.Density:
                case RegionDataObject_FieldIndex.Clustering:
                case RegionDataObject_FieldIndex.MinSlope:
                case RegionDataObject_FieldIndex.MaxSlope:
                case RegionDataObject_FieldIndex.Flags:
                case RegionDataObject_FieldIndex.RadiusWrtPercent:
                case RegionDataObject_FieldIndex.Radius:
                case RegionDataObject_FieldIndex.MinHeight:
                case RegionDataObject_FieldIndex.MaxHeight:
                case RegionDataObject_FieldIndex.Sink:
                case RegionDataObject_FieldIndex.SinkVariance:
                case RegionDataObject_FieldIndex.SizeVariance:
                case RegionDataObject_FieldIndex.AngleVariance:
                case RegionDataObject_FieldIndex.Unknown2:
                    return false;
                default:
                    throw new ArgumentException($"Index is out of range: {index}");
            }
        }

        public static bool IsProtected(ushort index)
        {
            RegionDataObject_FieldIndex enu = (RegionDataObject_FieldIndex)index;
            switch (enu)
            {
                case RegionDataObject_FieldIndex.Object:
                case RegionDataObject_FieldIndex.ParentIndex:
                case RegionDataObject_FieldIndex.Unknown1:
                case RegionDataObject_FieldIndex.Density:
                case RegionDataObject_FieldIndex.Clustering:
                case RegionDataObject_FieldIndex.MinSlope:
                case RegionDataObject_FieldIndex.MaxSlope:
                case RegionDataObject_FieldIndex.Flags:
                case RegionDataObject_FieldIndex.RadiusWrtPercent:
                case RegionDataObject_FieldIndex.Radius:
                case RegionDataObject_FieldIndex.MinHeight:
                case RegionDataObject_FieldIndex.MaxHeight:
                case RegionDataObject_FieldIndex.Sink:
                case RegionDataObject_FieldIndex.SinkVariance:
                case RegionDataObject_FieldIndex.SizeVariance:
                case RegionDataObject_FieldIndex.AngleVariance:
                case RegionDataObject_FieldIndex.Unknown2:
                    return false;
                default:
                    throw new ArgumentException($"Index is out of range: {index}");
            }
        }

        public static Type GetNthType(ushort index)
        {
            RegionDataObject_FieldIndex enu = (RegionDataObject_FieldIndex)index;
            switch (enu)
            {
                case RegionDataObject_FieldIndex.Object:
                    return typeof(IFormLink<OblivionMajorRecord>);
                case RegionDataObject_FieldIndex.ParentIndex:
                    return typeof(UInt16);
                case RegionDataObject_FieldIndex.Unknown1:
                    return typeof(Byte[]);
                case RegionDataObject_FieldIndex.Density:
                    return typeof(Single);
                case RegionDataObject_FieldIndex.Clustering:
                    return typeof(Byte);
                case RegionDataObject_FieldIndex.MinSlope:
                    return typeof(Byte);
                case RegionDataObject_FieldIndex.MaxSlope:
                    return typeof(Byte);
                case RegionDataObject_FieldIndex.Flags:
                    return typeof(RegionDataObject.Flag);
                case RegionDataObject_FieldIndex.RadiusWrtPercent:
                    return typeof(UInt16);
                case RegionDataObject_FieldIndex.Radius:
                    return typeof(UInt16);
                case RegionDataObject_FieldIndex.MinHeight:
                    return typeof(Single);
                case RegionDataObject_FieldIndex.MaxHeight:
                    return typeof(Single);
                case RegionDataObject_FieldIndex.Sink:
                    return typeof(Single);
                case RegionDataObject_FieldIndex.SinkVariance:
                    return typeof(Single);
                case RegionDataObject_FieldIndex.SizeVariance:
                    return typeof(Single);
                case RegionDataObject_FieldIndex.AngleVariance:
                    return typeof(P3UInt16);
                case RegionDataObject_FieldIndex.Unknown2:
                    return typeof(Byte[]);
                default:
                    throw new ArgumentException($"Index is out of range: {index}");
            }
        }

        public static readonly Type XmlWriteTranslation = typeof(RegionDataObjectXmlWriteTranslation);
        public const int NumStructFields = 17;
        public const int NumTypedFields = 0;
        public static readonly Type BinaryWriteTranslation = typeof(RegionDataObjectBinaryWriteTranslation);
        #region Interface
        ProtocolKey ILoquiRegistration.ProtocolKey => ProtocolKey;
        ObjectKey ILoquiRegistration.ObjectKey => ObjectKey;
        string ILoquiRegistration.GUID => GUID;
        ushort ILoquiRegistration.FieldCount => FieldCount;
        ushort ILoquiRegistration.AdditionalFieldCount => AdditionalFieldCount;
        Type ILoquiRegistration.MaskType => MaskType;
        Type ILoquiRegistration.ErrorMaskType => ErrorMaskType;
        Type ILoquiRegistration.ClassType => ClassType;
        Type ILoquiRegistration.SetterType => SetterType;
        Type? ILoquiRegistration.InternalSetterType => InternalSetterType;
        Type ILoquiRegistration.GetterType => GetterType;
        Type? ILoquiRegistration.InternalGetterType => InternalGetterType;
        string ILoquiRegistration.FullName => FullName;
        string ILoquiRegistration.Name => Name;
        string ILoquiRegistration.Namespace => Namespace;
        byte ILoquiRegistration.GenericCount => GenericCount;
        Type? ILoquiRegistration.GenericRegistrationType => GenericRegistrationType;
        ushort? ILoquiRegistration.GetNameIndex(StringCaseAgnostic name) => GetNameIndex(name);
        bool ILoquiRegistration.GetNthIsEnumerable(ushort index) => GetNthIsEnumerable(index);
        bool ILoquiRegistration.GetNthIsLoqui(ushort index) => GetNthIsLoqui(index);
        bool ILoquiRegistration.GetNthIsSingleton(ushort index) => GetNthIsSingleton(index);
        string ILoquiRegistration.GetNthName(ushort index) => GetNthName(index);
        bool ILoquiRegistration.IsNthDerivative(ushort index) => IsNthDerivative(index);
        bool ILoquiRegistration.IsProtected(ushort index) => IsProtected(index);
        Type ILoquiRegistration.GetNthType(ushort index) => GetNthType(index);
        #endregion

    }
    #endregion

    #region Common
    public partial class RegionDataObjectSetterCommon
    {
        public static readonly RegionDataObjectSetterCommon Instance = new RegionDataObjectSetterCommon();

        partial void ClearPartial();
        
        public void Clear(IRegionDataObject item)
        {
            ClearPartial();
            item.Object.FormKey = FormKey.Null;
            item.ParentIndex = default;
            item.Unknown1 = new byte[2];
            item.Density = default;
            item.Clustering = default;
            item.MinSlope = default;
            item.MaxSlope = default;
            item.Flags = default;
            item.RadiusWrtPercent = default;
            item.Radius = default;
            item.MinHeight = default;
            item.MaxHeight = default;
            item.Sink = default;
            item.SinkVariance = default;
            item.SizeVariance = default;
            item.AngleVariance = default;
            item.Unknown2 = new byte[6];
        }
        
        #region Xml Translation
        public virtual void CopyInFromXml(
            IRegionDataObject item,
            XElement node,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask)
        {
            try
            {
                foreach (var elem in node.Elements())
                {
                    RegionDataObjectXmlCreateTranslation.FillPublicElementXml(
                        item: item,
                        node: elem,
                        name: elem.Name.LocalName,
                        errorMask: errorMask,
                        translationMask: translationMask);
                }
            }
            catch (Exception ex)
            when (errorMask != null)
            {
                errorMask.ReportException(ex);
            }
        }
        
        #endregion
        
        #region Binary Translation
        protected static void FillBinaryStructs(
            IRegionDataObject item,
            MutagenFrame frame)
        {
            item.Object.FormKey = Mutagen.Bethesda.Binary.FormLinkBinaryTranslation.Instance.Parse(
                frame: frame,
                defaultVal: FormKey.Null);
            item.ParentIndex = frame.ReadUInt16();
            item.Unknown1 = Mutagen.Bethesda.Binary.ByteArrayBinaryTranslation.Instance.Parse(frame: frame.SpawnWithLength(2));
            item.Density = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
            item.Clustering = frame.ReadUInt8();
            item.MinSlope = frame.ReadUInt8();
            item.MaxSlope = frame.ReadUInt8();
            item.Flags = EnumBinaryTranslation<RegionDataObject.Flag>.Instance.Parse(frame: frame.SpawnWithLength(1));
            item.RadiusWrtPercent = frame.ReadUInt16();
            item.Radius = frame.ReadUInt16();
            item.MinHeight = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
            item.MaxHeight = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
            item.Sink = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
            item.SinkVariance = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
            item.SizeVariance = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
            item.AngleVariance = Mutagen.Bethesda.Binary.P3UInt16BinaryTranslation.Instance.Parse(frame: frame);
            item.Unknown2 = Mutagen.Bethesda.Binary.ByteArrayBinaryTranslation.Instance.Parse(frame: frame.SpawnWithLength(6));
        }
        
        public virtual void CopyInFromBinary(
            IRegionDataObject item,
            MutagenFrame frame,
            RecordTypeConverter? recordTypeConverter = null)
        {
            UtilityTranslation.SubrecordParse(
                record: item,
                frame: frame,
                recordTypeConverter: recordTypeConverter,
                fillStructs: FillBinaryStructs);
        }
        
        #endregion
        
    }
    public partial class RegionDataObjectCommon
    {
        public static readonly RegionDataObjectCommon Instance = new RegionDataObjectCommon();

        public RegionDataObject.Mask<bool> GetEqualsMask(
            IRegionDataObjectGetter item,
            IRegionDataObjectGetter rhs,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            var ret = new RegionDataObject.Mask<bool>(false);
            ((RegionDataObjectCommon)((IRegionDataObjectGetter)item).CommonInstance()!).FillEqualsMask(
                item: item,
                rhs: rhs,
                ret: ret,
                include: include);
            return ret;
        }
        
        public void FillEqualsMask(
            IRegionDataObjectGetter item,
            IRegionDataObjectGetter rhs,
            RegionDataObject.Mask<bool> ret,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            if (rhs == null) return;
            ret.Object = object.Equals(item.Object, rhs.Object);
            ret.ParentIndex = item.ParentIndex == rhs.ParentIndex;
            ret.Unknown1 = MemoryExtensions.SequenceEqual(item.Unknown1.Span, rhs.Unknown1.Span);
            ret.Density = item.Density.EqualsWithin(rhs.Density);
            ret.Clustering = item.Clustering == rhs.Clustering;
            ret.MinSlope = item.MinSlope == rhs.MinSlope;
            ret.MaxSlope = item.MaxSlope == rhs.MaxSlope;
            ret.Flags = item.Flags == rhs.Flags;
            ret.RadiusWrtPercent = item.RadiusWrtPercent == rhs.RadiusWrtPercent;
            ret.Radius = item.Radius == rhs.Radius;
            ret.MinHeight = item.MinHeight.EqualsWithin(rhs.MinHeight);
            ret.MaxHeight = item.MaxHeight.EqualsWithin(rhs.MaxHeight);
            ret.Sink = item.Sink.EqualsWithin(rhs.Sink);
            ret.SinkVariance = item.SinkVariance.EqualsWithin(rhs.SinkVariance);
            ret.SizeVariance = item.SizeVariance.EqualsWithin(rhs.SizeVariance);
            ret.AngleVariance = item.AngleVariance.Equals(rhs.AngleVariance);
            ret.Unknown2 = MemoryExtensions.SequenceEqual(item.Unknown2.Span, rhs.Unknown2.Span);
        }
        
        public string ToString(
            IRegionDataObjectGetter item,
            string? name = null,
            RegionDataObject.Mask<bool>? printMask = null)
        {
            var fg = new FileGeneration();
            ToString(
                item: item,
                fg: fg,
                name: name,
                printMask: printMask);
            return fg.ToString();
        }
        
        public void ToString(
            IRegionDataObjectGetter item,
            FileGeneration fg,
            string? name = null,
            RegionDataObject.Mask<bool>? printMask = null)
        {
            if (name == null)
            {
                fg.AppendLine($"RegionDataObject =>");
            }
            else
            {
                fg.AppendLine($"{name} (RegionDataObject) =>");
            }
            fg.AppendLine("[");
            using (new DepthWrapper(fg))
            {
                ToStringFields(
                    item: item,
                    fg: fg,
                    printMask: printMask);
            }
            fg.AppendLine("]");
        }
        
        protected static void ToStringFields(
            IRegionDataObjectGetter item,
            FileGeneration fg,
            RegionDataObject.Mask<bool>? printMask = null)
        {
            if (printMask?.Object ?? true)
            {
                fg.AppendItem(item.Object, "Object");
            }
            if (printMask?.ParentIndex ?? true)
            {
                fg.AppendItem(item.ParentIndex, "ParentIndex");
            }
            if (printMask?.Unknown1 ?? true)
            {
                fg.AppendLine($"Unknown1 => {SpanExt.ToHexString(item.Unknown1)}");
            }
            if (printMask?.Density ?? true)
            {
                fg.AppendItem(item.Density, "Density");
            }
            if (printMask?.Clustering ?? true)
            {
                fg.AppendItem(item.Clustering, "Clustering");
            }
            if (printMask?.MinSlope ?? true)
            {
                fg.AppendItem(item.MinSlope, "MinSlope");
            }
            if (printMask?.MaxSlope ?? true)
            {
                fg.AppendItem(item.MaxSlope, "MaxSlope");
            }
            if (printMask?.Flags ?? true)
            {
                fg.AppendItem(item.Flags, "Flags");
            }
            if (printMask?.RadiusWrtPercent ?? true)
            {
                fg.AppendItem(item.RadiusWrtPercent, "RadiusWrtPercent");
            }
            if (printMask?.Radius ?? true)
            {
                fg.AppendItem(item.Radius, "Radius");
            }
            if (printMask?.MinHeight ?? true)
            {
                fg.AppendItem(item.MinHeight, "MinHeight");
            }
            if (printMask?.MaxHeight ?? true)
            {
                fg.AppendItem(item.MaxHeight, "MaxHeight");
            }
            if (printMask?.Sink ?? true)
            {
                fg.AppendItem(item.Sink, "Sink");
            }
            if (printMask?.SinkVariance ?? true)
            {
                fg.AppendItem(item.SinkVariance, "SinkVariance");
            }
            if (printMask?.SizeVariance ?? true)
            {
                fg.AppendItem(item.SizeVariance, "SizeVariance");
            }
            if (printMask?.AngleVariance ?? true)
            {
                fg.AppendItem(item.AngleVariance, "AngleVariance");
            }
            if (printMask?.Unknown2 ?? true)
            {
                fg.AppendLine($"Unknown2 => {SpanExt.ToHexString(item.Unknown2)}");
            }
        }
        
        public bool HasBeenSet(
            IRegionDataObjectGetter item,
            RegionDataObject.Mask<bool?> checkMask)
        {
            return true;
        }
        
        public void FillHasBeenSetMask(
            IRegionDataObjectGetter item,
            RegionDataObject.Mask<bool> mask)
        {
            mask.Object = true;
            mask.ParentIndex = true;
            mask.Unknown1 = true;
            mask.Density = true;
            mask.Clustering = true;
            mask.MinSlope = true;
            mask.MaxSlope = true;
            mask.Flags = true;
            mask.RadiusWrtPercent = true;
            mask.Radius = true;
            mask.MinHeight = true;
            mask.MaxHeight = true;
            mask.Sink = true;
            mask.SinkVariance = true;
            mask.SizeVariance = true;
            mask.AngleVariance = true;
            mask.Unknown2 = true;
        }
        
        #region Equals and Hash
        public virtual bool Equals(
            IRegionDataObjectGetter? lhs,
            IRegionDataObjectGetter? rhs)
        {
            if (lhs == null && rhs == null) return false;
            if (lhs == null || rhs == null) return false;
            if (!lhs.Object.Equals(rhs.Object)) return false;
            if (lhs.ParentIndex != rhs.ParentIndex) return false;
            if (!MemoryExtensions.SequenceEqual(lhs.Unknown1.Span, rhs.Unknown1.Span)) return false;
            if (!lhs.Density.EqualsWithin(rhs.Density)) return false;
            if (lhs.Clustering != rhs.Clustering) return false;
            if (lhs.MinSlope != rhs.MinSlope) return false;
            if (lhs.MaxSlope != rhs.MaxSlope) return false;
            if (lhs.Flags != rhs.Flags) return false;
            if (lhs.RadiusWrtPercent != rhs.RadiusWrtPercent) return false;
            if (lhs.Radius != rhs.Radius) return false;
            if (!lhs.MinHeight.EqualsWithin(rhs.MinHeight)) return false;
            if (!lhs.MaxHeight.EqualsWithin(rhs.MaxHeight)) return false;
            if (!lhs.Sink.EqualsWithin(rhs.Sink)) return false;
            if (!lhs.SinkVariance.EqualsWithin(rhs.SinkVariance)) return false;
            if (!lhs.SizeVariance.EqualsWithin(rhs.SizeVariance)) return false;
            if (!lhs.AngleVariance.Equals(rhs.AngleVariance)) return false;
            if (!MemoryExtensions.SequenceEqual(lhs.Unknown2.Span, rhs.Unknown2.Span)) return false;
            return true;
        }
        
        public virtual int GetHashCode(IRegionDataObjectGetter item)
        {
            var hash = new HashCode();
            hash.Add(item.Object);
            hash.Add(item.ParentIndex);
            hash.Add(item.Unknown1);
            hash.Add(item.Density);
            hash.Add(item.Clustering);
            hash.Add(item.MinSlope);
            hash.Add(item.MaxSlope);
            hash.Add(item.Flags);
            hash.Add(item.RadiusWrtPercent);
            hash.Add(item.Radius);
            hash.Add(item.MinHeight);
            hash.Add(item.MaxHeight);
            hash.Add(item.Sink);
            hash.Add(item.SinkVariance);
            hash.Add(item.SizeVariance);
            hash.Add(item.AngleVariance);
            hash.Add(item.Unknown2);
            return hash.ToHashCode();
        }
        
        #endregion
        
        
        public object GetNew()
        {
            return RegionDataObject.GetNew();
        }
        
        #region Mutagen
        public IEnumerable<ILinkGetter> GetLinks(IRegionDataObjectGetter obj)
        {
            yield return obj.Object;
            yield break;
        }
        
        #endregion
        
    }
    public partial class RegionDataObjectSetterTranslationCommon
    {
        public static readonly RegionDataObjectSetterTranslationCommon Instance = new RegionDataObjectSetterTranslationCommon();

        #region Deep Copy Fields From
        public void DeepCopyIn(
            IRegionDataObject item,
            IRegionDataObjectGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask)
        {
            if ((copyMask?.GetShouldTranslate((int)RegionDataObject_FieldIndex.Object) ?? true))
            {
                item.Object.FormKey = rhs.Object.FormKey;
            }
            if ((copyMask?.GetShouldTranslate((int)RegionDataObject_FieldIndex.ParentIndex) ?? true))
            {
                item.ParentIndex = rhs.ParentIndex;
            }
            if ((copyMask?.GetShouldTranslate((int)RegionDataObject_FieldIndex.Unknown1) ?? true))
            {
                item.Unknown1 = rhs.Unknown1.ToArray();
            }
            if ((copyMask?.GetShouldTranslate((int)RegionDataObject_FieldIndex.Density) ?? true))
            {
                item.Density = rhs.Density;
            }
            if ((copyMask?.GetShouldTranslate((int)RegionDataObject_FieldIndex.Clustering) ?? true))
            {
                item.Clustering = rhs.Clustering;
            }
            if ((copyMask?.GetShouldTranslate((int)RegionDataObject_FieldIndex.MinSlope) ?? true))
            {
                item.MinSlope = rhs.MinSlope;
            }
            if ((copyMask?.GetShouldTranslate((int)RegionDataObject_FieldIndex.MaxSlope) ?? true))
            {
                item.MaxSlope = rhs.MaxSlope;
            }
            if ((copyMask?.GetShouldTranslate((int)RegionDataObject_FieldIndex.Flags) ?? true))
            {
                item.Flags = rhs.Flags;
            }
            if ((copyMask?.GetShouldTranslate((int)RegionDataObject_FieldIndex.RadiusWrtPercent) ?? true))
            {
                item.RadiusWrtPercent = rhs.RadiusWrtPercent;
            }
            if ((copyMask?.GetShouldTranslate((int)RegionDataObject_FieldIndex.Radius) ?? true))
            {
                item.Radius = rhs.Radius;
            }
            if ((copyMask?.GetShouldTranslate((int)RegionDataObject_FieldIndex.MinHeight) ?? true))
            {
                item.MinHeight = rhs.MinHeight;
            }
            if ((copyMask?.GetShouldTranslate((int)RegionDataObject_FieldIndex.MaxHeight) ?? true))
            {
                item.MaxHeight = rhs.MaxHeight;
            }
            if ((copyMask?.GetShouldTranslate((int)RegionDataObject_FieldIndex.Sink) ?? true))
            {
                item.Sink = rhs.Sink;
            }
            if ((copyMask?.GetShouldTranslate((int)RegionDataObject_FieldIndex.SinkVariance) ?? true))
            {
                item.SinkVariance = rhs.SinkVariance;
            }
            if ((copyMask?.GetShouldTranslate((int)RegionDataObject_FieldIndex.SizeVariance) ?? true))
            {
                item.SizeVariance = rhs.SizeVariance;
            }
            if ((copyMask?.GetShouldTranslate((int)RegionDataObject_FieldIndex.AngleVariance) ?? true))
            {
                item.AngleVariance = rhs.AngleVariance;
            }
            if ((copyMask?.GetShouldTranslate((int)RegionDataObject_FieldIndex.Unknown2) ?? true))
            {
                item.Unknown2 = rhs.Unknown2.ToArray();
            }
        }
        
        #endregion
        
        public RegionDataObject DeepCopy(
            IRegionDataObjectGetter item,
            RegionDataObject.TranslationMask? copyMask = null)
        {
            RegionDataObject ret = (RegionDataObject)((RegionDataObjectCommon)((IRegionDataObjectGetter)item).CommonInstance()!).GetNew();
            ret.DeepCopyIn(
                item,
                copyMask: copyMask);
            return ret;
        }
        
        public RegionDataObject DeepCopy(
            IRegionDataObjectGetter item,
            out RegionDataObject.ErrorMask errorMask,
            RegionDataObject.TranslationMask? copyMask = null)
        {
            RegionDataObject ret = (RegionDataObject)((RegionDataObjectCommon)((IRegionDataObjectGetter)item).CommonInstance()!).GetNew();
            ret.DeepCopyIn(
                item,
                errorMask: out errorMask,
                copyMask: copyMask);
            return ret;
        }
        
        public RegionDataObject DeepCopy(
            IRegionDataObjectGetter item,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask = null)
        {
            RegionDataObject ret = (RegionDataObject)((RegionDataObjectCommon)((IRegionDataObjectGetter)item).CommonInstance()!).GetNew();
            ret.DeepCopyIn(
                item,
                errorMask: errorMask,
                copyMask: copyMask);
            return ret;
        }
        
    }
    #endregion

}

namespace Mutagen.Bethesda.Oblivion
{
    public partial class RegionDataObject
    {
        #region Common Routing
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILoquiRegistration ILoquiObject.Registration => RegionDataObject_Registration.Instance;
        public static RegionDataObject_Registration Registration => RegionDataObject_Registration.Instance;
        [DebuggerStepThrough]
        protected object CommonInstance() => RegionDataObjectCommon.Instance;
        [DebuggerStepThrough]
        protected object CommonSetterInstance()
        {
            return RegionDataObjectSetterCommon.Instance;
        }
        [DebuggerStepThrough]
        protected object CommonSetterTranslationInstance() => RegionDataObjectSetterTranslationCommon.Instance;
        [DebuggerStepThrough]
        object IRegionDataObjectGetter.CommonInstance() => this.CommonInstance();
        [DebuggerStepThrough]
        object IRegionDataObjectGetter.CommonSetterInstance() => this.CommonSetterInstance();
        [DebuggerStepThrough]
        object IRegionDataObjectGetter.CommonSetterTranslationInstance() => this.CommonSetterTranslationInstance();

        #endregion

    }
}

#region Modules
#region Xml Translation
namespace Mutagen.Bethesda.Oblivion.Internals
{
    public partial class RegionDataObjectXmlWriteTranslation : IXmlWriteTranslator
    {
        public readonly static RegionDataObjectXmlWriteTranslation Instance = new RegionDataObjectXmlWriteTranslation();

        public static void WriteToNodeXml(
            IRegionDataObjectGetter item,
            XElement node,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask)
        {
            if ((translationMask?.GetShouldTranslate((int)RegionDataObject_FieldIndex.Object) ?? true))
            {
                FormKeyXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.Object),
                    item: item.Object.FormKey,
                    fieldIndex: (int)RegionDataObject_FieldIndex.Object,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)RegionDataObject_FieldIndex.ParentIndex) ?? true))
            {
                UInt16XmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.ParentIndex),
                    item: item.ParentIndex,
                    fieldIndex: (int)RegionDataObject_FieldIndex.ParentIndex,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)RegionDataObject_FieldIndex.Unknown1) ?? true))
            {
                ByteArrayXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.Unknown1),
                    item: item.Unknown1,
                    fieldIndex: (int)RegionDataObject_FieldIndex.Unknown1,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)RegionDataObject_FieldIndex.Density) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.Density),
                    item: item.Density,
                    fieldIndex: (int)RegionDataObject_FieldIndex.Density,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)RegionDataObject_FieldIndex.Clustering) ?? true))
            {
                ByteXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.Clustering),
                    item: item.Clustering,
                    fieldIndex: (int)RegionDataObject_FieldIndex.Clustering,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)RegionDataObject_FieldIndex.MinSlope) ?? true))
            {
                ByteXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.MinSlope),
                    item: item.MinSlope,
                    fieldIndex: (int)RegionDataObject_FieldIndex.MinSlope,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)RegionDataObject_FieldIndex.MaxSlope) ?? true))
            {
                ByteXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.MaxSlope),
                    item: item.MaxSlope,
                    fieldIndex: (int)RegionDataObject_FieldIndex.MaxSlope,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)RegionDataObject_FieldIndex.Flags) ?? true))
            {
                EnumXmlTranslation<RegionDataObject.Flag>.Instance.Write(
                    node: node,
                    name: nameof(item.Flags),
                    item: item.Flags,
                    fieldIndex: (int)RegionDataObject_FieldIndex.Flags,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)RegionDataObject_FieldIndex.RadiusWrtPercent) ?? true))
            {
                UInt16XmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.RadiusWrtPercent),
                    item: item.RadiusWrtPercent,
                    fieldIndex: (int)RegionDataObject_FieldIndex.RadiusWrtPercent,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)RegionDataObject_FieldIndex.Radius) ?? true))
            {
                UInt16XmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.Radius),
                    item: item.Radius,
                    fieldIndex: (int)RegionDataObject_FieldIndex.Radius,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)RegionDataObject_FieldIndex.MinHeight) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.MinHeight),
                    item: item.MinHeight,
                    fieldIndex: (int)RegionDataObject_FieldIndex.MinHeight,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)RegionDataObject_FieldIndex.MaxHeight) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.MaxHeight),
                    item: item.MaxHeight,
                    fieldIndex: (int)RegionDataObject_FieldIndex.MaxHeight,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)RegionDataObject_FieldIndex.Sink) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.Sink),
                    item: item.Sink,
                    fieldIndex: (int)RegionDataObject_FieldIndex.Sink,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)RegionDataObject_FieldIndex.SinkVariance) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.SinkVariance),
                    item: item.SinkVariance,
                    fieldIndex: (int)RegionDataObject_FieldIndex.SinkVariance,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)RegionDataObject_FieldIndex.SizeVariance) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.SizeVariance),
                    item: item.SizeVariance,
                    fieldIndex: (int)RegionDataObject_FieldIndex.SizeVariance,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)RegionDataObject_FieldIndex.AngleVariance) ?? true))
            {
                P3UInt16XmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.AngleVariance),
                    item: item.AngleVariance,
                    fieldIndex: (int)RegionDataObject_FieldIndex.AngleVariance,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)RegionDataObject_FieldIndex.Unknown2) ?? true))
            {
                ByteArrayXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.Unknown2),
                    item: item.Unknown2,
                    fieldIndex: (int)RegionDataObject_FieldIndex.Unknown2,
                    errorMask: errorMask);
            }
        }

        public void Write(
            XElement node,
            IRegionDataObjectGetter item,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask,
            string? name = null)
        {
            var elem = new XElement(name ?? "Mutagen.Bethesda.Oblivion.RegionDataObject");
            node.Add(elem);
            if (name != null)
            {
                elem.SetAttributeValue("type", "Mutagen.Bethesda.Oblivion.RegionDataObject");
            }
            WriteToNodeXml(
                item: item,
                node: elem,
                errorMask: errorMask,
                translationMask: translationMask);
        }

        public void Write(
            XElement node,
            object item,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask,
            string? name = null)
        {
            Write(
                item: (IRegionDataObjectGetter)item,
                name: name,
                node: node,
                errorMask: errorMask,
                translationMask: translationMask);
        }

        public void Write(
            XElement node,
            IRegionDataObjectGetter item,
            ErrorMaskBuilder? errorMask,
            int fieldIndex,
            TranslationCrystal? translationMask,
            string? name = null)
        {
            errorMask?.PushIndex(fieldIndex);
            try
            {
                Write(
                    item: (IRegionDataObjectGetter)item,
                    name: name,
                    node: node,
                    errorMask: errorMask,
                    translationMask: translationMask);
            }
            catch (Exception ex)
            when (errorMask != null)
            {
                errorMask.ReportException(ex);
            }
            finally
            {
                errorMask?.PopIndex();
            }
        }

    }

    public partial class RegionDataObjectXmlCreateTranslation
    {
        public readonly static RegionDataObjectXmlCreateTranslation Instance = new RegionDataObjectXmlCreateTranslation();

        public static void FillPublicXml(
            IRegionDataObject item,
            XElement node,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask)
        {
            try
            {
                foreach (var elem in node.Elements())
                {
                    RegionDataObjectXmlCreateTranslation.FillPublicElementXml(
                        item: item,
                        node: elem,
                        name: elem.Name.LocalName,
                        errorMask: errorMask,
                        translationMask: translationMask);
                }
            }
            catch (Exception ex)
            when (errorMask != null)
            {
                errorMask.ReportException(ex);
            }
        }

        public static void FillPublicElementXml(
            IRegionDataObject item,
            XElement node,
            string name,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask)
        {
            switch (name)
            {
                case "Object":
                    errorMask?.PushIndex((int)RegionDataObject_FieldIndex.Object);
                    try
                    {
                        item.Object.FormKey = FormKeyXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "ParentIndex":
                    errorMask?.PushIndex((int)RegionDataObject_FieldIndex.ParentIndex);
                    try
                    {
                        item.ParentIndex = UInt16XmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "Unknown1":
                    errorMask?.PushIndex((int)RegionDataObject_FieldIndex.Unknown1);
                    try
                    {
                        item.Unknown1 = ByteArrayXmlTranslation.Instance.Parse(
                            node: node,
                            fallbackLength: 2,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "Density":
                    errorMask?.PushIndex((int)RegionDataObject_FieldIndex.Density);
                    try
                    {
                        item.Density = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "Clustering":
                    errorMask?.PushIndex((int)RegionDataObject_FieldIndex.Clustering);
                    try
                    {
                        item.Clustering = ByteXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "MinSlope":
                    errorMask?.PushIndex((int)RegionDataObject_FieldIndex.MinSlope);
                    try
                    {
                        item.MinSlope = ByteXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "MaxSlope":
                    errorMask?.PushIndex((int)RegionDataObject_FieldIndex.MaxSlope);
                    try
                    {
                        item.MaxSlope = ByteXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "Flags":
                    errorMask?.PushIndex((int)RegionDataObject_FieldIndex.Flags);
                    try
                    {
                        item.Flags = EnumXmlTranslation<RegionDataObject.Flag>.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "RadiusWrtPercent":
                    errorMask?.PushIndex((int)RegionDataObject_FieldIndex.RadiusWrtPercent);
                    try
                    {
                        item.RadiusWrtPercent = UInt16XmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "Radius":
                    errorMask?.PushIndex((int)RegionDataObject_FieldIndex.Radius);
                    try
                    {
                        item.Radius = UInt16XmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "MinHeight":
                    errorMask?.PushIndex((int)RegionDataObject_FieldIndex.MinHeight);
                    try
                    {
                        item.MinHeight = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "MaxHeight":
                    errorMask?.PushIndex((int)RegionDataObject_FieldIndex.MaxHeight);
                    try
                    {
                        item.MaxHeight = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "Sink":
                    errorMask?.PushIndex((int)RegionDataObject_FieldIndex.Sink);
                    try
                    {
                        item.Sink = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "SinkVariance":
                    errorMask?.PushIndex((int)RegionDataObject_FieldIndex.SinkVariance);
                    try
                    {
                        item.SinkVariance = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "SizeVariance":
                    errorMask?.PushIndex((int)RegionDataObject_FieldIndex.SizeVariance);
                    try
                    {
                        item.SizeVariance = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "AngleVariance":
                    errorMask?.PushIndex((int)RegionDataObject_FieldIndex.AngleVariance);
                    try
                    {
                        item.AngleVariance = P3UInt16XmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "Unknown2":
                    errorMask?.PushIndex((int)RegionDataObject_FieldIndex.Unknown2);
                    try
                    {
                        item.Unknown2 = ByteArrayXmlTranslation.Instance.Parse(
                            node: node,
                            fallbackLength: 6,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                default:
                    break;
            }
        }

    }

}
namespace Mutagen.Bethesda.Oblivion
{
    #region Xml Write Mixins
    public static class RegionDataObjectXmlTranslationMixIn
    {
        public static void WriteToXml(
            this IRegionDataObjectGetter item,
            XElement node,
            out RegionDataObject.ErrorMask errorMask,
            RegionDataObject.TranslationMask? translationMask = null,
            string? name = null)
        {
            ErrorMaskBuilder errorMaskBuilder = new ErrorMaskBuilder();
            ((RegionDataObjectXmlWriteTranslation)item.XmlWriteTranslator).Write(
                item: item,
                name: name,
                node: node,
                errorMask: errorMaskBuilder,
                translationMask: translationMask?.GetCrystal());
            errorMask = RegionDataObject.ErrorMask.Factory(errorMaskBuilder);
        }

        public static void WriteToXml(
            this IRegionDataObjectGetter item,
            string path,
            out RegionDataObject.ErrorMask errorMask,
            RegionDataObject.TranslationMask? translationMask = null,
            string? name = null)
        {
            var node = new XElement("topnode");
            WriteToXml(
                item: item,
                name: name,
                node: node,
                errorMask: out errorMask,
                translationMask: translationMask);
            node.Elements().First().SaveIfChanged(path);
        }

        public static void WriteToXml(
            this IRegionDataObjectGetter item,
            string path,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask = null,
            string? name = null)
        {
            var node = new XElement("topnode");
            WriteToXml(
                item: item,
                name: name,
                node: node,
                errorMask: errorMask,
                translationMask: translationMask);
            node.Elements().First().SaveIfChanged(path);
        }

        public static void WriteToXml(
            this IRegionDataObjectGetter item,
            Stream stream,
            out RegionDataObject.ErrorMask errorMask,
            RegionDataObject.TranslationMask? translationMask = null,
            string? name = null)
        {
            var node = new XElement("topnode");
            WriteToXml(
                item: item,
                name: name,
                node: node,
                errorMask: out errorMask,
                translationMask: translationMask);
            node.Elements().First().Save(stream);
        }

        public static void WriteToXml(
            this IRegionDataObjectGetter item,
            Stream stream,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask = null,
            string? name = null)
        {
            var node = new XElement("topnode");
            WriteToXml(
                item: item,
                name: name,
                node: node,
                errorMask: errorMask,
                translationMask: translationMask);
            node.Elements().First().Save(stream);
        }

        public static void WriteToXml(
            this IRegionDataObjectGetter item,
            XElement node,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask = null,
            string? name = null)
        {
            ((RegionDataObjectXmlWriteTranslation)item.XmlWriteTranslator).Write(
                item: item,
                name: name,
                node: node,
                errorMask: errorMask,
                translationMask: translationMask);
        }

        public static void WriteToXml(
            this IRegionDataObjectGetter item,
            XElement node,
            string? name = null,
            RegionDataObject.TranslationMask? translationMask = null)
        {
            ((RegionDataObjectXmlWriteTranslation)item.XmlWriteTranslator).Write(
                item: item,
                name: name,
                node: node,
                errorMask: null,
                translationMask: translationMask?.GetCrystal());
        }

        public static void WriteToXml(
            this IRegionDataObjectGetter item,
            string path,
            string? name = null)
        {
            var node = new XElement("topnode");
            ((RegionDataObjectXmlWriteTranslation)item.XmlWriteTranslator).Write(
                item: item,
                name: name,
                node: node,
                errorMask: null,
                translationMask: null);
            node.Elements().First().SaveIfChanged(path);
        }

        public static void WriteToXml(
            this IRegionDataObjectGetter item,
            Stream stream,
            string? name = null)
        {
            var node = new XElement("topnode");
            ((RegionDataObjectXmlWriteTranslation)item.XmlWriteTranslator).Write(
                item: item,
                name: name,
                node: node,
                errorMask: null,
                translationMask: null);
            node.Elements().First().Save(stream);
        }

    }
    #endregion


}
#endregion

#region Binary Translation
namespace Mutagen.Bethesda.Oblivion.Internals
{
    public partial class RegionDataObjectBinaryWriteTranslation : IBinaryWriteTranslator
    {
        public readonly static RegionDataObjectBinaryWriteTranslation Instance = new RegionDataObjectBinaryWriteTranslation();

        public static void WriteEmbedded(
            IRegionDataObjectGetter item,
            MutagenWriter writer)
        {
            Mutagen.Bethesda.Binary.FormLinkBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.Object);
            writer.Write(item.ParentIndex);
            Mutagen.Bethesda.Binary.ByteArrayBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.Unknown1);
            Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.Density);
            writer.Write(item.Clustering);
            writer.Write(item.MinSlope);
            writer.Write(item.MaxSlope);
            Mutagen.Bethesda.Binary.EnumBinaryTranslation<RegionDataObject.Flag>.Instance.Write(
                writer,
                item.Flags,
                length: 1);
            writer.Write(item.RadiusWrtPercent);
            writer.Write(item.Radius);
            Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.MinHeight);
            Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.MaxHeight);
            Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.Sink);
            Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.SinkVariance);
            Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.SizeVariance);
            Mutagen.Bethesda.Binary.P3UInt16BinaryTranslation.Instance.Write(
                writer: writer,
                item: item.AngleVariance);
            Mutagen.Bethesda.Binary.ByteArrayBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.Unknown2);
        }

        public void Write(
            MutagenWriter writer,
            IRegionDataObjectGetter item,
            RecordTypeConverter? recordTypeConverter = null)
        {
            WriteEmbedded(
                item: item,
                writer: writer);
        }

        public void Write(
            MutagenWriter writer,
            object item,
            RecordTypeConverter? recordTypeConverter = null)
        {
            Write(
                item: (IRegionDataObjectGetter)item,
                writer: writer,
                recordTypeConverter: recordTypeConverter);
        }

    }

    public partial class RegionDataObjectBinaryCreateTranslation
    {
        public readonly static RegionDataObjectBinaryCreateTranslation Instance = new RegionDataObjectBinaryCreateTranslation();

    }

}
namespace Mutagen.Bethesda.Oblivion
{
    #region Binary Write Mixins
    public static class RegionDataObjectBinaryTranslationMixIn
    {
        public static void WriteToBinary(
            this IRegionDataObjectGetter item,
            MutagenWriter writer)
        {
            ((RegionDataObjectBinaryWriteTranslation)item.BinaryWriteTranslator).Write(
                item: item,
                writer: writer,
                recordTypeConverter: null);
        }

    }
    #endregion


}
namespace Mutagen.Bethesda.Oblivion.Internals
{
    public partial class RegionDataObjectBinaryOverlay :
        BinaryOverlay,
        IRegionDataObjectGetter
    {
        #region Common Routing
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILoquiRegistration ILoquiObject.Registration => RegionDataObject_Registration.Instance;
        public static RegionDataObject_Registration Registration => RegionDataObject_Registration.Instance;
        [DebuggerStepThrough]
        protected object CommonInstance() => RegionDataObjectCommon.Instance;
        [DebuggerStepThrough]
        protected object CommonSetterTranslationInstance() => RegionDataObjectSetterTranslationCommon.Instance;
        [DebuggerStepThrough]
        object IRegionDataObjectGetter.CommonInstance() => this.CommonInstance();
        [DebuggerStepThrough]
        object? IRegionDataObjectGetter.CommonSetterInstance() => null;
        [DebuggerStepThrough]
        object IRegionDataObjectGetter.CommonSetterTranslationInstance() => this.CommonSetterTranslationInstance();

        #endregion

        void IPrintable.ToString(FileGeneration fg, string? name) => this.ToString(fg, name);
        IMask<bool> ILoquiObjectGetter.GetHasBeenSetIMask() => this.GetHasBeenSetMask();
        IMask<bool> IEqualsMask.GetEqualsIMask(object rhs, EqualsMaskHelper.Include include) => this.GetEqualsMask((IRegionDataObjectGetter)rhs, include);

        public IEnumerable<ILinkGetter> Links => RegionDataObjectCommon.Instance.GetLinks(this);
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected object XmlWriteTranslator => RegionDataObjectXmlWriteTranslation.Instance;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        object IXmlItem.XmlWriteTranslator => this.XmlWriteTranslator;
        void IXmlItem.WriteToXml(
            XElement node,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask,
            string? name = null)
        {
            ((RegionDataObjectXmlWriteTranslation)this.XmlWriteTranslator).Write(
                item: this,
                name: name,
                node: node,
                errorMask: errorMask,
                translationMask: translationMask);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected object BinaryWriteTranslator => RegionDataObjectBinaryWriteTranslation.Instance;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        object IBinaryItem.BinaryWriteTranslator => this.BinaryWriteTranslator;
        void IBinaryItem.WriteToBinary(
            MutagenWriter writer,
            RecordTypeConverter? recordTypeConverter = null)
        {
            ((RegionDataObjectBinaryWriteTranslation)this.BinaryWriteTranslator).Write(
                item: this,
                writer: writer,
                recordTypeConverter: recordTypeConverter);
        }

        public IFormLinkGetter<IOblivionMajorRecordGetter> Object => new FormLink<IOblivionMajorRecordGetter>(FormKey.Factory(_package.MasterReferences!, BinaryPrimitives.ReadUInt32LittleEndian(_data.Span.Slice(0x0, 0x4))));
        public UInt16 ParentIndex => BinaryPrimitives.ReadUInt16LittleEndian(_data.Slice(0x4, 0x2));
        public ReadOnlyMemorySlice<Byte> Unknown1 => _data.Span.Slice(0x6, 0x2).ToArray();
        public Single Density => SpanExt.GetFloat(_data.Slice(0x8, 0x4));
        public Byte Clustering => _data.Span[0xC];
        public Byte MinSlope => _data.Span[0xD];
        public Byte MaxSlope => _data.Span[0xE];
        public RegionDataObject.Flag Flags => (RegionDataObject.Flag)_data.Span.Slice(0xF, 0x1)[0];
        public UInt16 RadiusWrtPercent => BinaryPrimitives.ReadUInt16LittleEndian(_data.Slice(0x10, 0x2));
        public UInt16 Radius => BinaryPrimitives.ReadUInt16LittleEndian(_data.Slice(0x12, 0x2));
        public Single MinHeight => SpanExt.GetFloat(_data.Slice(0x14, 0x4));
        public Single MaxHeight => SpanExt.GetFloat(_data.Slice(0x18, 0x4));
        public Single Sink => SpanExt.GetFloat(_data.Slice(0x1C, 0x4));
        public Single SinkVariance => SpanExt.GetFloat(_data.Slice(0x20, 0x4));
        public Single SizeVariance => SpanExt.GetFloat(_data.Slice(0x24, 0x4));
        public P3UInt16 AngleVariance => P3UInt16BinaryTranslation.Read(_data.Slice(0x28, 0x6));
        public ReadOnlyMemorySlice<Byte> Unknown2 => _data.Span.Slice(0x2E, 0x6).ToArray();
        partial void CustomCtor(
            IBinaryReadStream stream,
            int finalPos,
            int offset);

        protected RegionDataObjectBinaryOverlay(
            ReadOnlyMemorySlice<byte> bytes,
            BinaryOverlayFactoryPackage package)
            : base(
                bytes: bytes,
                package: package)
        {
        }

        public static RegionDataObjectBinaryOverlay RegionDataObjectFactory(
            BinaryMemoryReadStream stream,
            BinaryOverlayFactoryPackage package,
            RecordTypeConverter? recordTypeConverter = null)
        {
            var ret = new RegionDataObjectBinaryOverlay(
                bytes: stream.RemainingMemory.Slice(0, 0x34),
                package: package);
            int offset = stream.Position;
            stream.Position += 0x34;
            ret.CustomCtor(
                stream: stream,
                finalPos: stream.Length,
                offset: offset);
            return ret;
        }

        public static RegionDataObjectBinaryOverlay RegionDataObjectFactory(
            ReadOnlyMemorySlice<byte> slice,
            BinaryOverlayFactoryPackage package,
            RecordTypeConverter? recordTypeConverter = null)
        {
            return RegionDataObjectFactory(
                stream: new BinaryMemoryReadStream(slice),
                package: package,
                recordTypeConverter: recordTypeConverter);
        }

        #region To String

        public void ToString(
            FileGeneration fg,
            string? name = null)
        {
            RegionDataObjectMixIn.ToString(
                item: this,
                name: name);
        }

        #endregion

    }

}
#endregion

#endregion

