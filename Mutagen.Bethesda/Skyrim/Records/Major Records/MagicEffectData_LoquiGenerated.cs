/*
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
 * Autogenerated by Loqui.  Do not manually change.
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
*/
#region Usings
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Loqui;
using Loqui.Internal;
using Noggog;
using Mutagen.Bethesda.Skyrim.Internals;
using System.Reactive.Disposables;
using System.Reactive.Linq;
using Mutagen.Bethesda.Skyrim;
using System.Xml;
using System.Xml.Linq;
using System.IO;
using Noggog.Xml;
using Loqui.Xml;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using Mutagen.Bethesda.Binary;
using System.Buffers.Binary;
using Mutagen.Bethesda.Internals;
#endregion

#nullable enable
namespace Mutagen.Bethesda.Skyrim
{
    #region Class
    public partial class MagicEffectData :
        IMagicEffectData,
        ILoquiObjectSetter<MagicEffectData>,
        IEquatable<MagicEffectData>,
        IEqualsMask
    {
        #region Ctor
        public MagicEffectData()
        {
            CustomCtor();
        }
        partial void CustomCtor();
        #endregion

        #region Flags
        public MagicEffect.Flag Flags { get; set; } = default;
        #endregion
        #region BaseCost
        public Single BaseCost { get; set; } = default;
        #endregion
        #region MagicSkill
        public ActorValueExtended MagicSkill { get; set; } = default;
        #endregion
        #region ResistValue
        public ActorValueExtended ResistValue { get; set; } = default;
        #endregion
        #region CounterEffectCount
        public UInt16 CounterEffectCount { get; set; } = default;
        #endregion
        #region Unknown1
        public UInt16 Unknown1 { get; set; } = default;
        #endregion
        #region CastingLight
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected IFormLink<Light> _CastingLight = new FormLink<Light>();
        public IFormLink<Light> CastingLight => this._CastingLight;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkGetter<ILightGetter> IMagicEffectDataGetter.CastingLight => this.CastingLight;
        #endregion
        #region TaperWeight
        public Single TaperWeight { get; set; } = default;
        #endregion
        #region HitShader
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected IFormLink<EffectShader> _HitShader = new FormLink<EffectShader>();
        public IFormLink<EffectShader> HitShader => this._HitShader;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkGetter<IEffectShaderGetter> IMagicEffectDataGetter.HitShader => this.HitShader;
        #endregion
        #region EnchantShader
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected IFormLink<EffectShader> _EnchantShader = new FormLink<EffectShader>();
        public IFormLink<EffectShader> EnchantShader => this._EnchantShader;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkGetter<IEffectShaderGetter> IMagicEffectDataGetter.EnchantShader => this.EnchantShader;
        #endregion
        #region MinimumSkillLevel
        public UInt32 MinimumSkillLevel { get; set; } = default;
        #endregion
        #region SpellmakingArea
        public UInt32 SpellmakingArea { get; set; } = default;
        #endregion
        #region SpellmakingCastingTime
        public Single SpellmakingCastingTime { get; set; } = default;
        #endregion
        #region TaperCurve
        public Single TaperCurve { get; set; } = default;
        #endregion
        #region TaperDuration
        public Single TaperDuration { get; set; } = default;
        #endregion
        #region SecondActorValueWeight
        public Single SecondActorValueWeight { get; set; } = default;
        #endregion
        #region Archetype
        public MagicEffectArchetype Archetype { get; set; } = new MagicEffectArchetype();
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IMagicEffectArchetypeGetter IMagicEffectDataGetter.Archetype => Archetype;
        #endregion
        #region Projectile
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected IFormLink<Projectile> _Projectile = new FormLink<Projectile>();
        public IFormLink<Projectile> Projectile => this._Projectile;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkGetter<IProjectileGetter> IMagicEffectDataGetter.Projectile => this.Projectile;
        #endregion
        #region Explosion
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected IFormLink<Explosion> _Explosion = new FormLink<Explosion>();
        public IFormLink<Explosion> Explosion => this._Explosion;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkGetter<IExplosionGetter> IMagicEffectDataGetter.Explosion => this.Explosion;
        #endregion
        #region CastType
        public CastType CastType { get; set; } = default;
        #endregion
        #region TargetType
        public TargetType TargetType { get; set; } = default;
        #endregion
        #region SecondActorValue
        public ActorValueExtended SecondActorValue { get; set; } = default;
        #endregion
        #region CastingArt
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected IFormLink<ArtObject> _CastingArt = new FormLink<ArtObject>();
        public IFormLink<ArtObject> CastingArt => this._CastingArt;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkGetter<IArtObjectGetter> IMagicEffectDataGetter.CastingArt => this.CastingArt;
        #endregion
        #region HitEffectArt
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected IFormLink<ArtObject> _HitEffectArt = new FormLink<ArtObject>();
        public IFormLink<ArtObject> HitEffectArt => this._HitEffectArt;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkGetter<IArtObjectGetter> IMagicEffectDataGetter.HitEffectArt => this.HitEffectArt;
        #endregion
        #region ImpactData
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected IFormLink<ImpactDataSet> _ImpactData = new FormLink<ImpactDataSet>();
        public IFormLink<ImpactDataSet> ImpactData => this._ImpactData;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkGetter<IImpactDataSetGetter> IMagicEffectDataGetter.ImpactData => this.ImpactData;
        #endregion
        #region SkillUsageMultiplier
        public Single SkillUsageMultiplier { get; set; } = default;
        #endregion
        #region DualCastArt
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected IFormLink<DualCastData> _DualCastArt = new FormLink<DualCastData>();
        public IFormLink<DualCastData> DualCastArt => this._DualCastArt;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkGetter<IDualCastDataGetter> IMagicEffectDataGetter.DualCastArt => this.DualCastArt;
        #endregion
        #region DualCastScale
        public Single DualCastScale { get; set; } = default;
        #endregion
        #region EnchantArt
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected IFormLink<ArtObject> _EnchantArt = new FormLink<ArtObject>();
        public IFormLink<ArtObject> EnchantArt => this._EnchantArt;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkGetter<IArtObjectGetter> IMagicEffectDataGetter.EnchantArt => this.EnchantArt;
        #endregion
        #region Unknown2
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected IFormLink<SkyrimMajorRecord> _Unknown2 = new FormLink<SkyrimMajorRecord>();
        public IFormLink<SkyrimMajorRecord> Unknown2 => this._Unknown2;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkGetter<ISkyrimMajorRecordGetter> IMagicEffectDataGetter.Unknown2 => this.Unknown2;
        #endregion
        #region Unknown3
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected IFormLink<SkyrimMajorRecord> _Unknown3 = new FormLink<SkyrimMajorRecord>();
        public IFormLink<SkyrimMajorRecord> Unknown3 => this._Unknown3;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkGetter<ISkyrimMajorRecordGetter> IMagicEffectDataGetter.Unknown3 => this.Unknown3;
        #endregion
        #region EquipAbility
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected IFormLink<Spell> _EquipAbility = new FormLink<Spell>();
        public IFormLink<Spell> EquipAbility => this._EquipAbility;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkGetter<ISpellGetter> IMagicEffectDataGetter.EquipAbility => this.EquipAbility;
        #endregion
        #region ImageSpaceModifier
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected IFormLink<ImageSpaceAdapter> _ImageSpaceModifier = new FormLink<ImageSpaceAdapter>();
        public IFormLink<ImageSpaceAdapter> ImageSpaceModifier => this._ImageSpaceModifier;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkGetter<IImageSpaceAdapterGetter> IMagicEffectDataGetter.ImageSpaceModifier => this.ImageSpaceModifier;
        #endregion
        #region PerkToApply
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected IFormLink<Perk> _PerkToApply = new FormLink<Perk>();
        public IFormLink<Perk> PerkToApply => this._PerkToApply;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkGetter<IPerkGetter> IMagicEffectDataGetter.PerkToApply => this.PerkToApply;
        #endregion
        #region CastingSoundLevel
        public SoundLevel CastingSoundLevel { get; set; } = default;
        #endregion
        #region ScriptEffectAIScore
        public Single ScriptEffectAIScore { get; set; } = default;
        #endregion
        #region ScriptEffectAIDelayTime
        public Single ScriptEffectAIDelayTime { get; set; } = default;
        #endregion

        #region To String

        public void ToString(
            FileGeneration fg,
            string? name = null)
        {
            MagicEffectDataMixIn.ToString(
                item: this,
                name: name);
        }

        #endregion

        #region Equals and Hash
        public override bool Equals(object? obj)
        {
            if (!(obj is IMagicEffectDataGetter rhs)) return false;
            return ((MagicEffectDataCommon)((IMagicEffectDataGetter)this).CommonInstance()!).Equals(this, rhs);
        }

        public bool Equals(MagicEffectData obj)
        {
            return ((MagicEffectDataCommon)((IMagicEffectDataGetter)this).CommonInstance()!).Equals(this, obj);
        }

        public override int GetHashCode() => ((MagicEffectDataCommon)((IMagicEffectDataGetter)this).CommonInstance()!).GetHashCode(this);

        #endregion

        #region Xml Translation
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected object XmlWriteTranslator => MagicEffectDataXmlWriteTranslation.Instance;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        object IXmlItem.XmlWriteTranslator => this.XmlWriteTranslator;
        void IXmlItem.WriteToXml(
            XElement node,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask,
            string? name = null)
        {
            ((MagicEffectDataXmlWriteTranslation)this.XmlWriteTranslator).Write(
                item: this,
                name: name,
                node: node,
                errorMask: errorMask,
                translationMask: translationMask);
        }
        #region Xml Create
        [DebuggerStepThrough]
        public static MagicEffectData CreateFromXml(
            XElement node,
            MagicEffectData.TranslationMask? translationMask = null)
        {
            return CreateFromXml(
                node: node,
                errorMask: null,
                translationMask: translationMask?.GetCrystal());
        }

        [DebuggerStepThrough]
        public static MagicEffectData CreateFromXml(
            XElement node,
            out MagicEffectData.ErrorMask errorMask,
            MagicEffectData.TranslationMask? translationMask = null)
        {
            ErrorMaskBuilder errorMaskBuilder = new ErrorMaskBuilder();
            var ret = CreateFromXml(
                node: node,
                errorMask: errorMaskBuilder,
                translationMask: translationMask?.GetCrystal());
            errorMask = MagicEffectData.ErrorMask.Factory(errorMaskBuilder);
            return ret;
        }

        public static MagicEffectData CreateFromXml(
            XElement node,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask)
        {
            var ret = new MagicEffectData();
            ((MagicEffectDataSetterCommon)((IMagicEffectDataGetter)ret).CommonSetterInstance()!).CopyInFromXml(
                item: ret,
                node: node,
                errorMask: errorMask,
                translationMask: translationMask);
            return ret;
        }

        public static MagicEffectData CreateFromXml(
            string path,
            MagicEffectData.TranslationMask? translationMask = null)
        {
            var node = XDocument.Load(path).Root;
            return CreateFromXml(
                node: node,
                translationMask: translationMask);
        }

        public static MagicEffectData CreateFromXml(
            string path,
            out MagicEffectData.ErrorMask errorMask,
            MagicEffectData.TranslationMask? translationMask = null)
        {
            var node = XDocument.Load(path).Root;
            return CreateFromXml(
                node: node,
                errorMask: out errorMask,
                translationMask: translationMask);
        }

        public static MagicEffectData CreateFromXml(
            string path,
            ErrorMaskBuilder? errorMask,
            MagicEffectData.TranslationMask? translationMask = null)
        {
            var node = XDocument.Load(path).Root;
            return CreateFromXml(
                node: node,
                errorMask: errorMask,
                translationMask: translationMask?.GetCrystal());
        }

        public static MagicEffectData CreateFromXml(
            Stream stream,
            MagicEffectData.TranslationMask? translationMask = null)
        {
            var node = XDocument.Load(stream).Root;
            return CreateFromXml(
                node: node,
                translationMask: translationMask);
        }

        public static MagicEffectData CreateFromXml(
            Stream stream,
            out MagicEffectData.ErrorMask errorMask,
            MagicEffectData.TranslationMask? translationMask = null)
        {
            var node = XDocument.Load(stream).Root;
            return CreateFromXml(
                node: node,
                errorMask: out errorMask,
                translationMask: translationMask);
        }

        public static MagicEffectData CreateFromXml(
            Stream stream,
            ErrorMaskBuilder? errorMask,
            MagicEffectData.TranslationMask? translationMask = null)
        {
            var node = XDocument.Load(stream).Root;
            return CreateFromXml(
                node: node,
                errorMask: errorMask,
                translationMask: translationMask?.GetCrystal());
        }

        #endregion

        #endregion

        #region Mask
        public class Mask<TItem> :
            IMask<TItem>,
            IEquatable<Mask<TItem>>
            where TItem : notnull
        {
            #region Ctors
            public Mask(TItem initialValue)
            {
                this.Flags = initialValue;
                this.BaseCost = initialValue;
                this.MagicSkill = initialValue;
                this.ResistValue = initialValue;
                this.CounterEffectCount = initialValue;
                this.Unknown1 = initialValue;
                this.CastingLight = initialValue;
                this.TaperWeight = initialValue;
                this.HitShader = initialValue;
                this.EnchantShader = initialValue;
                this.MinimumSkillLevel = initialValue;
                this.SpellmakingArea = initialValue;
                this.SpellmakingCastingTime = initialValue;
                this.TaperCurve = initialValue;
                this.TaperDuration = initialValue;
                this.SecondActorValueWeight = initialValue;
                this.Archetype = new MaskItem<TItem, MagicEffectArchetype.Mask<TItem>?>(initialValue, new MagicEffectArchetype.Mask<TItem>(initialValue));
                this.Projectile = initialValue;
                this.Explosion = initialValue;
                this.CastType = initialValue;
                this.TargetType = initialValue;
                this.SecondActorValue = initialValue;
                this.CastingArt = initialValue;
                this.HitEffectArt = initialValue;
                this.ImpactData = initialValue;
                this.SkillUsageMultiplier = initialValue;
                this.DualCastArt = initialValue;
                this.DualCastScale = initialValue;
                this.EnchantArt = initialValue;
                this.Unknown2 = initialValue;
                this.Unknown3 = initialValue;
                this.EquipAbility = initialValue;
                this.ImageSpaceModifier = initialValue;
                this.PerkToApply = initialValue;
                this.CastingSoundLevel = initialValue;
                this.ScriptEffectAIScore = initialValue;
                this.ScriptEffectAIDelayTime = initialValue;
            }

            public Mask(
                TItem Flags,
                TItem BaseCost,
                TItem MagicSkill,
                TItem ResistValue,
                TItem CounterEffectCount,
                TItem Unknown1,
                TItem CastingLight,
                TItem TaperWeight,
                TItem HitShader,
                TItem EnchantShader,
                TItem MinimumSkillLevel,
                TItem SpellmakingArea,
                TItem SpellmakingCastingTime,
                TItem TaperCurve,
                TItem TaperDuration,
                TItem SecondActorValueWeight,
                TItem Archetype,
                TItem Projectile,
                TItem Explosion,
                TItem CastType,
                TItem TargetType,
                TItem SecondActorValue,
                TItem CastingArt,
                TItem HitEffectArt,
                TItem ImpactData,
                TItem SkillUsageMultiplier,
                TItem DualCastArt,
                TItem DualCastScale,
                TItem EnchantArt,
                TItem Unknown2,
                TItem Unknown3,
                TItem EquipAbility,
                TItem ImageSpaceModifier,
                TItem PerkToApply,
                TItem CastingSoundLevel,
                TItem ScriptEffectAIScore,
                TItem ScriptEffectAIDelayTime)
            {
                this.Flags = Flags;
                this.BaseCost = BaseCost;
                this.MagicSkill = MagicSkill;
                this.ResistValue = ResistValue;
                this.CounterEffectCount = CounterEffectCount;
                this.Unknown1 = Unknown1;
                this.CastingLight = CastingLight;
                this.TaperWeight = TaperWeight;
                this.HitShader = HitShader;
                this.EnchantShader = EnchantShader;
                this.MinimumSkillLevel = MinimumSkillLevel;
                this.SpellmakingArea = SpellmakingArea;
                this.SpellmakingCastingTime = SpellmakingCastingTime;
                this.TaperCurve = TaperCurve;
                this.TaperDuration = TaperDuration;
                this.SecondActorValueWeight = SecondActorValueWeight;
                this.Archetype = new MaskItem<TItem, MagicEffectArchetype.Mask<TItem>?>(Archetype, new MagicEffectArchetype.Mask<TItem>(Archetype));
                this.Projectile = Projectile;
                this.Explosion = Explosion;
                this.CastType = CastType;
                this.TargetType = TargetType;
                this.SecondActorValue = SecondActorValue;
                this.CastingArt = CastingArt;
                this.HitEffectArt = HitEffectArt;
                this.ImpactData = ImpactData;
                this.SkillUsageMultiplier = SkillUsageMultiplier;
                this.DualCastArt = DualCastArt;
                this.DualCastScale = DualCastScale;
                this.EnchantArt = EnchantArt;
                this.Unknown2 = Unknown2;
                this.Unknown3 = Unknown3;
                this.EquipAbility = EquipAbility;
                this.ImageSpaceModifier = ImageSpaceModifier;
                this.PerkToApply = PerkToApply;
                this.CastingSoundLevel = CastingSoundLevel;
                this.ScriptEffectAIScore = ScriptEffectAIScore;
                this.ScriptEffectAIDelayTime = ScriptEffectAIDelayTime;
            }

            #pragma warning disable CS8618
            protected Mask()
            {
            }
            #pragma warning restore CS8618

            #endregion

            #region Members
            public TItem Flags;
            public TItem BaseCost;
            public TItem MagicSkill;
            public TItem ResistValue;
            public TItem CounterEffectCount;
            public TItem Unknown1;
            public TItem CastingLight;
            public TItem TaperWeight;
            public TItem HitShader;
            public TItem EnchantShader;
            public TItem MinimumSkillLevel;
            public TItem SpellmakingArea;
            public TItem SpellmakingCastingTime;
            public TItem TaperCurve;
            public TItem TaperDuration;
            public TItem SecondActorValueWeight;
            public MaskItem<TItem, MagicEffectArchetype.Mask<TItem>?>? Archetype { get; set; }
            public TItem Projectile;
            public TItem Explosion;
            public TItem CastType;
            public TItem TargetType;
            public TItem SecondActorValue;
            public TItem CastingArt;
            public TItem HitEffectArt;
            public TItem ImpactData;
            public TItem SkillUsageMultiplier;
            public TItem DualCastArt;
            public TItem DualCastScale;
            public TItem EnchantArt;
            public TItem Unknown2;
            public TItem Unknown3;
            public TItem EquipAbility;
            public TItem ImageSpaceModifier;
            public TItem PerkToApply;
            public TItem CastingSoundLevel;
            public TItem ScriptEffectAIScore;
            public TItem ScriptEffectAIDelayTime;
            #endregion

            #region Equals
            public override bool Equals(object? obj)
            {
                if (!(obj is Mask<TItem> rhs)) return false;
                return Equals(rhs);
            }

            public bool Equals(Mask<TItem> rhs)
            {
                if (rhs == null) return false;
                if (!object.Equals(this.Flags, rhs.Flags)) return false;
                if (!object.Equals(this.BaseCost, rhs.BaseCost)) return false;
                if (!object.Equals(this.MagicSkill, rhs.MagicSkill)) return false;
                if (!object.Equals(this.ResistValue, rhs.ResistValue)) return false;
                if (!object.Equals(this.CounterEffectCount, rhs.CounterEffectCount)) return false;
                if (!object.Equals(this.Unknown1, rhs.Unknown1)) return false;
                if (!object.Equals(this.CastingLight, rhs.CastingLight)) return false;
                if (!object.Equals(this.TaperWeight, rhs.TaperWeight)) return false;
                if (!object.Equals(this.HitShader, rhs.HitShader)) return false;
                if (!object.Equals(this.EnchantShader, rhs.EnchantShader)) return false;
                if (!object.Equals(this.MinimumSkillLevel, rhs.MinimumSkillLevel)) return false;
                if (!object.Equals(this.SpellmakingArea, rhs.SpellmakingArea)) return false;
                if (!object.Equals(this.SpellmakingCastingTime, rhs.SpellmakingCastingTime)) return false;
                if (!object.Equals(this.TaperCurve, rhs.TaperCurve)) return false;
                if (!object.Equals(this.TaperDuration, rhs.TaperDuration)) return false;
                if (!object.Equals(this.SecondActorValueWeight, rhs.SecondActorValueWeight)) return false;
                if (!object.Equals(this.Archetype, rhs.Archetype)) return false;
                if (!object.Equals(this.Projectile, rhs.Projectile)) return false;
                if (!object.Equals(this.Explosion, rhs.Explosion)) return false;
                if (!object.Equals(this.CastType, rhs.CastType)) return false;
                if (!object.Equals(this.TargetType, rhs.TargetType)) return false;
                if (!object.Equals(this.SecondActorValue, rhs.SecondActorValue)) return false;
                if (!object.Equals(this.CastingArt, rhs.CastingArt)) return false;
                if (!object.Equals(this.HitEffectArt, rhs.HitEffectArt)) return false;
                if (!object.Equals(this.ImpactData, rhs.ImpactData)) return false;
                if (!object.Equals(this.SkillUsageMultiplier, rhs.SkillUsageMultiplier)) return false;
                if (!object.Equals(this.DualCastArt, rhs.DualCastArt)) return false;
                if (!object.Equals(this.DualCastScale, rhs.DualCastScale)) return false;
                if (!object.Equals(this.EnchantArt, rhs.EnchantArt)) return false;
                if (!object.Equals(this.Unknown2, rhs.Unknown2)) return false;
                if (!object.Equals(this.Unknown3, rhs.Unknown3)) return false;
                if (!object.Equals(this.EquipAbility, rhs.EquipAbility)) return false;
                if (!object.Equals(this.ImageSpaceModifier, rhs.ImageSpaceModifier)) return false;
                if (!object.Equals(this.PerkToApply, rhs.PerkToApply)) return false;
                if (!object.Equals(this.CastingSoundLevel, rhs.CastingSoundLevel)) return false;
                if (!object.Equals(this.ScriptEffectAIScore, rhs.ScriptEffectAIScore)) return false;
                if (!object.Equals(this.ScriptEffectAIDelayTime, rhs.ScriptEffectAIDelayTime)) return false;
                return true;
            }
            public override int GetHashCode()
            {
                var hash = new HashCode();
                hash.Add(this.Flags);
                hash.Add(this.BaseCost);
                hash.Add(this.MagicSkill);
                hash.Add(this.ResistValue);
                hash.Add(this.CounterEffectCount);
                hash.Add(this.Unknown1);
                hash.Add(this.CastingLight);
                hash.Add(this.TaperWeight);
                hash.Add(this.HitShader);
                hash.Add(this.EnchantShader);
                hash.Add(this.MinimumSkillLevel);
                hash.Add(this.SpellmakingArea);
                hash.Add(this.SpellmakingCastingTime);
                hash.Add(this.TaperCurve);
                hash.Add(this.TaperDuration);
                hash.Add(this.SecondActorValueWeight);
                hash.Add(this.Archetype);
                hash.Add(this.Projectile);
                hash.Add(this.Explosion);
                hash.Add(this.CastType);
                hash.Add(this.TargetType);
                hash.Add(this.SecondActorValue);
                hash.Add(this.CastingArt);
                hash.Add(this.HitEffectArt);
                hash.Add(this.ImpactData);
                hash.Add(this.SkillUsageMultiplier);
                hash.Add(this.DualCastArt);
                hash.Add(this.DualCastScale);
                hash.Add(this.EnchantArt);
                hash.Add(this.Unknown2);
                hash.Add(this.Unknown3);
                hash.Add(this.EquipAbility);
                hash.Add(this.ImageSpaceModifier);
                hash.Add(this.PerkToApply);
                hash.Add(this.CastingSoundLevel);
                hash.Add(this.ScriptEffectAIScore);
                hash.Add(this.ScriptEffectAIDelayTime);
                return hash.ToHashCode();
            }

            #endregion

            #region All
            public bool All(Func<TItem, bool> eval)
            {
                if (!eval(this.Flags)) return false;
                if (!eval(this.BaseCost)) return false;
                if (!eval(this.MagicSkill)) return false;
                if (!eval(this.ResistValue)) return false;
                if (!eval(this.CounterEffectCount)) return false;
                if (!eval(this.Unknown1)) return false;
                if (!eval(this.CastingLight)) return false;
                if (!eval(this.TaperWeight)) return false;
                if (!eval(this.HitShader)) return false;
                if (!eval(this.EnchantShader)) return false;
                if (!eval(this.MinimumSkillLevel)) return false;
                if (!eval(this.SpellmakingArea)) return false;
                if (!eval(this.SpellmakingCastingTime)) return false;
                if (!eval(this.TaperCurve)) return false;
                if (!eval(this.TaperDuration)) return false;
                if (!eval(this.SecondActorValueWeight)) return false;
                if (Archetype != null)
                {
                    if (!eval(this.Archetype.Overall)) return false;
                    if (this.Archetype.Specific != null && !this.Archetype.Specific.All(eval)) return false;
                }
                if (!eval(this.Projectile)) return false;
                if (!eval(this.Explosion)) return false;
                if (!eval(this.CastType)) return false;
                if (!eval(this.TargetType)) return false;
                if (!eval(this.SecondActorValue)) return false;
                if (!eval(this.CastingArt)) return false;
                if (!eval(this.HitEffectArt)) return false;
                if (!eval(this.ImpactData)) return false;
                if (!eval(this.SkillUsageMultiplier)) return false;
                if (!eval(this.DualCastArt)) return false;
                if (!eval(this.DualCastScale)) return false;
                if (!eval(this.EnchantArt)) return false;
                if (!eval(this.Unknown2)) return false;
                if (!eval(this.Unknown3)) return false;
                if (!eval(this.EquipAbility)) return false;
                if (!eval(this.ImageSpaceModifier)) return false;
                if (!eval(this.PerkToApply)) return false;
                if (!eval(this.CastingSoundLevel)) return false;
                if (!eval(this.ScriptEffectAIScore)) return false;
                if (!eval(this.ScriptEffectAIDelayTime)) return false;
                return true;
            }
            #endregion

            #region Any
            public bool Any(Func<TItem, bool> eval)
            {
                if (eval(this.Flags)) return true;
                if (eval(this.BaseCost)) return true;
                if (eval(this.MagicSkill)) return true;
                if (eval(this.ResistValue)) return true;
                if (eval(this.CounterEffectCount)) return true;
                if (eval(this.Unknown1)) return true;
                if (eval(this.CastingLight)) return true;
                if (eval(this.TaperWeight)) return true;
                if (eval(this.HitShader)) return true;
                if (eval(this.EnchantShader)) return true;
                if (eval(this.MinimumSkillLevel)) return true;
                if (eval(this.SpellmakingArea)) return true;
                if (eval(this.SpellmakingCastingTime)) return true;
                if (eval(this.TaperCurve)) return true;
                if (eval(this.TaperDuration)) return true;
                if (eval(this.SecondActorValueWeight)) return true;
                if (Archetype != null)
                {
                    if (eval(this.Archetype.Overall)) return true;
                    if (this.Archetype.Specific != null && this.Archetype.Specific.Any(eval)) return true;
                }
                if (eval(this.Projectile)) return true;
                if (eval(this.Explosion)) return true;
                if (eval(this.CastType)) return true;
                if (eval(this.TargetType)) return true;
                if (eval(this.SecondActorValue)) return true;
                if (eval(this.CastingArt)) return true;
                if (eval(this.HitEffectArt)) return true;
                if (eval(this.ImpactData)) return true;
                if (eval(this.SkillUsageMultiplier)) return true;
                if (eval(this.DualCastArt)) return true;
                if (eval(this.DualCastScale)) return true;
                if (eval(this.EnchantArt)) return true;
                if (eval(this.Unknown2)) return true;
                if (eval(this.Unknown3)) return true;
                if (eval(this.EquipAbility)) return true;
                if (eval(this.ImageSpaceModifier)) return true;
                if (eval(this.PerkToApply)) return true;
                if (eval(this.CastingSoundLevel)) return true;
                if (eval(this.ScriptEffectAIScore)) return true;
                if (eval(this.ScriptEffectAIDelayTime)) return true;
                return false;
            }
            #endregion

            #region Translate
            public Mask<R> Translate<R>(Func<TItem, R> eval)
            {
                var ret = new MagicEffectData.Mask<R>();
                this.Translate_InternalFill(ret, eval);
                return ret;
            }

            protected void Translate_InternalFill<R>(Mask<R> obj, Func<TItem, R> eval)
            {
                obj.Flags = eval(this.Flags);
                obj.BaseCost = eval(this.BaseCost);
                obj.MagicSkill = eval(this.MagicSkill);
                obj.ResistValue = eval(this.ResistValue);
                obj.CounterEffectCount = eval(this.CounterEffectCount);
                obj.Unknown1 = eval(this.Unknown1);
                obj.CastingLight = eval(this.CastingLight);
                obj.TaperWeight = eval(this.TaperWeight);
                obj.HitShader = eval(this.HitShader);
                obj.EnchantShader = eval(this.EnchantShader);
                obj.MinimumSkillLevel = eval(this.MinimumSkillLevel);
                obj.SpellmakingArea = eval(this.SpellmakingArea);
                obj.SpellmakingCastingTime = eval(this.SpellmakingCastingTime);
                obj.TaperCurve = eval(this.TaperCurve);
                obj.TaperDuration = eval(this.TaperDuration);
                obj.SecondActorValueWeight = eval(this.SecondActorValueWeight);
                obj.Archetype = this.Archetype == null ? null : new MaskItem<R, MagicEffectArchetype.Mask<R>?>(eval(this.Archetype.Overall), this.Archetype.Specific?.Translate(eval));
                obj.Projectile = eval(this.Projectile);
                obj.Explosion = eval(this.Explosion);
                obj.CastType = eval(this.CastType);
                obj.TargetType = eval(this.TargetType);
                obj.SecondActorValue = eval(this.SecondActorValue);
                obj.CastingArt = eval(this.CastingArt);
                obj.HitEffectArt = eval(this.HitEffectArt);
                obj.ImpactData = eval(this.ImpactData);
                obj.SkillUsageMultiplier = eval(this.SkillUsageMultiplier);
                obj.DualCastArt = eval(this.DualCastArt);
                obj.DualCastScale = eval(this.DualCastScale);
                obj.EnchantArt = eval(this.EnchantArt);
                obj.Unknown2 = eval(this.Unknown2);
                obj.Unknown3 = eval(this.Unknown3);
                obj.EquipAbility = eval(this.EquipAbility);
                obj.ImageSpaceModifier = eval(this.ImageSpaceModifier);
                obj.PerkToApply = eval(this.PerkToApply);
                obj.CastingSoundLevel = eval(this.CastingSoundLevel);
                obj.ScriptEffectAIScore = eval(this.ScriptEffectAIScore);
                obj.ScriptEffectAIDelayTime = eval(this.ScriptEffectAIDelayTime);
            }
            #endregion

            #region To String
            public override string ToString()
            {
                return ToString(printMask: null);
            }

            public string ToString(MagicEffectData.Mask<bool>? printMask = null)
            {
                var fg = new FileGeneration();
                ToString(fg, printMask);
                return fg.ToString();
            }

            public void ToString(FileGeneration fg, MagicEffectData.Mask<bool>? printMask = null)
            {
                fg.AppendLine($"{nameof(MagicEffectData.Mask<TItem>)} =>");
                fg.AppendLine("[");
                using (new DepthWrapper(fg))
                {
                    if (printMask?.Flags ?? true)
                    {
                        fg.AppendItem(Flags, "Flags");
                    }
                    if (printMask?.BaseCost ?? true)
                    {
                        fg.AppendItem(BaseCost, "BaseCost");
                    }
                    if (printMask?.MagicSkill ?? true)
                    {
                        fg.AppendItem(MagicSkill, "MagicSkill");
                    }
                    if (printMask?.ResistValue ?? true)
                    {
                        fg.AppendItem(ResistValue, "ResistValue");
                    }
                    if (printMask?.CounterEffectCount ?? true)
                    {
                        fg.AppendItem(CounterEffectCount, "CounterEffectCount");
                    }
                    if (printMask?.Unknown1 ?? true)
                    {
                        fg.AppendItem(Unknown1, "Unknown1");
                    }
                    if (printMask?.CastingLight ?? true)
                    {
                        fg.AppendItem(CastingLight, "CastingLight");
                    }
                    if (printMask?.TaperWeight ?? true)
                    {
                        fg.AppendItem(TaperWeight, "TaperWeight");
                    }
                    if (printMask?.HitShader ?? true)
                    {
                        fg.AppendItem(HitShader, "HitShader");
                    }
                    if (printMask?.EnchantShader ?? true)
                    {
                        fg.AppendItem(EnchantShader, "EnchantShader");
                    }
                    if (printMask?.MinimumSkillLevel ?? true)
                    {
                        fg.AppendItem(MinimumSkillLevel, "MinimumSkillLevel");
                    }
                    if (printMask?.SpellmakingArea ?? true)
                    {
                        fg.AppendItem(SpellmakingArea, "SpellmakingArea");
                    }
                    if (printMask?.SpellmakingCastingTime ?? true)
                    {
                        fg.AppendItem(SpellmakingCastingTime, "SpellmakingCastingTime");
                    }
                    if (printMask?.TaperCurve ?? true)
                    {
                        fg.AppendItem(TaperCurve, "TaperCurve");
                    }
                    if (printMask?.TaperDuration ?? true)
                    {
                        fg.AppendItem(TaperDuration, "TaperDuration");
                    }
                    if (printMask?.SecondActorValueWeight ?? true)
                    {
                        fg.AppendItem(SecondActorValueWeight, "SecondActorValueWeight");
                    }
                    if (printMask?.Archetype?.Overall ?? true)
                    {
                        Archetype?.ToString(fg);
                    }
                    if (printMask?.Projectile ?? true)
                    {
                        fg.AppendItem(Projectile, "Projectile");
                    }
                    if (printMask?.Explosion ?? true)
                    {
                        fg.AppendItem(Explosion, "Explosion");
                    }
                    if (printMask?.CastType ?? true)
                    {
                        fg.AppendItem(CastType, "CastType");
                    }
                    if (printMask?.TargetType ?? true)
                    {
                        fg.AppendItem(TargetType, "TargetType");
                    }
                    if (printMask?.SecondActorValue ?? true)
                    {
                        fg.AppendItem(SecondActorValue, "SecondActorValue");
                    }
                    if (printMask?.CastingArt ?? true)
                    {
                        fg.AppendItem(CastingArt, "CastingArt");
                    }
                    if (printMask?.HitEffectArt ?? true)
                    {
                        fg.AppendItem(HitEffectArt, "HitEffectArt");
                    }
                    if (printMask?.ImpactData ?? true)
                    {
                        fg.AppendItem(ImpactData, "ImpactData");
                    }
                    if (printMask?.SkillUsageMultiplier ?? true)
                    {
                        fg.AppendItem(SkillUsageMultiplier, "SkillUsageMultiplier");
                    }
                    if (printMask?.DualCastArt ?? true)
                    {
                        fg.AppendItem(DualCastArt, "DualCastArt");
                    }
                    if (printMask?.DualCastScale ?? true)
                    {
                        fg.AppendItem(DualCastScale, "DualCastScale");
                    }
                    if (printMask?.EnchantArt ?? true)
                    {
                        fg.AppendItem(EnchantArt, "EnchantArt");
                    }
                    if (printMask?.Unknown2 ?? true)
                    {
                        fg.AppendItem(Unknown2, "Unknown2");
                    }
                    if (printMask?.Unknown3 ?? true)
                    {
                        fg.AppendItem(Unknown3, "Unknown3");
                    }
                    if (printMask?.EquipAbility ?? true)
                    {
                        fg.AppendItem(EquipAbility, "EquipAbility");
                    }
                    if (printMask?.ImageSpaceModifier ?? true)
                    {
                        fg.AppendItem(ImageSpaceModifier, "ImageSpaceModifier");
                    }
                    if (printMask?.PerkToApply ?? true)
                    {
                        fg.AppendItem(PerkToApply, "PerkToApply");
                    }
                    if (printMask?.CastingSoundLevel ?? true)
                    {
                        fg.AppendItem(CastingSoundLevel, "CastingSoundLevel");
                    }
                    if (printMask?.ScriptEffectAIScore ?? true)
                    {
                        fg.AppendItem(ScriptEffectAIScore, "ScriptEffectAIScore");
                    }
                    if (printMask?.ScriptEffectAIDelayTime ?? true)
                    {
                        fg.AppendItem(ScriptEffectAIDelayTime, "ScriptEffectAIDelayTime");
                    }
                }
                fg.AppendLine("]");
            }
            #endregion

        }

        public class ErrorMask :
            IErrorMask,
            IErrorMask<ErrorMask>
        {
            #region Members
            public Exception? Overall { get; set; }
            private List<string>? _warnings;
            public List<string> Warnings
            {
                get
                {
                    if (_warnings == null)
                    {
                        _warnings = new List<string>();
                    }
                    return _warnings;
                }
            }
            public Exception? Flags;
            public Exception? BaseCost;
            public Exception? MagicSkill;
            public Exception? ResistValue;
            public Exception? CounterEffectCount;
            public Exception? Unknown1;
            public Exception? CastingLight;
            public Exception? TaperWeight;
            public Exception? HitShader;
            public Exception? EnchantShader;
            public Exception? MinimumSkillLevel;
            public Exception? SpellmakingArea;
            public Exception? SpellmakingCastingTime;
            public Exception? TaperCurve;
            public Exception? TaperDuration;
            public Exception? SecondActorValueWeight;
            public MaskItem<Exception?, MagicEffectArchetype.ErrorMask?>? Archetype;
            public Exception? Projectile;
            public Exception? Explosion;
            public Exception? CastType;
            public Exception? TargetType;
            public Exception? SecondActorValue;
            public Exception? CastingArt;
            public Exception? HitEffectArt;
            public Exception? ImpactData;
            public Exception? SkillUsageMultiplier;
            public Exception? DualCastArt;
            public Exception? DualCastScale;
            public Exception? EnchantArt;
            public Exception? Unknown2;
            public Exception? Unknown3;
            public Exception? EquipAbility;
            public Exception? ImageSpaceModifier;
            public Exception? PerkToApply;
            public Exception? CastingSoundLevel;
            public Exception? ScriptEffectAIScore;
            public Exception? ScriptEffectAIDelayTime;
            #endregion

            #region IErrorMask
            public object? GetNthMask(int index)
            {
                MagicEffectData_FieldIndex enu = (MagicEffectData_FieldIndex)index;
                switch (enu)
                {
                    case MagicEffectData_FieldIndex.Flags:
                        return Flags;
                    case MagicEffectData_FieldIndex.BaseCost:
                        return BaseCost;
                    case MagicEffectData_FieldIndex.MagicSkill:
                        return MagicSkill;
                    case MagicEffectData_FieldIndex.ResistValue:
                        return ResistValue;
                    case MagicEffectData_FieldIndex.CounterEffectCount:
                        return CounterEffectCount;
                    case MagicEffectData_FieldIndex.Unknown1:
                        return Unknown1;
                    case MagicEffectData_FieldIndex.CastingLight:
                        return CastingLight;
                    case MagicEffectData_FieldIndex.TaperWeight:
                        return TaperWeight;
                    case MagicEffectData_FieldIndex.HitShader:
                        return HitShader;
                    case MagicEffectData_FieldIndex.EnchantShader:
                        return EnchantShader;
                    case MagicEffectData_FieldIndex.MinimumSkillLevel:
                        return MinimumSkillLevel;
                    case MagicEffectData_FieldIndex.SpellmakingArea:
                        return SpellmakingArea;
                    case MagicEffectData_FieldIndex.SpellmakingCastingTime:
                        return SpellmakingCastingTime;
                    case MagicEffectData_FieldIndex.TaperCurve:
                        return TaperCurve;
                    case MagicEffectData_FieldIndex.TaperDuration:
                        return TaperDuration;
                    case MagicEffectData_FieldIndex.SecondActorValueWeight:
                        return SecondActorValueWeight;
                    case MagicEffectData_FieldIndex.Archetype:
                        return Archetype;
                    case MagicEffectData_FieldIndex.Projectile:
                        return Projectile;
                    case MagicEffectData_FieldIndex.Explosion:
                        return Explosion;
                    case MagicEffectData_FieldIndex.CastType:
                        return CastType;
                    case MagicEffectData_FieldIndex.TargetType:
                        return TargetType;
                    case MagicEffectData_FieldIndex.SecondActorValue:
                        return SecondActorValue;
                    case MagicEffectData_FieldIndex.CastingArt:
                        return CastingArt;
                    case MagicEffectData_FieldIndex.HitEffectArt:
                        return HitEffectArt;
                    case MagicEffectData_FieldIndex.ImpactData:
                        return ImpactData;
                    case MagicEffectData_FieldIndex.SkillUsageMultiplier:
                        return SkillUsageMultiplier;
                    case MagicEffectData_FieldIndex.DualCastArt:
                        return DualCastArt;
                    case MagicEffectData_FieldIndex.DualCastScale:
                        return DualCastScale;
                    case MagicEffectData_FieldIndex.EnchantArt:
                        return EnchantArt;
                    case MagicEffectData_FieldIndex.Unknown2:
                        return Unknown2;
                    case MagicEffectData_FieldIndex.Unknown3:
                        return Unknown3;
                    case MagicEffectData_FieldIndex.EquipAbility:
                        return EquipAbility;
                    case MagicEffectData_FieldIndex.ImageSpaceModifier:
                        return ImageSpaceModifier;
                    case MagicEffectData_FieldIndex.PerkToApply:
                        return PerkToApply;
                    case MagicEffectData_FieldIndex.CastingSoundLevel:
                        return CastingSoundLevel;
                    case MagicEffectData_FieldIndex.ScriptEffectAIScore:
                        return ScriptEffectAIScore;
                    case MagicEffectData_FieldIndex.ScriptEffectAIDelayTime:
                        return ScriptEffectAIDelayTime;
                    default:
                        throw new ArgumentException($"Index is out of range: {index}");
                }
            }

            public void SetNthException(int index, Exception ex)
            {
                MagicEffectData_FieldIndex enu = (MagicEffectData_FieldIndex)index;
                switch (enu)
                {
                    case MagicEffectData_FieldIndex.Flags:
                        this.Flags = ex;
                        break;
                    case MagicEffectData_FieldIndex.BaseCost:
                        this.BaseCost = ex;
                        break;
                    case MagicEffectData_FieldIndex.MagicSkill:
                        this.MagicSkill = ex;
                        break;
                    case MagicEffectData_FieldIndex.ResistValue:
                        this.ResistValue = ex;
                        break;
                    case MagicEffectData_FieldIndex.CounterEffectCount:
                        this.CounterEffectCount = ex;
                        break;
                    case MagicEffectData_FieldIndex.Unknown1:
                        this.Unknown1 = ex;
                        break;
                    case MagicEffectData_FieldIndex.CastingLight:
                        this.CastingLight = ex;
                        break;
                    case MagicEffectData_FieldIndex.TaperWeight:
                        this.TaperWeight = ex;
                        break;
                    case MagicEffectData_FieldIndex.HitShader:
                        this.HitShader = ex;
                        break;
                    case MagicEffectData_FieldIndex.EnchantShader:
                        this.EnchantShader = ex;
                        break;
                    case MagicEffectData_FieldIndex.MinimumSkillLevel:
                        this.MinimumSkillLevel = ex;
                        break;
                    case MagicEffectData_FieldIndex.SpellmakingArea:
                        this.SpellmakingArea = ex;
                        break;
                    case MagicEffectData_FieldIndex.SpellmakingCastingTime:
                        this.SpellmakingCastingTime = ex;
                        break;
                    case MagicEffectData_FieldIndex.TaperCurve:
                        this.TaperCurve = ex;
                        break;
                    case MagicEffectData_FieldIndex.TaperDuration:
                        this.TaperDuration = ex;
                        break;
                    case MagicEffectData_FieldIndex.SecondActorValueWeight:
                        this.SecondActorValueWeight = ex;
                        break;
                    case MagicEffectData_FieldIndex.Archetype:
                        this.Archetype = new MaskItem<Exception?, MagicEffectArchetype.ErrorMask?>(ex, null);
                        break;
                    case MagicEffectData_FieldIndex.Projectile:
                        this.Projectile = ex;
                        break;
                    case MagicEffectData_FieldIndex.Explosion:
                        this.Explosion = ex;
                        break;
                    case MagicEffectData_FieldIndex.CastType:
                        this.CastType = ex;
                        break;
                    case MagicEffectData_FieldIndex.TargetType:
                        this.TargetType = ex;
                        break;
                    case MagicEffectData_FieldIndex.SecondActorValue:
                        this.SecondActorValue = ex;
                        break;
                    case MagicEffectData_FieldIndex.CastingArt:
                        this.CastingArt = ex;
                        break;
                    case MagicEffectData_FieldIndex.HitEffectArt:
                        this.HitEffectArt = ex;
                        break;
                    case MagicEffectData_FieldIndex.ImpactData:
                        this.ImpactData = ex;
                        break;
                    case MagicEffectData_FieldIndex.SkillUsageMultiplier:
                        this.SkillUsageMultiplier = ex;
                        break;
                    case MagicEffectData_FieldIndex.DualCastArt:
                        this.DualCastArt = ex;
                        break;
                    case MagicEffectData_FieldIndex.DualCastScale:
                        this.DualCastScale = ex;
                        break;
                    case MagicEffectData_FieldIndex.EnchantArt:
                        this.EnchantArt = ex;
                        break;
                    case MagicEffectData_FieldIndex.Unknown2:
                        this.Unknown2 = ex;
                        break;
                    case MagicEffectData_FieldIndex.Unknown3:
                        this.Unknown3 = ex;
                        break;
                    case MagicEffectData_FieldIndex.EquipAbility:
                        this.EquipAbility = ex;
                        break;
                    case MagicEffectData_FieldIndex.ImageSpaceModifier:
                        this.ImageSpaceModifier = ex;
                        break;
                    case MagicEffectData_FieldIndex.PerkToApply:
                        this.PerkToApply = ex;
                        break;
                    case MagicEffectData_FieldIndex.CastingSoundLevel:
                        this.CastingSoundLevel = ex;
                        break;
                    case MagicEffectData_FieldIndex.ScriptEffectAIScore:
                        this.ScriptEffectAIScore = ex;
                        break;
                    case MagicEffectData_FieldIndex.ScriptEffectAIDelayTime:
                        this.ScriptEffectAIDelayTime = ex;
                        break;
                    default:
                        throw new ArgumentException($"Index is out of range: {index}");
                }
            }

            public void SetNthMask(int index, object obj)
            {
                MagicEffectData_FieldIndex enu = (MagicEffectData_FieldIndex)index;
                switch (enu)
                {
                    case MagicEffectData_FieldIndex.Flags:
                        this.Flags = (Exception?)obj;
                        break;
                    case MagicEffectData_FieldIndex.BaseCost:
                        this.BaseCost = (Exception?)obj;
                        break;
                    case MagicEffectData_FieldIndex.MagicSkill:
                        this.MagicSkill = (Exception?)obj;
                        break;
                    case MagicEffectData_FieldIndex.ResistValue:
                        this.ResistValue = (Exception?)obj;
                        break;
                    case MagicEffectData_FieldIndex.CounterEffectCount:
                        this.CounterEffectCount = (Exception?)obj;
                        break;
                    case MagicEffectData_FieldIndex.Unknown1:
                        this.Unknown1 = (Exception?)obj;
                        break;
                    case MagicEffectData_FieldIndex.CastingLight:
                        this.CastingLight = (Exception?)obj;
                        break;
                    case MagicEffectData_FieldIndex.TaperWeight:
                        this.TaperWeight = (Exception?)obj;
                        break;
                    case MagicEffectData_FieldIndex.HitShader:
                        this.HitShader = (Exception?)obj;
                        break;
                    case MagicEffectData_FieldIndex.EnchantShader:
                        this.EnchantShader = (Exception?)obj;
                        break;
                    case MagicEffectData_FieldIndex.MinimumSkillLevel:
                        this.MinimumSkillLevel = (Exception?)obj;
                        break;
                    case MagicEffectData_FieldIndex.SpellmakingArea:
                        this.SpellmakingArea = (Exception?)obj;
                        break;
                    case MagicEffectData_FieldIndex.SpellmakingCastingTime:
                        this.SpellmakingCastingTime = (Exception?)obj;
                        break;
                    case MagicEffectData_FieldIndex.TaperCurve:
                        this.TaperCurve = (Exception?)obj;
                        break;
                    case MagicEffectData_FieldIndex.TaperDuration:
                        this.TaperDuration = (Exception?)obj;
                        break;
                    case MagicEffectData_FieldIndex.SecondActorValueWeight:
                        this.SecondActorValueWeight = (Exception?)obj;
                        break;
                    case MagicEffectData_FieldIndex.Archetype:
                        this.Archetype = (MaskItem<Exception?, MagicEffectArchetype.ErrorMask?>?)obj;
                        break;
                    case MagicEffectData_FieldIndex.Projectile:
                        this.Projectile = (Exception?)obj;
                        break;
                    case MagicEffectData_FieldIndex.Explosion:
                        this.Explosion = (Exception?)obj;
                        break;
                    case MagicEffectData_FieldIndex.CastType:
                        this.CastType = (Exception?)obj;
                        break;
                    case MagicEffectData_FieldIndex.TargetType:
                        this.TargetType = (Exception?)obj;
                        break;
                    case MagicEffectData_FieldIndex.SecondActorValue:
                        this.SecondActorValue = (Exception?)obj;
                        break;
                    case MagicEffectData_FieldIndex.CastingArt:
                        this.CastingArt = (Exception?)obj;
                        break;
                    case MagicEffectData_FieldIndex.HitEffectArt:
                        this.HitEffectArt = (Exception?)obj;
                        break;
                    case MagicEffectData_FieldIndex.ImpactData:
                        this.ImpactData = (Exception?)obj;
                        break;
                    case MagicEffectData_FieldIndex.SkillUsageMultiplier:
                        this.SkillUsageMultiplier = (Exception?)obj;
                        break;
                    case MagicEffectData_FieldIndex.DualCastArt:
                        this.DualCastArt = (Exception?)obj;
                        break;
                    case MagicEffectData_FieldIndex.DualCastScale:
                        this.DualCastScale = (Exception?)obj;
                        break;
                    case MagicEffectData_FieldIndex.EnchantArt:
                        this.EnchantArt = (Exception?)obj;
                        break;
                    case MagicEffectData_FieldIndex.Unknown2:
                        this.Unknown2 = (Exception?)obj;
                        break;
                    case MagicEffectData_FieldIndex.Unknown3:
                        this.Unknown3 = (Exception?)obj;
                        break;
                    case MagicEffectData_FieldIndex.EquipAbility:
                        this.EquipAbility = (Exception?)obj;
                        break;
                    case MagicEffectData_FieldIndex.ImageSpaceModifier:
                        this.ImageSpaceModifier = (Exception?)obj;
                        break;
                    case MagicEffectData_FieldIndex.PerkToApply:
                        this.PerkToApply = (Exception?)obj;
                        break;
                    case MagicEffectData_FieldIndex.CastingSoundLevel:
                        this.CastingSoundLevel = (Exception?)obj;
                        break;
                    case MagicEffectData_FieldIndex.ScriptEffectAIScore:
                        this.ScriptEffectAIScore = (Exception?)obj;
                        break;
                    case MagicEffectData_FieldIndex.ScriptEffectAIDelayTime:
                        this.ScriptEffectAIDelayTime = (Exception?)obj;
                        break;
                    default:
                        throw new ArgumentException($"Index is out of range: {index}");
                }
            }

            public bool IsInError()
            {
                if (Overall != null) return true;
                if (Flags != null) return true;
                if (BaseCost != null) return true;
                if (MagicSkill != null) return true;
                if (ResistValue != null) return true;
                if (CounterEffectCount != null) return true;
                if (Unknown1 != null) return true;
                if (CastingLight != null) return true;
                if (TaperWeight != null) return true;
                if (HitShader != null) return true;
                if (EnchantShader != null) return true;
                if (MinimumSkillLevel != null) return true;
                if (SpellmakingArea != null) return true;
                if (SpellmakingCastingTime != null) return true;
                if (TaperCurve != null) return true;
                if (TaperDuration != null) return true;
                if (SecondActorValueWeight != null) return true;
                if (Archetype != null) return true;
                if (Projectile != null) return true;
                if (Explosion != null) return true;
                if (CastType != null) return true;
                if (TargetType != null) return true;
                if (SecondActorValue != null) return true;
                if (CastingArt != null) return true;
                if (HitEffectArt != null) return true;
                if (ImpactData != null) return true;
                if (SkillUsageMultiplier != null) return true;
                if (DualCastArt != null) return true;
                if (DualCastScale != null) return true;
                if (EnchantArt != null) return true;
                if (Unknown2 != null) return true;
                if (Unknown3 != null) return true;
                if (EquipAbility != null) return true;
                if (ImageSpaceModifier != null) return true;
                if (PerkToApply != null) return true;
                if (CastingSoundLevel != null) return true;
                if (ScriptEffectAIScore != null) return true;
                if (ScriptEffectAIDelayTime != null) return true;
                return false;
            }
            #endregion

            #region To String
            public override string ToString()
            {
                var fg = new FileGeneration();
                ToString(fg, null);
                return fg.ToString();
            }

            public void ToString(FileGeneration fg, string? name = null)
            {
                fg.AppendLine($"{(name ?? "ErrorMask")} =>");
                fg.AppendLine("[");
                using (new DepthWrapper(fg))
                {
                    if (this.Overall != null)
                    {
                        fg.AppendLine("Overall =>");
                        fg.AppendLine("[");
                        using (new DepthWrapper(fg))
                        {
                            fg.AppendLine($"{this.Overall}");
                        }
                        fg.AppendLine("]");
                    }
                    ToString_FillInternal(fg);
                }
                fg.AppendLine("]");
            }
            protected void ToString_FillInternal(FileGeneration fg)
            {
                fg.AppendItem(Flags, "Flags");
                fg.AppendItem(BaseCost, "BaseCost");
                fg.AppendItem(MagicSkill, "MagicSkill");
                fg.AppendItem(ResistValue, "ResistValue");
                fg.AppendItem(CounterEffectCount, "CounterEffectCount");
                fg.AppendItem(Unknown1, "Unknown1");
                fg.AppendItem(CastingLight, "CastingLight");
                fg.AppendItem(TaperWeight, "TaperWeight");
                fg.AppendItem(HitShader, "HitShader");
                fg.AppendItem(EnchantShader, "EnchantShader");
                fg.AppendItem(MinimumSkillLevel, "MinimumSkillLevel");
                fg.AppendItem(SpellmakingArea, "SpellmakingArea");
                fg.AppendItem(SpellmakingCastingTime, "SpellmakingCastingTime");
                fg.AppendItem(TaperCurve, "TaperCurve");
                fg.AppendItem(TaperDuration, "TaperDuration");
                fg.AppendItem(SecondActorValueWeight, "SecondActorValueWeight");
                Archetype?.ToString(fg);
                fg.AppendItem(Projectile, "Projectile");
                fg.AppendItem(Explosion, "Explosion");
                fg.AppendItem(CastType, "CastType");
                fg.AppendItem(TargetType, "TargetType");
                fg.AppendItem(SecondActorValue, "SecondActorValue");
                fg.AppendItem(CastingArt, "CastingArt");
                fg.AppendItem(HitEffectArt, "HitEffectArt");
                fg.AppendItem(ImpactData, "ImpactData");
                fg.AppendItem(SkillUsageMultiplier, "SkillUsageMultiplier");
                fg.AppendItem(DualCastArt, "DualCastArt");
                fg.AppendItem(DualCastScale, "DualCastScale");
                fg.AppendItem(EnchantArt, "EnchantArt");
                fg.AppendItem(Unknown2, "Unknown2");
                fg.AppendItem(Unknown3, "Unknown3");
                fg.AppendItem(EquipAbility, "EquipAbility");
                fg.AppendItem(ImageSpaceModifier, "ImageSpaceModifier");
                fg.AppendItem(PerkToApply, "PerkToApply");
                fg.AppendItem(CastingSoundLevel, "CastingSoundLevel");
                fg.AppendItem(ScriptEffectAIScore, "ScriptEffectAIScore");
                fg.AppendItem(ScriptEffectAIDelayTime, "ScriptEffectAIDelayTime");
            }
            #endregion

            #region Combine
            public ErrorMask Combine(ErrorMask? rhs)
            {
                if (rhs == null) return this;
                var ret = new ErrorMask();
                ret.Flags = this.Flags.Combine(rhs.Flags);
                ret.BaseCost = this.BaseCost.Combine(rhs.BaseCost);
                ret.MagicSkill = this.MagicSkill.Combine(rhs.MagicSkill);
                ret.ResistValue = this.ResistValue.Combine(rhs.ResistValue);
                ret.CounterEffectCount = this.CounterEffectCount.Combine(rhs.CounterEffectCount);
                ret.Unknown1 = this.Unknown1.Combine(rhs.Unknown1);
                ret.CastingLight = this.CastingLight.Combine(rhs.CastingLight);
                ret.TaperWeight = this.TaperWeight.Combine(rhs.TaperWeight);
                ret.HitShader = this.HitShader.Combine(rhs.HitShader);
                ret.EnchantShader = this.EnchantShader.Combine(rhs.EnchantShader);
                ret.MinimumSkillLevel = this.MinimumSkillLevel.Combine(rhs.MinimumSkillLevel);
                ret.SpellmakingArea = this.SpellmakingArea.Combine(rhs.SpellmakingArea);
                ret.SpellmakingCastingTime = this.SpellmakingCastingTime.Combine(rhs.SpellmakingCastingTime);
                ret.TaperCurve = this.TaperCurve.Combine(rhs.TaperCurve);
                ret.TaperDuration = this.TaperDuration.Combine(rhs.TaperDuration);
                ret.SecondActorValueWeight = this.SecondActorValueWeight.Combine(rhs.SecondActorValueWeight);
                ret.Archetype = this.Archetype.Combine(rhs.Archetype, (l, r) => l.Combine(r));
                ret.Projectile = this.Projectile.Combine(rhs.Projectile);
                ret.Explosion = this.Explosion.Combine(rhs.Explosion);
                ret.CastType = this.CastType.Combine(rhs.CastType);
                ret.TargetType = this.TargetType.Combine(rhs.TargetType);
                ret.SecondActorValue = this.SecondActorValue.Combine(rhs.SecondActorValue);
                ret.CastingArt = this.CastingArt.Combine(rhs.CastingArt);
                ret.HitEffectArt = this.HitEffectArt.Combine(rhs.HitEffectArt);
                ret.ImpactData = this.ImpactData.Combine(rhs.ImpactData);
                ret.SkillUsageMultiplier = this.SkillUsageMultiplier.Combine(rhs.SkillUsageMultiplier);
                ret.DualCastArt = this.DualCastArt.Combine(rhs.DualCastArt);
                ret.DualCastScale = this.DualCastScale.Combine(rhs.DualCastScale);
                ret.EnchantArt = this.EnchantArt.Combine(rhs.EnchantArt);
                ret.Unknown2 = this.Unknown2.Combine(rhs.Unknown2);
                ret.Unknown3 = this.Unknown3.Combine(rhs.Unknown3);
                ret.EquipAbility = this.EquipAbility.Combine(rhs.EquipAbility);
                ret.ImageSpaceModifier = this.ImageSpaceModifier.Combine(rhs.ImageSpaceModifier);
                ret.PerkToApply = this.PerkToApply.Combine(rhs.PerkToApply);
                ret.CastingSoundLevel = this.CastingSoundLevel.Combine(rhs.CastingSoundLevel);
                ret.ScriptEffectAIScore = this.ScriptEffectAIScore.Combine(rhs.ScriptEffectAIScore);
                ret.ScriptEffectAIDelayTime = this.ScriptEffectAIDelayTime.Combine(rhs.ScriptEffectAIDelayTime);
                return ret;
            }
            public static ErrorMask? Combine(ErrorMask? lhs, ErrorMask? rhs)
            {
                if (lhs != null && rhs != null) return lhs.Combine(rhs);
                return lhs ?? rhs;
            }
            #endregion

            #region Factory
            public static ErrorMask Factory(ErrorMaskBuilder errorMask)
            {
                return new ErrorMask();
            }
            #endregion

        }
        public class TranslationMask : ITranslationMask
        {
            #region Members
            private TranslationCrystal? _crystal;
            public bool Flags;
            public bool BaseCost;
            public bool MagicSkill;
            public bool ResistValue;
            public bool CounterEffectCount;
            public bool Unknown1;
            public bool CastingLight;
            public bool TaperWeight;
            public bool HitShader;
            public bool EnchantShader;
            public bool MinimumSkillLevel;
            public bool SpellmakingArea;
            public bool SpellmakingCastingTime;
            public bool TaperCurve;
            public bool TaperDuration;
            public bool SecondActorValueWeight;
            public MaskItem<bool, MagicEffectArchetype.TranslationMask?> Archetype;
            public bool Projectile;
            public bool Explosion;
            public bool CastType;
            public bool TargetType;
            public bool SecondActorValue;
            public bool CastingArt;
            public bool HitEffectArt;
            public bool ImpactData;
            public bool SkillUsageMultiplier;
            public bool DualCastArt;
            public bool DualCastScale;
            public bool EnchantArt;
            public bool Unknown2;
            public bool Unknown3;
            public bool EquipAbility;
            public bool ImageSpaceModifier;
            public bool PerkToApply;
            public bool CastingSoundLevel;
            public bool ScriptEffectAIScore;
            public bool ScriptEffectAIDelayTime;
            #endregion

            #region Ctors
            public TranslationMask(bool defaultOn)
            {
                this.Flags = defaultOn;
                this.BaseCost = defaultOn;
                this.MagicSkill = defaultOn;
                this.ResistValue = defaultOn;
                this.CounterEffectCount = defaultOn;
                this.Unknown1 = defaultOn;
                this.CastingLight = defaultOn;
                this.TaperWeight = defaultOn;
                this.HitShader = defaultOn;
                this.EnchantShader = defaultOn;
                this.MinimumSkillLevel = defaultOn;
                this.SpellmakingArea = defaultOn;
                this.SpellmakingCastingTime = defaultOn;
                this.TaperCurve = defaultOn;
                this.TaperDuration = defaultOn;
                this.SecondActorValueWeight = defaultOn;
                this.Archetype = new MaskItem<bool, MagicEffectArchetype.TranslationMask?>(defaultOn, null);
                this.Projectile = defaultOn;
                this.Explosion = defaultOn;
                this.CastType = defaultOn;
                this.TargetType = defaultOn;
                this.SecondActorValue = defaultOn;
                this.CastingArt = defaultOn;
                this.HitEffectArt = defaultOn;
                this.ImpactData = defaultOn;
                this.SkillUsageMultiplier = defaultOn;
                this.DualCastArt = defaultOn;
                this.DualCastScale = defaultOn;
                this.EnchantArt = defaultOn;
                this.Unknown2 = defaultOn;
                this.Unknown3 = defaultOn;
                this.EquipAbility = defaultOn;
                this.ImageSpaceModifier = defaultOn;
                this.PerkToApply = defaultOn;
                this.CastingSoundLevel = defaultOn;
                this.ScriptEffectAIScore = defaultOn;
                this.ScriptEffectAIDelayTime = defaultOn;
            }

            #endregion

            public TranslationCrystal GetCrystal()
            {
                if (_crystal != null) return _crystal;
                var ret = new List<(bool On, TranslationCrystal? SubCrystal)>();
                GetCrystal(ret);
                _crystal = new TranslationCrystal(ret.ToArray());
                return _crystal;
            }

            protected void GetCrystal(List<(bool On, TranslationCrystal? SubCrystal)> ret)
            {
                ret.Add((Flags, null));
                ret.Add((BaseCost, null));
                ret.Add((MagicSkill, null));
                ret.Add((ResistValue, null));
                ret.Add((CounterEffectCount, null));
                ret.Add((Unknown1, null));
                ret.Add((CastingLight, null));
                ret.Add((TaperWeight, null));
                ret.Add((HitShader, null));
                ret.Add((EnchantShader, null));
                ret.Add((MinimumSkillLevel, null));
                ret.Add((SpellmakingArea, null));
                ret.Add((SpellmakingCastingTime, null));
                ret.Add((TaperCurve, null));
                ret.Add((TaperDuration, null));
                ret.Add((SecondActorValueWeight, null));
                ret.Add((Archetype?.Overall ?? true, Archetype?.Specific?.GetCrystal()));
                ret.Add((Projectile, null));
                ret.Add((Explosion, null));
                ret.Add((CastType, null));
                ret.Add((TargetType, null));
                ret.Add((SecondActorValue, null));
                ret.Add((CastingArt, null));
                ret.Add((HitEffectArt, null));
                ret.Add((ImpactData, null));
                ret.Add((SkillUsageMultiplier, null));
                ret.Add((DualCastArt, null));
                ret.Add((DualCastScale, null));
                ret.Add((EnchantArt, null));
                ret.Add((Unknown2, null));
                ret.Add((Unknown3, null));
                ret.Add((EquipAbility, null));
                ret.Add((ImageSpaceModifier, null));
                ret.Add((PerkToApply, null));
                ret.Add((CastingSoundLevel, null));
                ret.Add((ScriptEffectAIScore, null));
                ret.Add((ScriptEffectAIDelayTime, null));
            }
        }
        #endregion

        #region Mutagen
        public new static readonly RecordType GrupRecordType = MagicEffectData_Registration.TriggeringRecordType;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        public IEnumerable<ILinkGetter> Links => MagicEffectDataCommon.Instance.GetLinks(this);
        #endregion

        #region Binary Translation
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected object BinaryWriteTranslator => MagicEffectDataBinaryWriteTranslation.Instance;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        object IBinaryItem.BinaryWriteTranslator => this.BinaryWriteTranslator;
        void IBinaryItem.WriteToBinary(
            MutagenWriter writer,
            RecordTypeConverter? recordTypeConverter = null)
        {
            ((MagicEffectDataBinaryWriteTranslation)this.BinaryWriteTranslator).Write(
                item: this,
                writer: writer,
                recordTypeConverter: recordTypeConverter);
        }
        #region Binary Create
        [DebuggerStepThrough]
        public static MagicEffectData CreateFromBinary(MutagenFrame frame)
        {
            return CreateFromBinary(
                frame: frame,
                recordTypeConverter: null);
        }

        public static MagicEffectData CreateFromBinary(
            MutagenFrame frame,
            RecordTypeConverter? recordTypeConverter = null)
        {
            var ret = new MagicEffectData();
            ((MagicEffectDataSetterCommon)((IMagicEffectDataGetter)ret).CommonSetterInstance()!).CopyInFromBinary(
                item: ret,
                frame: frame,
                recordTypeConverter: recordTypeConverter);
            return ret;
        }

        #endregion

        #endregion

        void IPrintable.ToString(FileGeneration fg, string? name) => this.ToString(fg, name);
        IMask<bool> ILoquiObjectGetter.GetHasBeenSetIMask() => this.GetHasBeenSetMask();
        IMask<bool> IEqualsMask.GetEqualsIMask(object rhs, EqualsMaskHelper.Include include) => this.GetEqualsMask((IMagicEffectDataGetter)rhs, include);

        void IClearable.Clear()
        {
            ((MagicEffectDataSetterCommon)((IMagicEffectDataGetter)this).CommonSetterInstance()!).Clear(this);
        }

        internal static MagicEffectData GetNew()
        {
            return new MagicEffectData();
        }

    }
    #endregion

    #region Interface
    public partial interface IMagicEffectData :
        IMagicEffectDataGetter,
        ILoquiObjectSetter<IMagicEffectData>
    {
        new MagicEffect.Flag Flags { get; set; }
        new Single BaseCost { get; set; }
        new ActorValueExtended MagicSkill { get; set; }
        new ActorValueExtended ResistValue { get; set; }
        new UInt16 CounterEffectCount { get; set; }
        new UInt16 Unknown1 { get; set; }
        new IFormLink<Light> CastingLight { get; }
        new Single TaperWeight { get; set; }
        new IFormLink<EffectShader> HitShader { get; }
        new IFormLink<EffectShader> EnchantShader { get; }
        new UInt32 MinimumSkillLevel { get; set; }
        new UInt32 SpellmakingArea { get; set; }
        new Single SpellmakingCastingTime { get; set; }
        new Single TaperCurve { get; set; }
        new Single TaperDuration { get; set; }
        new Single SecondActorValueWeight { get; set; }
        new MagicEffectArchetype Archetype { get; set; }
        new IFormLink<Projectile> Projectile { get; }
        new IFormLink<Explosion> Explosion { get; }
        new CastType CastType { get; set; }
        new TargetType TargetType { get; set; }
        new ActorValueExtended SecondActorValue { get; set; }
        new IFormLink<ArtObject> CastingArt { get; }
        new IFormLink<ArtObject> HitEffectArt { get; }
        new IFormLink<ImpactDataSet> ImpactData { get; }
        new Single SkillUsageMultiplier { get; set; }
        new IFormLink<DualCastData> DualCastArt { get; }
        new Single DualCastScale { get; set; }
        new IFormLink<ArtObject> EnchantArt { get; }
        new IFormLink<SkyrimMajorRecord> Unknown2 { get; }
        new IFormLink<SkyrimMajorRecord> Unknown3 { get; }
        new IFormLink<Spell> EquipAbility { get; }
        new IFormLink<ImageSpaceAdapter> ImageSpaceModifier { get; }
        new IFormLink<Perk> PerkToApply { get; }
        new SoundLevel CastingSoundLevel { get; set; }
        new Single ScriptEffectAIScore { get; set; }
        new Single ScriptEffectAIDelayTime { get; set; }
    }

    public partial interface IMagicEffectDataGetter :
        ILoquiObject,
        ILoquiObject<IMagicEffectDataGetter>,
        IXmlItem,
        ILinkContainer,
        IBinaryItem
    {
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        object CommonInstance();
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        object? CommonSetterInstance();
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        object CommonSetterTranslationInstance();
        MagicEffect.Flag Flags { get; }
        Single BaseCost { get; }
        ActorValueExtended MagicSkill { get; }
        ActorValueExtended ResistValue { get; }
        UInt16 CounterEffectCount { get; }
        UInt16 Unknown1 { get; }
        IFormLinkGetter<ILightGetter> CastingLight { get; }
        Single TaperWeight { get; }
        IFormLinkGetter<IEffectShaderGetter> HitShader { get; }
        IFormLinkGetter<IEffectShaderGetter> EnchantShader { get; }
        UInt32 MinimumSkillLevel { get; }
        UInt32 SpellmakingArea { get; }
        Single SpellmakingCastingTime { get; }
        Single TaperCurve { get; }
        Single TaperDuration { get; }
        Single SecondActorValueWeight { get; }
        IMagicEffectArchetypeGetter Archetype { get; }
        IFormLinkGetter<IProjectileGetter> Projectile { get; }
        IFormLinkGetter<IExplosionGetter> Explosion { get; }
        CastType CastType { get; }
        TargetType TargetType { get; }
        ActorValueExtended SecondActorValue { get; }
        IFormLinkGetter<IArtObjectGetter> CastingArt { get; }
        IFormLinkGetter<IArtObjectGetter> HitEffectArt { get; }
        IFormLinkGetter<IImpactDataSetGetter> ImpactData { get; }
        Single SkillUsageMultiplier { get; }
        IFormLinkGetter<IDualCastDataGetter> DualCastArt { get; }
        Single DualCastScale { get; }
        IFormLinkGetter<IArtObjectGetter> EnchantArt { get; }
        IFormLinkGetter<ISkyrimMajorRecordGetter> Unknown2 { get; }
        IFormLinkGetter<ISkyrimMajorRecordGetter> Unknown3 { get; }
        IFormLinkGetter<ISpellGetter> EquipAbility { get; }
        IFormLinkGetter<IImageSpaceAdapterGetter> ImageSpaceModifier { get; }
        IFormLinkGetter<IPerkGetter> PerkToApply { get; }
        SoundLevel CastingSoundLevel { get; }
        Single ScriptEffectAIScore { get; }
        Single ScriptEffectAIDelayTime { get; }

    }

    #endregion

    #region Common MixIn
    public static partial class MagicEffectDataMixIn
    {
        public static void Clear(this IMagicEffectData item)
        {
            ((MagicEffectDataSetterCommon)((IMagicEffectDataGetter)item).CommonSetterInstance()!).Clear(item: item);
        }

        public static MagicEffectData.Mask<bool> GetEqualsMask(
            this IMagicEffectDataGetter item,
            IMagicEffectDataGetter rhs,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            return ((MagicEffectDataCommon)((IMagicEffectDataGetter)item).CommonInstance()!).GetEqualsMask(
                item: item,
                rhs: rhs,
                include: include);
        }

        public static string ToString(
            this IMagicEffectDataGetter item,
            string? name = null,
            MagicEffectData.Mask<bool>? printMask = null)
        {
            return ((MagicEffectDataCommon)((IMagicEffectDataGetter)item).CommonInstance()!).ToString(
                item: item,
                name: name,
                printMask: printMask);
        }

        public static void ToString(
            this IMagicEffectDataGetter item,
            FileGeneration fg,
            string? name = null,
            MagicEffectData.Mask<bool>? printMask = null)
        {
            ((MagicEffectDataCommon)((IMagicEffectDataGetter)item).CommonInstance()!).ToString(
                item: item,
                fg: fg,
                name: name,
                printMask: printMask);
        }

        public static bool HasBeenSet(
            this IMagicEffectDataGetter item,
            MagicEffectData.Mask<bool?> checkMask)
        {
            return ((MagicEffectDataCommon)((IMagicEffectDataGetter)item).CommonInstance()!).HasBeenSet(
                item: item,
                checkMask: checkMask);
        }

        public static MagicEffectData.Mask<bool> GetHasBeenSetMask(this IMagicEffectDataGetter item)
        {
            var ret = new MagicEffectData.Mask<bool>(false);
            ((MagicEffectDataCommon)((IMagicEffectDataGetter)item).CommonInstance()!).FillHasBeenSetMask(
                item: item,
                mask: ret);
            return ret;
        }

        public static bool Equals(
            this IMagicEffectDataGetter item,
            IMagicEffectDataGetter rhs)
        {
            return ((MagicEffectDataCommon)((IMagicEffectDataGetter)item).CommonInstance()!).Equals(
                lhs: item,
                rhs: rhs);
        }

        public static void DeepCopyIn(
            this IMagicEffectData lhs,
            IMagicEffectDataGetter rhs,
            MagicEffectData.TranslationMask? copyMask = null)
        {
            ((MagicEffectDataSetterTranslationCommon)((IMagicEffectDataGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: default,
                copyMask: default);
        }

        public static void DeepCopyIn(
            this IMagicEffectData lhs,
            IMagicEffectDataGetter rhs,
            out MagicEffectData.ErrorMask errorMask,
            MagicEffectData.TranslationMask? copyMask = null)
        {
            var errorMaskBuilder = new ErrorMaskBuilder();
            ((MagicEffectDataSetterTranslationCommon)((IMagicEffectDataGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: errorMaskBuilder,
                copyMask: copyMask?.GetCrystal());
            errorMask = MagicEffectData.ErrorMask.Factory(errorMaskBuilder);
        }

        public static void DeepCopyIn(
            this IMagicEffectData lhs,
            IMagicEffectDataGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask)
        {
            ((MagicEffectDataSetterTranslationCommon)((IMagicEffectDataGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: errorMask,
                copyMask: copyMask);
        }

        public static MagicEffectData DeepCopy(
            this IMagicEffectDataGetter item,
            MagicEffectData.TranslationMask? copyMask = null)
        {
            return ((MagicEffectDataSetterTranslationCommon)((IMagicEffectDataGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask);
        }

        public static MagicEffectData DeepCopy(
            this IMagicEffectDataGetter item,
            out MagicEffectData.ErrorMask errorMask,
            MagicEffectData.TranslationMask? copyMask = null)
        {
            return ((MagicEffectDataSetterTranslationCommon)((IMagicEffectDataGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask,
                errorMask: out errorMask);
        }

        public static MagicEffectData DeepCopy(
            this IMagicEffectDataGetter item,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask = null)
        {
            return ((MagicEffectDataSetterTranslationCommon)((IMagicEffectDataGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask,
                errorMask: errorMask);
        }

        #region Xml Translation
        [DebuggerStepThrough]
        public static void CopyInFromXml(
            this IMagicEffectData item,
            XElement node,
            MagicEffectData.TranslationMask? translationMask = null)
        {
            CopyInFromXml(
                item: item,
                node: node,
                errorMask: null,
                translationMask: translationMask?.GetCrystal());
        }

        [DebuggerStepThrough]
        public static void CopyInFromXml(
            this IMagicEffectData item,
            XElement node,
            out MagicEffectData.ErrorMask errorMask,
            MagicEffectData.TranslationMask? translationMask = null)
        {
            ErrorMaskBuilder errorMaskBuilder = new ErrorMaskBuilder();
            CopyInFromXml(
                item: item,
                node: node,
                errorMask: errorMaskBuilder,
                translationMask: translationMask?.GetCrystal());
            errorMask = MagicEffectData.ErrorMask.Factory(errorMaskBuilder);
        }

        public static void CopyInFromXml(
            this IMagicEffectData item,
            XElement node,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask)
        {
            ((MagicEffectDataSetterCommon)((IMagicEffectDataGetter)item).CommonSetterInstance()!).CopyInFromXml(
                item: item,
                node: node,
                errorMask: errorMask,
                translationMask: translationMask);
        }

        public static void CopyInFromXml(
            this IMagicEffectData item,
            string path,
            MagicEffectData.TranslationMask? translationMask = null)
        {
            var node = XDocument.Load(path).Root;
            CopyInFromXml(
                item: item,
                node: node,
                translationMask: translationMask);
        }

        public static void CopyInFromXml(
            this IMagicEffectData item,
            string path,
            out MagicEffectData.ErrorMask errorMask,
            MagicEffectData.TranslationMask? translationMask = null)
        {
            var node = XDocument.Load(path).Root;
            CopyInFromXml(
                item: item,
                node: node,
                errorMask: out errorMask,
                translationMask: translationMask);
        }

        public static void CopyInFromXml(
            this IMagicEffectData item,
            string path,
            ErrorMaskBuilder? errorMask,
            MagicEffectData.TranslationMask? translationMask = null)
        {
            var node = XDocument.Load(path).Root;
            CopyInFromXml(
                item: item,
                node: node,
                errorMask: errorMask,
                translationMask: translationMask?.GetCrystal());
        }

        public static void CopyInFromXml(
            this IMagicEffectData item,
            Stream stream,
            MagicEffectData.TranslationMask? translationMask = null)
        {
            var node = XDocument.Load(stream).Root;
            CopyInFromXml(
                item: item,
                node: node,
                translationMask: translationMask);
        }

        public static void CopyInFromXml(
            this IMagicEffectData item,
            Stream stream,
            out MagicEffectData.ErrorMask errorMask,
            MagicEffectData.TranslationMask? translationMask = null)
        {
            var node = XDocument.Load(stream).Root;
            CopyInFromXml(
                item: item,
                node: node,
                errorMask: out errorMask,
                translationMask: translationMask);
        }

        public static void CopyInFromXml(
            this IMagicEffectData item,
            Stream stream,
            ErrorMaskBuilder? errorMask,
            MagicEffectData.TranslationMask? translationMask = null)
        {
            var node = XDocument.Load(stream).Root;
            CopyInFromXml(
                item: item,
                node: node,
                errorMask: errorMask,
                translationMask: translationMask?.GetCrystal());
        }

        #endregion

        #region Binary Translation
        [DebuggerStepThrough]
        public static void CopyInFromBinary(
            this IMagicEffectData item,
            MutagenFrame frame)
        {
            CopyInFromBinary(
                item: item,
                frame: frame,
                recordTypeConverter: null);
        }

        public static void CopyInFromBinary(
            this IMagicEffectData item,
            MutagenFrame frame,
            RecordTypeConverter? recordTypeConverter = null)
        {
            ((MagicEffectDataSetterCommon)((IMagicEffectDataGetter)item).CommonSetterInstance()!).CopyInFromBinary(
                item: item,
                frame: frame,
                recordTypeConverter: recordTypeConverter);
        }

        #endregion

    }
    #endregion

}

namespace Mutagen.Bethesda.Skyrim.Internals
{
    #region Field Index
    public enum MagicEffectData_FieldIndex
    {
        Flags = 0,
        BaseCost = 1,
        MagicSkill = 2,
        ResistValue = 3,
        CounterEffectCount = 4,
        Unknown1 = 5,
        CastingLight = 6,
        TaperWeight = 7,
        HitShader = 8,
        EnchantShader = 9,
        MinimumSkillLevel = 10,
        SpellmakingArea = 11,
        SpellmakingCastingTime = 12,
        TaperCurve = 13,
        TaperDuration = 14,
        SecondActorValueWeight = 15,
        Archetype = 16,
        Projectile = 17,
        Explosion = 18,
        CastType = 19,
        TargetType = 20,
        SecondActorValue = 21,
        CastingArt = 22,
        HitEffectArt = 23,
        ImpactData = 24,
        SkillUsageMultiplier = 25,
        DualCastArt = 26,
        DualCastScale = 27,
        EnchantArt = 28,
        Unknown2 = 29,
        Unknown3 = 30,
        EquipAbility = 31,
        ImageSpaceModifier = 32,
        PerkToApply = 33,
        CastingSoundLevel = 34,
        ScriptEffectAIScore = 35,
        ScriptEffectAIDelayTime = 36,
    }
    #endregion

    #region Registration
    public partial class MagicEffectData_Registration : ILoquiRegistration
    {
        public static readonly MagicEffectData_Registration Instance = new MagicEffectData_Registration();

        public static ProtocolKey ProtocolKey => ProtocolDefinition_Skyrim.ProtocolKey;

        public static readonly ObjectKey ObjectKey = new ObjectKey(
            protocolKey: ProtocolDefinition_Skyrim.ProtocolKey,
            msgID: 104,
            version: 0);

        public const string GUID = "004a4e09-a57e-46fe-aa90-43fe97d703ae";

        public const ushort AdditionalFieldCount = 37;

        public const ushort FieldCount = 37;

        public static readonly Type MaskType = typeof(MagicEffectData.Mask<>);

        public static readonly Type ErrorMaskType = typeof(MagicEffectData.ErrorMask);

        public static readonly Type ClassType = typeof(MagicEffectData);

        public static readonly Type GetterType = typeof(IMagicEffectDataGetter);

        public static readonly Type? InternalGetterType = null;

        public static readonly Type SetterType = typeof(IMagicEffectData);

        public static readonly Type? InternalSetterType = null;

        public const string FullName = "Mutagen.Bethesda.Skyrim.MagicEffectData";

        public const string Name = "MagicEffectData";

        public const string Namespace = "Mutagen.Bethesda.Skyrim";

        public const byte GenericCount = 0;

        public static readonly Type? GenericRegistrationType = null;

        public static ushort? GetNameIndex(StringCaseAgnostic str)
        {
            switch (str.Upper)
            {
                case "FLAGS":
                    return (ushort)MagicEffectData_FieldIndex.Flags;
                case "BASECOST":
                    return (ushort)MagicEffectData_FieldIndex.BaseCost;
                case "MAGICSKILL":
                    return (ushort)MagicEffectData_FieldIndex.MagicSkill;
                case "RESISTVALUE":
                    return (ushort)MagicEffectData_FieldIndex.ResistValue;
                case "COUNTEREFFECTCOUNT":
                    return (ushort)MagicEffectData_FieldIndex.CounterEffectCount;
                case "UNKNOWN1":
                    return (ushort)MagicEffectData_FieldIndex.Unknown1;
                case "CASTINGLIGHT":
                    return (ushort)MagicEffectData_FieldIndex.CastingLight;
                case "TAPERWEIGHT":
                    return (ushort)MagicEffectData_FieldIndex.TaperWeight;
                case "HITSHADER":
                    return (ushort)MagicEffectData_FieldIndex.HitShader;
                case "ENCHANTSHADER":
                    return (ushort)MagicEffectData_FieldIndex.EnchantShader;
                case "MINIMUMSKILLLEVEL":
                    return (ushort)MagicEffectData_FieldIndex.MinimumSkillLevel;
                case "SPELLMAKINGAREA":
                    return (ushort)MagicEffectData_FieldIndex.SpellmakingArea;
                case "SPELLMAKINGCASTINGTIME":
                    return (ushort)MagicEffectData_FieldIndex.SpellmakingCastingTime;
                case "TAPERCURVE":
                    return (ushort)MagicEffectData_FieldIndex.TaperCurve;
                case "TAPERDURATION":
                    return (ushort)MagicEffectData_FieldIndex.TaperDuration;
                case "SECONDACTORVALUEWEIGHT":
                    return (ushort)MagicEffectData_FieldIndex.SecondActorValueWeight;
                case "ARCHETYPE":
                    return (ushort)MagicEffectData_FieldIndex.Archetype;
                case "PROJECTILE":
                    return (ushort)MagicEffectData_FieldIndex.Projectile;
                case "EXPLOSION":
                    return (ushort)MagicEffectData_FieldIndex.Explosion;
                case "CASTTYPE":
                    return (ushort)MagicEffectData_FieldIndex.CastType;
                case "TARGETTYPE":
                    return (ushort)MagicEffectData_FieldIndex.TargetType;
                case "SECONDACTORVALUE":
                    return (ushort)MagicEffectData_FieldIndex.SecondActorValue;
                case "CASTINGART":
                    return (ushort)MagicEffectData_FieldIndex.CastingArt;
                case "HITEFFECTART":
                    return (ushort)MagicEffectData_FieldIndex.HitEffectArt;
                case "IMPACTDATA":
                    return (ushort)MagicEffectData_FieldIndex.ImpactData;
                case "SKILLUSAGEMULTIPLIER":
                    return (ushort)MagicEffectData_FieldIndex.SkillUsageMultiplier;
                case "DUALCASTART":
                    return (ushort)MagicEffectData_FieldIndex.DualCastArt;
                case "DUALCASTSCALE":
                    return (ushort)MagicEffectData_FieldIndex.DualCastScale;
                case "ENCHANTART":
                    return (ushort)MagicEffectData_FieldIndex.EnchantArt;
                case "UNKNOWN2":
                    return (ushort)MagicEffectData_FieldIndex.Unknown2;
                case "UNKNOWN3":
                    return (ushort)MagicEffectData_FieldIndex.Unknown3;
                case "EQUIPABILITY":
                    return (ushort)MagicEffectData_FieldIndex.EquipAbility;
                case "IMAGESPACEMODIFIER":
                    return (ushort)MagicEffectData_FieldIndex.ImageSpaceModifier;
                case "PERKTOAPPLY":
                    return (ushort)MagicEffectData_FieldIndex.PerkToApply;
                case "CASTINGSOUNDLEVEL":
                    return (ushort)MagicEffectData_FieldIndex.CastingSoundLevel;
                case "SCRIPTEFFECTAISCORE":
                    return (ushort)MagicEffectData_FieldIndex.ScriptEffectAIScore;
                case "SCRIPTEFFECTAIDELAYTIME":
                    return (ushort)MagicEffectData_FieldIndex.ScriptEffectAIDelayTime;
                default:
                    return null;
            }
        }

        public static bool GetNthIsEnumerable(ushort index)
        {
            MagicEffectData_FieldIndex enu = (MagicEffectData_FieldIndex)index;
            switch (enu)
            {
                case MagicEffectData_FieldIndex.Flags:
                case MagicEffectData_FieldIndex.BaseCost:
                case MagicEffectData_FieldIndex.MagicSkill:
                case MagicEffectData_FieldIndex.ResistValue:
                case MagicEffectData_FieldIndex.CounterEffectCount:
                case MagicEffectData_FieldIndex.Unknown1:
                case MagicEffectData_FieldIndex.CastingLight:
                case MagicEffectData_FieldIndex.TaperWeight:
                case MagicEffectData_FieldIndex.HitShader:
                case MagicEffectData_FieldIndex.EnchantShader:
                case MagicEffectData_FieldIndex.MinimumSkillLevel:
                case MagicEffectData_FieldIndex.SpellmakingArea:
                case MagicEffectData_FieldIndex.SpellmakingCastingTime:
                case MagicEffectData_FieldIndex.TaperCurve:
                case MagicEffectData_FieldIndex.TaperDuration:
                case MagicEffectData_FieldIndex.SecondActorValueWeight:
                case MagicEffectData_FieldIndex.Archetype:
                case MagicEffectData_FieldIndex.Projectile:
                case MagicEffectData_FieldIndex.Explosion:
                case MagicEffectData_FieldIndex.CastType:
                case MagicEffectData_FieldIndex.TargetType:
                case MagicEffectData_FieldIndex.SecondActorValue:
                case MagicEffectData_FieldIndex.CastingArt:
                case MagicEffectData_FieldIndex.HitEffectArt:
                case MagicEffectData_FieldIndex.ImpactData:
                case MagicEffectData_FieldIndex.SkillUsageMultiplier:
                case MagicEffectData_FieldIndex.DualCastArt:
                case MagicEffectData_FieldIndex.DualCastScale:
                case MagicEffectData_FieldIndex.EnchantArt:
                case MagicEffectData_FieldIndex.Unknown2:
                case MagicEffectData_FieldIndex.Unknown3:
                case MagicEffectData_FieldIndex.EquipAbility:
                case MagicEffectData_FieldIndex.ImageSpaceModifier:
                case MagicEffectData_FieldIndex.PerkToApply:
                case MagicEffectData_FieldIndex.CastingSoundLevel:
                case MagicEffectData_FieldIndex.ScriptEffectAIScore:
                case MagicEffectData_FieldIndex.ScriptEffectAIDelayTime:
                    return false;
                default:
                    throw new ArgumentException($"Index is out of range: {index}");
            }
        }

        public static bool GetNthIsLoqui(ushort index)
        {
            MagicEffectData_FieldIndex enu = (MagicEffectData_FieldIndex)index;
            switch (enu)
            {
                case MagicEffectData_FieldIndex.Archetype:
                    return true;
                case MagicEffectData_FieldIndex.Flags:
                case MagicEffectData_FieldIndex.BaseCost:
                case MagicEffectData_FieldIndex.MagicSkill:
                case MagicEffectData_FieldIndex.ResistValue:
                case MagicEffectData_FieldIndex.CounterEffectCount:
                case MagicEffectData_FieldIndex.Unknown1:
                case MagicEffectData_FieldIndex.CastingLight:
                case MagicEffectData_FieldIndex.TaperWeight:
                case MagicEffectData_FieldIndex.HitShader:
                case MagicEffectData_FieldIndex.EnchantShader:
                case MagicEffectData_FieldIndex.MinimumSkillLevel:
                case MagicEffectData_FieldIndex.SpellmakingArea:
                case MagicEffectData_FieldIndex.SpellmakingCastingTime:
                case MagicEffectData_FieldIndex.TaperCurve:
                case MagicEffectData_FieldIndex.TaperDuration:
                case MagicEffectData_FieldIndex.SecondActorValueWeight:
                case MagicEffectData_FieldIndex.Projectile:
                case MagicEffectData_FieldIndex.Explosion:
                case MagicEffectData_FieldIndex.CastType:
                case MagicEffectData_FieldIndex.TargetType:
                case MagicEffectData_FieldIndex.SecondActorValue:
                case MagicEffectData_FieldIndex.CastingArt:
                case MagicEffectData_FieldIndex.HitEffectArt:
                case MagicEffectData_FieldIndex.ImpactData:
                case MagicEffectData_FieldIndex.SkillUsageMultiplier:
                case MagicEffectData_FieldIndex.DualCastArt:
                case MagicEffectData_FieldIndex.DualCastScale:
                case MagicEffectData_FieldIndex.EnchantArt:
                case MagicEffectData_FieldIndex.Unknown2:
                case MagicEffectData_FieldIndex.Unknown3:
                case MagicEffectData_FieldIndex.EquipAbility:
                case MagicEffectData_FieldIndex.ImageSpaceModifier:
                case MagicEffectData_FieldIndex.PerkToApply:
                case MagicEffectData_FieldIndex.CastingSoundLevel:
                case MagicEffectData_FieldIndex.ScriptEffectAIScore:
                case MagicEffectData_FieldIndex.ScriptEffectAIDelayTime:
                    return false;
                default:
                    throw new ArgumentException($"Index is out of range: {index}");
            }
        }

        public static bool GetNthIsSingleton(ushort index)
        {
            MagicEffectData_FieldIndex enu = (MagicEffectData_FieldIndex)index;
            switch (enu)
            {
                case MagicEffectData_FieldIndex.Flags:
                case MagicEffectData_FieldIndex.BaseCost:
                case MagicEffectData_FieldIndex.MagicSkill:
                case MagicEffectData_FieldIndex.ResistValue:
                case MagicEffectData_FieldIndex.CounterEffectCount:
                case MagicEffectData_FieldIndex.Unknown1:
                case MagicEffectData_FieldIndex.CastingLight:
                case MagicEffectData_FieldIndex.TaperWeight:
                case MagicEffectData_FieldIndex.HitShader:
                case MagicEffectData_FieldIndex.EnchantShader:
                case MagicEffectData_FieldIndex.MinimumSkillLevel:
                case MagicEffectData_FieldIndex.SpellmakingArea:
                case MagicEffectData_FieldIndex.SpellmakingCastingTime:
                case MagicEffectData_FieldIndex.TaperCurve:
                case MagicEffectData_FieldIndex.TaperDuration:
                case MagicEffectData_FieldIndex.SecondActorValueWeight:
                case MagicEffectData_FieldIndex.Archetype:
                case MagicEffectData_FieldIndex.Projectile:
                case MagicEffectData_FieldIndex.Explosion:
                case MagicEffectData_FieldIndex.CastType:
                case MagicEffectData_FieldIndex.TargetType:
                case MagicEffectData_FieldIndex.SecondActorValue:
                case MagicEffectData_FieldIndex.CastingArt:
                case MagicEffectData_FieldIndex.HitEffectArt:
                case MagicEffectData_FieldIndex.ImpactData:
                case MagicEffectData_FieldIndex.SkillUsageMultiplier:
                case MagicEffectData_FieldIndex.DualCastArt:
                case MagicEffectData_FieldIndex.DualCastScale:
                case MagicEffectData_FieldIndex.EnchantArt:
                case MagicEffectData_FieldIndex.Unknown2:
                case MagicEffectData_FieldIndex.Unknown3:
                case MagicEffectData_FieldIndex.EquipAbility:
                case MagicEffectData_FieldIndex.ImageSpaceModifier:
                case MagicEffectData_FieldIndex.PerkToApply:
                case MagicEffectData_FieldIndex.CastingSoundLevel:
                case MagicEffectData_FieldIndex.ScriptEffectAIScore:
                case MagicEffectData_FieldIndex.ScriptEffectAIDelayTime:
                    return false;
                default:
                    throw new ArgumentException($"Index is out of range: {index}");
            }
        }

        public static string GetNthName(ushort index)
        {
            MagicEffectData_FieldIndex enu = (MagicEffectData_FieldIndex)index;
            switch (enu)
            {
                case MagicEffectData_FieldIndex.Flags:
                    return "Flags";
                case MagicEffectData_FieldIndex.BaseCost:
                    return "BaseCost";
                case MagicEffectData_FieldIndex.MagicSkill:
                    return "MagicSkill";
                case MagicEffectData_FieldIndex.ResistValue:
                    return "ResistValue";
                case MagicEffectData_FieldIndex.CounterEffectCount:
                    return "CounterEffectCount";
                case MagicEffectData_FieldIndex.Unknown1:
                    return "Unknown1";
                case MagicEffectData_FieldIndex.CastingLight:
                    return "CastingLight";
                case MagicEffectData_FieldIndex.TaperWeight:
                    return "TaperWeight";
                case MagicEffectData_FieldIndex.HitShader:
                    return "HitShader";
                case MagicEffectData_FieldIndex.EnchantShader:
                    return "EnchantShader";
                case MagicEffectData_FieldIndex.MinimumSkillLevel:
                    return "MinimumSkillLevel";
                case MagicEffectData_FieldIndex.SpellmakingArea:
                    return "SpellmakingArea";
                case MagicEffectData_FieldIndex.SpellmakingCastingTime:
                    return "SpellmakingCastingTime";
                case MagicEffectData_FieldIndex.TaperCurve:
                    return "TaperCurve";
                case MagicEffectData_FieldIndex.TaperDuration:
                    return "TaperDuration";
                case MagicEffectData_FieldIndex.SecondActorValueWeight:
                    return "SecondActorValueWeight";
                case MagicEffectData_FieldIndex.Archetype:
                    return "Archetype";
                case MagicEffectData_FieldIndex.Projectile:
                    return "Projectile";
                case MagicEffectData_FieldIndex.Explosion:
                    return "Explosion";
                case MagicEffectData_FieldIndex.CastType:
                    return "CastType";
                case MagicEffectData_FieldIndex.TargetType:
                    return "TargetType";
                case MagicEffectData_FieldIndex.SecondActorValue:
                    return "SecondActorValue";
                case MagicEffectData_FieldIndex.CastingArt:
                    return "CastingArt";
                case MagicEffectData_FieldIndex.HitEffectArt:
                    return "HitEffectArt";
                case MagicEffectData_FieldIndex.ImpactData:
                    return "ImpactData";
                case MagicEffectData_FieldIndex.SkillUsageMultiplier:
                    return "SkillUsageMultiplier";
                case MagicEffectData_FieldIndex.DualCastArt:
                    return "DualCastArt";
                case MagicEffectData_FieldIndex.DualCastScale:
                    return "DualCastScale";
                case MagicEffectData_FieldIndex.EnchantArt:
                    return "EnchantArt";
                case MagicEffectData_FieldIndex.Unknown2:
                    return "Unknown2";
                case MagicEffectData_FieldIndex.Unknown3:
                    return "Unknown3";
                case MagicEffectData_FieldIndex.EquipAbility:
                    return "EquipAbility";
                case MagicEffectData_FieldIndex.ImageSpaceModifier:
                    return "ImageSpaceModifier";
                case MagicEffectData_FieldIndex.PerkToApply:
                    return "PerkToApply";
                case MagicEffectData_FieldIndex.CastingSoundLevel:
                    return "CastingSoundLevel";
                case MagicEffectData_FieldIndex.ScriptEffectAIScore:
                    return "ScriptEffectAIScore";
                case MagicEffectData_FieldIndex.ScriptEffectAIDelayTime:
                    return "ScriptEffectAIDelayTime";
                default:
                    throw new ArgumentException($"Index is out of range: {index}");
            }
        }

        public static bool IsNthDerivative(ushort index)
        {
            MagicEffectData_FieldIndex enu = (MagicEffectData_FieldIndex)index;
            switch (enu)
            {
                case MagicEffectData_FieldIndex.Flags:
                case MagicEffectData_FieldIndex.BaseCost:
                case MagicEffectData_FieldIndex.MagicSkill:
                case MagicEffectData_FieldIndex.ResistValue:
                case MagicEffectData_FieldIndex.CounterEffectCount:
                case MagicEffectData_FieldIndex.Unknown1:
                case MagicEffectData_FieldIndex.CastingLight:
                case MagicEffectData_FieldIndex.TaperWeight:
                case MagicEffectData_FieldIndex.HitShader:
                case MagicEffectData_FieldIndex.EnchantShader:
                case MagicEffectData_FieldIndex.MinimumSkillLevel:
                case MagicEffectData_FieldIndex.SpellmakingArea:
                case MagicEffectData_FieldIndex.SpellmakingCastingTime:
                case MagicEffectData_FieldIndex.TaperCurve:
                case MagicEffectData_FieldIndex.TaperDuration:
                case MagicEffectData_FieldIndex.SecondActorValueWeight:
                case MagicEffectData_FieldIndex.Archetype:
                case MagicEffectData_FieldIndex.Projectile:
                case MagicEffectData_FieldIndex.Explosion:
                case MagicEffectData_FieldIndex.CastType:
                case MagicEffectData_FieldIndex.TargetType:
                case MagicEffectData_FieldIndex.SecondActorValue:
                case MagicEffectData_FieldIndex.CastingArt:
                case MagicEffectData_FieldIndex.HitEffectArt:
                case MagicEffectData_FieldIndex.ImpactData:
                case MagicEffectData_FieldIndex.SkillUsageMultiplier:
                case MagicEffectData_FieldIndex.DualCastArt:
                case MagicEffectData_FieldIndex.DualCastScale:
                case MagicEffectData_FieldIndex.EnchantArt:
                case MagicEffectData_FieldIndex.Unknown2:
                case MagicEffectData_FieldIndex.Unknown3:
                case MagicEffectData_FieldIndex.EquipAbility:
                case MagicEffectData_FieldIndex.ImageSpaceModifier:
                case MagicEffectData_FieldIndex.PerkToApply:
                case MagicEffectData_FieldIndex.CastingSoundLevel:
                case MagicEffectData_FieldIndex.ScriptEffectAIScore:
                case MagicEffectData_FieldIndex.ScriptEffectAIDelayTime:
                    return false;
                default:
                    throw new ArgumentException($"Index is out of range: {index}");
            }
        }

        public static bool IsProtected(ushort index)
        {
            MagicEffectData_FieldIndex enu = (MagicEffectData_FieldIndex)index;
            switch (enu)
            {
                case MagicEffectData_FieldIndex.Flags:
                case MagicEffectData_FieldIndex.BaseCost:
                case MagicEffectData_FieldIndex.MagicSkill:
                case MagicEffectData_FieldIndex.ResistValue:
                case MagicEffectData_FieldIndex.CounterEffectCount:
                case MagicEffectData_FieldIndex.Unknown1:
                case MagicEffectData_FieldIndex.CastingLight:
                case MagicEffectData_FieldIndex.TaperWeight:
                case MagicEffectData_FieldIndex.HitShader:
                case MagicEffectData_FieldIndex.EnchantShader:
                case MagicEffectData_FieldIndex.MinimumSkillLevel:
                case MagicEffectData_FieldIndex.SpellmakingArea:
                case MagicEffectData_FieldIndex.SpellmakingCastingTime:
                case MagicEffectData_FieldIndex.TaperCurve:
                case MagicEffectData_FieldIndex.TaperDuration:
                case MagicEffectData_FieldIndex.SecondActorValueWeight:
                case MagicEffectData_FieldIndex.Archetype:
                case MagicEffectData_FieldIndex.Projectile:
                case MagicEffectData_FieldIndex.Explosion:
                case MagicEffectData_FieldIndex.CastType:
                case MagicEffectData_FieldIndex.TargetType:
                case MagicEffectData_FieldIndex.SecondActorValue:
                case MagicEffectData_FieldIndex.CastingArt:
                case MagicEffectData_FieldIndex.HitEffectArt:
                case MagicEffectData_FieldIndex.ImpactData:
                case MagicEffectData_FieldIndex.SkillUsageMultiplier:
                case MagicEffectData_FieldIndex.DualCastArt:
                case MagicEffectData_FieldIndex.DualCastScale:
                case MagicEffectData_FieldIndex.EnchantArt:
                case MagicEffectData_FieldIndex.Unknown2:
                case MagicEffectData_FieldIndex.Unknown3:
                case MagicEffectData_FieldIndex.EquipAbility:
                case MagicEffectData_FieldIndex.ImageSpaceModifier:
                case MagicEffectData_FieldIndex.PerkToApply:
                case MagicEffectData_FieldIndex.CastingSoundLevel:
                case MagicEffectData_FieldIndex.ScriptEffectAIScore:
                case MagicEffectData_FieldIndex.ScriptEffectAIDelayTime:
                    return false;
                default:
                    throw new ArgumentException($"Index is out of range: {index}");
            }
        }

        public static Type GetNthType(ushort index)
        {
            MagicEffectData_FieldIndex enu = (MagicEffectData_FieldIndex)index;
            switch (enu)
            {
                case MagicEffectData_FieldIndex.Flags:
                    return typeof(MagicEffect.Flag);
                case MagicEffectData_FieldIndex.BaseCost:
                    return typeof(Single);
                case MagicEffectData_FieldIndex.MagicSkill:
                    return typeof(ActorValueExtended);
                case MagicEffectData_FieldIndex.ResistValue:
                    return typeof(ActorValueExtended);
                case MagicEffectData_FieldIndex.CounterEffectCount:
                    return typeof(UInt16);
                case MagicEffectData_FieldIndex.Unknown1:
                    return typeof(UInt16);
                case MagicEffectData_FieldIndex.CastingLight:
                    return typeof(IFormLink<Light>);
                case MagicEffectData_FieldIndex.TaperWeight:
                    return typeof(Single);
                case MagicEffectData_FieldIndex.HitShader:
                    return typeof(IFormLink<EffectShader>);
                case MagicEffectData_FieldIndex.EnchantShader:
                    return typeof(IFormLink<EffectShader>);
                case MagicEffectData_FieldIndex.MinimumSkillLevel:
                    return typeof(UInt32);
                case MagicEffectData_FieldIndex.SpellmakingArea:
                    return typeof(UInt32);
                case MagicEffectData_FieldIndex.SpellmakingCastingTime:
                    return typeof(Single);
                case MagicEffectData_FieldIndex.TaperCurve:
                    return typeof(Single);
                case MagicEffectData_FieldIndex.TaperDuration:
                    return typeof(Single);
                case MagicEffectData_FieldIndex.SecondActorValueWeight:
                    return typeof(Single);
                case MagicEffectData_FieldIndex.Archetype:
                    return typeof(MagicEffectArchetype);
                case MagicEffectData_FieldIndex.Projectile:
                    return typeof(IFormLink<Projectile>);
                case MagicEffectData_FieldIndex.Explosion:
                    return typeof(IFormLink<Explosion>);
                case MagicEffectData_FieldIndex.CastType:
                    return typeof(CastType);
                case MagicEffectData_FieldIndex.TargetType:
                    return typeof(TargetType);
                case MagicEffectData_FieldIndex.SecondActorValue:
                    return typeof(ActorValueExtended);
                case MagicEffectData_FieldIndex.CastingArt:
                    return typeof(IFormLink<ArtObject>);
                case MagicEffectData_FieldIndex.HitEffectArt:
                    return typeof(IFormLink<ArtObject>);
                case MagicEffectData_FieldIndex.ImpactData:
                    return typeof(IFormLink<ImpactDataSet>);
                case MagicEffectData_FieldIndex.SkillUsageMultiplier:
                    return typeof(Single);
                case MagicEffectData_FieldIndex.DualCastArt:
                    return typeof(IFormLink<DualCastData>);
                case MagicEffectData_FieldIndex.DualCastScale:
                    return typeof(Single);
                case MagicEffectData_FieldIndex.EnchantArt:
                    return typeof(IFormLink<ArtObject>);
                case MagicEffectData_FieldIndex.Unknown2:
                    return typeof(IFormLink<SkyrimMajorRecord>);
                case MagicEffectData_FieldIndex.Unknown3:
                    return typeof(IFormLink<SkyrimMajorRecord>);
                case MagicEffectData_FieldIndex.EquipAbility:
                    return typeof(IFormLink<Spell>);
                case MagicEffectData_FieldIndex.ImageSpaceModifier:
                    return typeof(IFormLink<ImageSpaceAdapter>);
                case MagicEffectData_FieldIndex.PerkToApply:
                    return typeof(IFormLink<Perk>);
                case MagicEffectData_FieldIndex.CastingSoundLevel:
                    return typeof(SoundLevel);
                case MagicEffectData_FieldIndex.ScriptEffectAIScore:
                    return typeof(Single);
                case MagicEffectData_FieldIndex.ScriptEffectAIDelayTime:
                    return typeof(Single);
                default:
                    throw new ArgumentException($"Index is out of range: {index}");
            }
        }

        public static readonly Type XmlWriteTranslation = typeof(MagicEffectDataXmlWriteTranslation);
        public static readonly RecordType DATA_HEADER = new RecordType("DATA");
        public static readonly RecordType TriggeringRecordType = DATA_HEADER;
        public const int NumStructFields = 37;
        public const int NumTypedFields = 0;
        public static readonly Type BinaryWriteTranslation = typeof(MagicEffectDataBinaryWriteTranslation);
        #region Interface
        ProtocolKey ILoquiRegistration.ProtocolKey => ProtocolKey;
        ObjectKey ILoquiRegistration.ObjectKey => ObjectKey;
        string ILoquiRegistration.GUID => GUID;
        ushort ILoquiRegistration.FieldCount => FieldCount;
        ushort ILoquiRegistration.AdditionalFieldCount => AdditionalFieldCount;
        Type ILoquiRegistration.MaskType => MaskType;
        Type ILoquiRegistration.ErrorMaskType => ErrorMaskType;
        Type ILoquiRegistration.ClassType => ClassType;
        Type ILoquiRegistration.SetterType => SetterType;
        Type? ILoquiRegistration.InternalSetterType => InternalSetterType;
        Type ILoquiRegistration.GetterType => GetterType;
        Type? ILoquiRegistration.InternalGetterType => InternalGetterType;
        string ILoquiRegistration.FullName => FullName;
        string ILoquiRegistration.Name => Name;
        string ILoquiRegistration.Namespace => Namespace;
        byte ILoquiRegistration.GenericCount => GenericCount;
        Type? ILoquiRegistration.GenericRegistrationType => GenericRegistrationType;
        ushort? ILoquiRegistration.GetNameIndex(StringCaseAgnostic name) => GetNameIndex(name);
        bool ILoquiRegistration.GetNthIsEnumerable(ushort index) => GetNthIsEnumerable(index);
        bool ILoquiRegistration.GetNthIsLoqui(ushort index) => GetNthIsLoqui(index);
        bool ILoquiRegistration.GetNthIsSingleton(ushort index) => GetNthIsSingleton(index);
        string ILoquiRegistration.GetNthName(ushort index) => GetNthName(index);
        bool ILoquiRegistration.IsNthDerivative(ushort index) => IsNthDerivative(index);
        bool ILoquiRegistration.IsProtected(ushort index) => IsProtected(index);
        Type ILoquiRegistration.GetNthType(ushort index) => GetNthType(index);
        #endregion

    }
    #endregion

    #region Common
    public partial class MagicEffectDataSetterCommon
    {
        public static readonly MagicEffectDataSetterCommon Instance = new MagicEffectDataSetterCommon();

        partial void ClearPartial();
        
        public void Clear(IMagicEffectData item)
        {
            ClearPartial();
            item.Flags = default;
            item.BaseCost = default;
            item.MagicSkill = default;
            item.ResistValue = default;
            item.CounterEffectCount = default;
            item.Unknown1 = default;
            item.CastingLight.FormKey = FormKey.Null;
            item.TaperWeight = default;
            item.HitShader.FormKey = FormKey.Null;
            item.EnchantShader.FormKey = FormKey.Null;
            item.MinimumSkillLevel = default;
            item.SpellmakingArea = default;
            item.SpellmakingCastingTime = default;
            item.TaperCurve = default;
            item.TaperDuration = default;
            item.SecondActorValueWeight = default;
            item.Archetype.Clear();
            item.Projectile.FormKey = FormKey.Null;
            item.Explosion.FormKey = FormKey.Null;
            item.CastType = default;
            item.TargetType = default;
            item.SecondActorValue = default;
            item.CastingArt.FormKey = FormKey.Null;
            item.HitEffectArt.FormKey = FormKey.Null;
            item.ImpactData.FormKey = FormKey.Null;
            item.SkillUsageMultiplier = default;
            item.DualCastArt.FormKey = FormKey.Null;
            item.DualCastScale = default;
            item.EnchantArt.FormKey = FormKey.Null;
            item.Unknown2.FormKey = FormKey.Null;
            item.Unknown3.FormKey = FormKey.Null;
            item.EquipAbility.FormKey = FormKey.Null;
            item.ImageSpaceModifier.FormKey = FormKey.Null;
            item.PerkToApply.FormKey = FormKey.Null;
            item.CastingSoundLevel = default;
            item.ScriptEffectAIScore = default;
            item.ScriptEffectAIDelayTime = default;
        }
        
        #region Xml Translation
        public virtual void CopyInFromXml(
            IMagicEffectData item,
            XElement node,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask)
        {
            try
            {
                foreach (var elem in node.Elements())
                {
                    MagicEffectDataXmlCreateTranslation.FillPublicElementXml(
                        item: item,
                        node: elem,
                        name: elem.Name.LocalName,
                        errorMask: errorMask,
                        translationMask: translationMask);
                }
            }
            catch (Exception ex)
            when (errorMask != null)
            {
                errorMask.ReportException(ex);
            }
        }
        
        #endregion
        
        #region Binary Translation
        protected static void FillBinaryStructs(
            IMagicEffectData item,
            MutagenFrame frame)
        {
            item.Flags = EnumBinaryTranslation<MagicEffect.Flag>.Instance.Parse(frame: frame.SpawnWithLength(4));
            item.BaseCost = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
            MagicEffectDataBinaryCreateTranslation.FillBinaryAssociatedItemCustomPublic(
                frame: frame,
                item: item);
            item.MagicSkill = EnumBinaryTranslation<ActorValueExtended>.Instance.Parse(frame: frame.SpawnWithLength(4));
            item.ResistValue = EnumBinaryTranslation<ActorValueExtended>.Instance.Parse(frame: frame.SpawnWithLength(4));
            item.CounterEffectCount = frame.ReadUInt16();
            item.Unknown1 = frame.ReadUInt16();
            item.CastingLight.FormKey = Mutagen.Bethesda.Binary.FormLinkBinaryTranslation.Instance.Parse(
                frame: frame,
                defaultVal: FormKey.Null);
            item.TaperWeight = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
            item.HitShader.FormKey = Mutagen.Bethesda.Binary.FormLinkBinaryTranslation.Instance.Parse(
                frame: frame,
                defaultVal: FormKey.Null);
            item.EnchantShader.FormKey = Mutagen.Bethesda.Binary.FormLinkBinaryTranslation.Instance.Parse(
                frame: frame,
                defaultVal: FormKey.Null);
            item.MinimumSkillLevel = frame.ReadUInt32();
            item.SpellmakingArea = frame.ReadUInt32();
            item.SpellmakingCastingTime = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
            item.TaperCurve = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
            item.TaperDuration = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
            item.SecondActorValueWeight = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
            MagicEffectDataBinaryCreateTranslation.FillBinaryArchetypeCustomPublic(
                frame: frame,
                item: item);
            item.Projectile.FormKey = Mutagen.Bethesda.Binary.FormLinkBinaryTranslation.Instance.Parse(
                frame: frame,
                defaultVal: FormKey.Null);
            item.Explosion.FormKey = Mutagen.Bethesda.Binary.FormLinkBinaryTranslation.Instance.Parse(
                frame: frame,
                defaultVal: FormKey.Null);
            item.CastType = EnumBinaryTranslation<CastType>.Instance.Parse(frame: frame.SpawnWithLength(4));
            item.TargetType = EnumBinaryTranslation<TargetType>.Instance.Parse(frame: frame.SpawnWithLength(4));
            item.SecondActorValue = EnumBinaryTranslation<ActorValueExtended>.Instance.Parse(frame: frame.SpawnWithLength(4));
            item.CastingArt.FormKey = Mutagen.Bethesda.Binary.FormLinkBinaryTranslation.Instance.Parse(
                frame: frame,
                defaultVal: FormKey.Null);
            item.HitEffectArt.FormKey = Mutagen.Bethesda.Binary.FormLinkBinaryTranslation.Instance.Parse(
                frame: frame,
                defaultVal: FormKey.Null);
            item.ImpactData.FormKey = Mutagen.Bethesda.Binary.FormLinkBinaryTranslation.Instance.Parse(
                frame: frame,
                defaultVal: FormKey.Null);
            item.SkillUsageMultiplier = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
            item.DualCastArt.FormKey = Mutagen.Bethesda.Binary.FormLinkBinaryTranslation.Instance.Parse(
                frame: frame,
                defaultVal: FormKey.Null);
            item.DualCastScale = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
            item.EnchantArt.FormKey = Mutagen.Bethesda.Binary.FormLinkBinaryTranslation.Instance.Parse(
                frame: frame,
                defaultVal: FormKey.Null);
            item.Unknown2.FormKey = Mutagen.Bethesda.Binary.FormLinkBinaryTranslation.Instance.Parse(
                frame: frame,
                defaultVal: FormKey.Null);
            item.Unknown3.FormKey = Mutagen.Bethesda.Binary.FormLinkBinaryTranslation.Instance.Parse(
                frame: frame,
                defaultVal: FormKey.Null);
            item.EquipAbility.FormKey = Mutagen.Bethesda.Binary.FormLinkBinaryTranslation.Instance.Parse(
                frame: frame,
                defaultVal: FormKey.Null);
            item.ImageSpaceModifier.FormKey = Mutagen.Bethesda.Binary.FormLinkBinaryTranslation.Instance.Parse(
                frame: frame,
                defaultVal: FormKey.Null);
            item.PerkToApply.FormKey = Mutagen.Bethesda.Binary.FormLinkBinaryTranslation.Instance.Parse(
                frame: frame,
                defaultVal: FormKey.Null);
            item.CastingSoundLevel = EnumBinaryTranslation<SoundLevel>.Instance.Parse(frame: frame.SpawnWithLength(4));
            item.ScriptEffectAIScore = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
            item.ScriptEffectAIDelayTime = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
        }
        
        public virtual void CopyInFromBinary(
            IMagicEffectData item,
            MutagenFrame frame,
            RecordTypeConverter? recordTypeConverter = null)
        {
            frame = frame.SpawnWithFinalPosition(HeaderTranslation.ParseSubrecord(
                frame.Reader,
                recordTypeConverter.ConvertToCustom(MagicEffectData_Registration.DATA_HEADER)));
            UtilityTranslation.SubrecordParse(
                record: item,
                frame: frame,
                recordTypeConverter: recordTypeConverter,
                fillStructs: FillBinaryStructs);
        }
        
        #endregion
        
    }
    public partial class MagicEffectDataCommon
    {
        public static readonly MagicEffectDataCommon Instance = new MagicEffectDataCommon();

        public MagicEffectData.Mask<bool> GetEqualsMask(
            IMagicEffectDataGetter item,
            IMagicEffectDataGetter rhs,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            var ret = new MagicEffectData.Mask<bool>(false);
            ((MagicEffectDataCommon)((IMagicEffectDataGetter)item).CommonInstance()!).FillEqualsMask(
                item: item,
                rhs: rhs,
                ret: ret,
                include: include);
            return ret;
        }
        
        public void FillEqualsMask(
            IMagicEffectDataGetter item,
            IMagicEffectDataGetter rhs,
            MagicEffectData.Mask<bool> ret,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            if (rhs == null) return;
            ret.Flags = item.Flags == rhs.Flags;
            ret.BaseCost = item.BaseCost.EqualsWithin(rhs.BaseCost);
            ret.MagicSkill = item.MagicSkill == rhs.MagicSkill;
            ret.ResistValue = item.ResistValue == rhs.ResistValue;
            ret.CounterEffectCount = item.CounterEffectCount == rhs.CounterEffectCount;
            ret.Unknown1 = item.Unknown1 == rhs.Unknown1;
            ret.CastingLight = object.Equals(item.CastingLight, rhs.CastingLight);
            ret.TaperWeight = item.TaperWeight.EqualsWithin(rhs.TaperWeight);
            ret.HitShader = object.Equals(item.HitShader, rhs.HitShader);
            ret.EnchantShader = object.Equals(item.EnchantShader, rhs.EnchantShader);
            ret.MinimumSkillLevel = item.MinimumSkillLevel == rhs.MinimumSkillLevel;
            ret.SpellmakingArea = item.SpellmakingArea == rhs.SpellmakingArea;
            ret.SpellmakingCastingTime = item.SpellmakingCastingTime.EqualsWithin(rhs.SpellmakingCastingTime);
            ret.TaperCurve = item.TaperCurve.EqualsWithin(rhs.TaperCurve);
            ret.TaperDuration = item.TaperDuration.EqualsWithin(rhs.TaperDuration);
            ret.SecondActorValueWeight = item.SecondActorValueWeight.EqualsWithin(rhs.SecondActorValueWeight);
            ret.Archetype = MaskItemExt.Factory(item.Archetype.GetEqualsMask(rhs.Archetype, include), include);
            ret.Projectile = object.Equals(item.Projectile, rhs.Projectile);
            ret.Explosion = object.Equals(item.Explosion, rhs.Explosion);
            ret.CastType = item.CastType == rhs.CastType;
            ret.TargetType = item.TargetType == rhs.TargetType;
            ret.SecondActorValue = item.SecondActorValue == rhs.SecondActorValue;
            ret.CastingArt = object.Equals(item.CastingArt, rhs.CastingArt);
            ret.HitEffectArt = object.Equals(item.HitEffectArt, rhs.HitEffectArt);
            ret.ImpactData = object.Equals(item.ImpactData, rhs.ImpactData);
            ret.SkillUsageMultiplier = item.SkillUsageMultiplier.EqualsWithin(rhs.SkillUsageMultiplier);
            ret.DualCastArt = object.Equals(item.DualCastArt, rhs.DualCastArt);
            ret.DualCastScale = item.DualCastScale.EqualsWithin(rhs.DualCastScale);
            ret.EnchantArt = object.Equals(item.EnchantArt, rhs.EnchantArt);
            ret.Unknown2 = object.Equals(item.Unknown2, rhs.Unknown2);
            ret.Unknown3 = object.Equals(item.Unknown3, rhs.Unknown3);
            ret.EquipAbility = object.Equals(item.EquipAbility, rhs.EquipAbility);
            ret.ImageSpaceModifier = object.Equals(item.ImageSpaceModifier, rhs.ImageSpaceModifier);
            ret.PerkToApply = object.Equals(item.PerkToApply, rhs.PerkToApply);
            ret.CastingSoundLevel = item.CastingSoundLevel == rhs.CastingSoundLevel;
            ret.ScriptEffectAIScore = item.ScriptEffectAIScore.EqualsWithin(rhs.ScriptEffectAIScore);
            ret.ScriptEffectAIDelayTime = item.ScriptEffectAIDelayTime.EqualsWithin(rhs.ScriptEffectAIDelayTime);
        }
        
        public string ToString(
            IMagicEffectDataGetter item,
            string? name = null,
            MagicEffectData.Mask<bool>? printMask = null)
        {
            var fg = new FileGeneration();
            ToString(
                item: item,
                fg: fg,
                name: name,
                printMask: printMask);
            return fg.ToString();
        }
        
        public void ToString(
            IMagicEffectDataGetter item,
            FileGeneration fg,
            string? name = null,
            MagicEffectData.Mask<bool>? printMask = null)
        {
            if (name == null)
            {
                fg.AppendLine($"MagicEffectData =>");
            }
            else
            {
                fg.AppendLine($"{name} (MagicEffectData) =>");
            }
            fg.AppendLine("[");
            using (new DepthWrapper(fg))
            {
                ToStringFields(
                    item: item,
                    fg: fg,
                    printMask: printMask);
            }
            fg.AppendLine("]");
        }
        
        protected static void ToStringFields(
            IMagicEffectDataGetter item,
            FileGeneration fg,
            MagicEffectData.Mask<bool>? printMask = null)
        {
            if (printMask?.Flags ?? true)
            {
                fg.AppendItem(item.Flags, "Flags");
            }
            if (printMask?.BaseCost ?? true)
            {
                fg.AppendItem(item.BaseCost, "BaseCost");
            }
            if (printMask?.MagicSkill ?? true)
            {
                fg.AppendItem(item.MagicSkill, "MagicSkill");
            }
            if (printMask?.ResistValue ?? true)
            {
                fg.AppendItem(item.ResistValue, "ResistValue");
            }
            if (printMask?.CounterEffectCount ?? true)
            {
                fg.AppendItem(item.CounterEffectCount, "CounterEffectCount");
            }
            if (printMask?.Unknown1 ?? true)
            {
                fg.AppendItem(item.Unknown1, "Unknown1");
            }
            if (printMask?.CastingLight ?? true)
            {
                fg.AppendItem(item.CastingLight, "CastingLight");
            }
            if (printMask?.TaperWeight ?? true)
            {
                fg.AppendItem(item.TaperWeight, "TaperWeight");
            }
            if (printMask?.HitShader ?? true)
            {
                fg.AppendItem(item.HitShader, "HitShader");
            }
            if (printMask?.EnchantShader ?? true)
            {
                fg.AppendItem(item.EnchantShader, "EnchantShader");
            }
            if (printMask?.MinimumSkillLevel ?? true)
            {
                fg.AppendItem(item.MinimumSkillLevel, "MinimumSkillLevel");
            }
            if (printMask?.SpellmakingArea ?? true)
            {
                fg.AppendItem(item.SpellmakingArea, "SpellmakingArea");
            }
            if (printMask?.SpellmakingCastingTime ?? true)
            {
                fg.AppendItem(item.SpellmakingCastingTime, "SpellmakingCastingTime");
            }
            if (printMask?.TaperCurve ?? true)
            {
                fg.AppendItem(item.TaperCurve, "TaperCurve");
            }
            if (printMask?.TaperDuration ?? true)
            {
                fg.AppendItem(item.TaperDuration, "TaperDuration");
            }
            if (printMask?.SecondActorValueWeight ?? true)
            {
                fg.AppendItem(item.SecondActorValueWeight, "SecondActorValueWeight");
            }
            if (printMask?.Archetype?.Overall ?? true)
            {
                item.Archetype?.ToString(fg, "Archetype");
            }
            if (printMask?.Projectile ?? true)
            {
                fg.AppendItem(item.Projectile, "Projectile");
            }
            if (printMask?.Explosion ?? true)
            {
                fg.AppendItem(item.Explosion, "Explosion");
            }
            if (printMask?.CastType ?? true)
            {
                fg.AppendItem(item.CastType, "CastType");
            }
            if (printMask?.TargetType ?? true)
            {
                fg.AppendItem(item.TargetType, "TargetType");
            }
            if (printMask?.SecondActorValue ?? true)
            {
                fg.AppendItem(item.SecondActorValue, "SecondActorValue");
            }
            if (printMask?.CastingArt ?? true)
            {
                fg.AppendItem(item.CastingArt, "CastingArt");
            }
            if (printMask?.HitEffectArt ?? true)
            {
                fg.AppendItem(item.HitEffectArt, "HitEffectArt");
            }
            if (printMask?.ImpactData ?? true)
            {
                fg.AppendItem(item.ImpactData, "ImpactData");
            }
            if (printMask?.SkillUsageMultiplier ?? true)
            {
                fg.AppendItem(item.SkillUsageMultiplier, "SkillUsageMultiplier");
            }
            if (printMask?.DualCastArt ?? true)
            {
                fg.AppendItem(item.DualCastArt, "DualCastArt");
            }
            if (printMask?.DualCastScale ?? true)
            {
                fg.AppendItem(item.DualCastScale, "DualCastScale");
            }
            if (printMask?.EnchantArt ?? true)
            {
                fg.AppendItem(item.EnchantArt, "EnchantArt");
            }
            if (printMask?.Unknown2 ?? true)
            {
                fg.AppendItem(item.Unknown2, "Unknown2");
            }
            if (printMask?.Unknown3 ?? true)
            {
                fg.AppendItem(item.Unknown3, "Unknown3");
            }
            if (printMask?.EquipAbility ?? true)
            {
                fg.AppendItem(item.EquipAbility, "EquipAbility");
            }
            if (printMask?.ImageSpaceModifier ?? true)
            {
                fg.AppendItem(item.ImageSpaceModifier, "ImageSpaceModifier");
            }
            if (printMask?.PerkToApply ?? true)
            {
                fg.AppendItem(item.PerkToApply, "PerkToApply");
            }
            if (printMask?.CastingSoundLevel ?? true)
            {
                fg.AppendItem(item.CastingSoundLevel, "CastingSoundLevel");
            }
            if (printMask?.ScriptEffectAIScore ?? true)
            {
                fg.AppendItem(item.ScriptEffectAIScore, "ScriptEffectAIScore");
            }
            if (printMask?.ScriptEffectAIDelayTime ?? true)
            {
                fg.AppendItem(item.ScriptEffectAIDelayTime, "ScriptEffectAIDelayTime");
            }
        }
        
        public bool HasBeenSet(
            IMagicEffectDataGetter item,
            MagicEffectData.Mask<bool?> checkMask)
        {
            return true;
        }
        
        public void FillHasBeenSetMask(
            IMagicEffectDataGetter item,
            MagicEffectData.Mask<bool> mask)
        {
            mask.Flags = true;
            mask.BaseCost = true;
            mask.MagicSkill = true;
            mask.ResistValue = true;
            mask.CounterEffectCount = true;
            mask.Unknown1 = true;
            mask.CastingLight = true;
            mask.TaperWeight = true;
            mask.HitShader = true;
            mask.EnchantShader = true;
            mask.MinimumSkillLevel = true;
            mask.SpellmakingArea = true;
            mask.SpellmakingCastingTime = true;
            mask.TaperCurve = true;
            mask.TaperDuration = true;
            mask.SecondActorValueWeight = true;
            mask.Archetype = new MaskItem<bool, MagicEffectArchetype.Mask<bool>?>(true, item.Archetype?.GetHasBeenSetMask());
            mask.Projectile = true;
            mask.Explosion = true;
            mask.CastType = true;
            mask.TargetType = true;
            mask.SecondActorValue = true;
            mask.CastingArt = true;
            mask.HitEffectArt = true;
            mask.ImpactData = true;
            mask.SkillUsageMultiplier = true;
            mask.DualCastArt = true;
            mask.DualCastScale = true;
            mask.EnchantArt = true;
            mask.Unknown2 = true;
            mask.Unknown3 = true;
            mask.EquipAbility = true;
            mask.ImageSpaceModifier = true;
            mask.PerkToApply = true;
            mask.CastingSoundLevel = true;
            mask.ScriptEffectAIScore = true;
            mask.ScriptEffectAIDelayTime = true;
        }
        
        #region Equals and Hash
        public virtual bool Equals(
            IMagicEffectDataGetter? lhs,
            IMagicEffectDataGetter? rhs)
        {
            if (lhs == null && rhs == null) return false;
            if (lhs == null || rhs == null) return false;
            if (lhs.Flags != rhs.Flags) return false;
            if (!lhs.BaseCost.EqualsWithin(rhs.BaseCost)) return false;
            if (lhs.MagicSkill != rhs.MagicSkill) return false;
            if (lhs.ResistValue != rhs.ResistValue) return false;
            if (lhs.CounterEffectCount != rhs.CounterEffectCount) return false;
            if (lhs.Unknown1 != rhs.Unknown1) return false;
            if (!lhs.CastingLight.Equals(rhs.CastingLight)) return false;
            if (!lhs.TaperWeight.EqualsWithin(rhs.TaperWeight)) return false;
            if (!lhs.HitShader.Equals(rhs.HitShader)) return false;
            if (!lhs.EnchantShader.Equals(rhs.EnchantShader)) return false;
            if (lhs.MinimumSkillLevel != rhs.MinimumSkillLevel) return false;
            if (lhs.SpellmakingArea != rhs.SpellmakingArea) return false;
            if (!lhs.SpellmakingCastingTime.EqualsWithin(rhs.SpellmakingCastingTime)) return false;
            if (!lhs.TaperCurve.EqualsWithin(rhs.TaperCurve)) return false;
            if (!lhs.TaperDuration.EqualsWithin(rhs.TaperDuration)) return false;
            if (!lhs.SecondActorValueWeight.EqualsWithin(rhs.SecondActorValueWeight)) return false;
            if (!object.Equals(lhs.Archetype, rhs.Archetype)) return false;
            if (!lhs.Projectile.Equals(rhs.Projectile)) return false;
            if (!lhs.Explosion.Equals(rhs.Explosion)) return false;
            if (lhs.CastType != rhs.CastType) return false;
            if (lhs.TargetType != rhs.TargetType) return false;
            if (lhs.SecondActorValue != rhs.SecondActorValue) return false;
            if (!lhs.CastingArt.Equals(rhs.CastingArt)) return false;
            if (!lhs.HitEffectArt.Equals(rhs.HitEffectArt)) return false;
            if (!lhs.ImpactData.Equals(rhs.ImpactData)) return false;
            if (!lhs.SkillUsageMultiplier.EqualsWithin(rhs.SkillUsageMultiplier)) return false;
            if (!lhs.DualCastArt.Equals(rhs.DualCastArt)) return false;
            if (!lhs.DualCastScale.EqualsWithin(rhs.DualCastScale)) return false;
            if (!lhs.EnchantArt.Equals(rhs.EnchantArt)) return false;
            if (!lhs.Unknown2.Equals(rhs.Unknown2)) return false;
            if (!lhs.Unknown3.Equals(rhs.Unknown3)) return false;
            if (!lhs.EquipAbility.Equals(rhs.EquipAbility)) return false;
            if (!lhs.ImageSpaceModifier.Equals(rhs.ImageSpaceModifier)) return false;
            if (!lhs.PerkToApply.Equals(rhs.PerkToApply)) return false;
            if (lhs.CastingSoundLevel != rhs.CastingSoundLevel) return false;
            if (!lhs.ScriptEffectAIScore.EqualsWithin(rhs.ScriptEffectAIScore)) return false;
            if (!lhs.ScriptEffectAIDelayTime.EqualsWithin(rhs.ScriptEffectAIDelayTime)) return false;
            return true;
        }
        
        public virtual int GetHashCode(IMagicEffectDataGetter item)
        {
            var hash = new HashCode();
            hash.Add(item.Flags);
            hash.Add(item.BaseCost);
            hash.Add(item.MagicSkill);
            hash.Add(item.ResistValue);
            hash.Add(item.CounterEffectCount);
            hash.Add(item.Unknown1);
            hash.Add(item.CastingLight);
            hash.Add(item.TaperWeight);
            hash.Add(item.HitShader);
            hash.Add(item.EnchantShader);
            hash.Add(item.MinimumSkillLevel);
            hash.Add(item.SpellmakingArea);
            hash.Add(item.SpellmakingCastingTime);
            hash.Add(item.TaperCurve);
            hash.Add(item.TaperDuration);
            hash.Add(item.SecondActorValueWeight);
            hash.Add(item.Archetype);
            hash.Add(item.Projectile);
            hash.Add(item.Explosion);
            hash.Add(item.CastType);
            hash.Add(item.TargetType);
            hash.Add(item.SecondActorValue);
            hash.Add(item.CastingArt);
            hash.Add(item.HitEffectArt);
            hash.Add(item.ImpactData);
            hash.Add(item.SkillUsageMultiplier);
            hash.Add(item.DualCastArt);
            hash.Add(item.DualCastScale);
            hash.Add(item.EnchantArt);
            hash.Add(item.Unknown2);
            hash.Add(item.Unknown3);
            hash.Add(item.EquipAbility);
            hash.Add(item.ImageSpaceModifier);
            hash.Add(item.PerkToApply);
            hash.Add(item.CastingSoundLevel);
            hash.Add(item.ScriptEffectAIScore);
            hash.Add(item.ScriptEffectAIDelayTime);
            return hash.ToHashCode();
        }
        
        #endregion
        
        
        public object GetNew()
        {
            return MagicEffectData.GetNew();
        }
        
        #region Mutagen
        public IEnumerable<ILinkGetter> GetLinks(IMagicEffectDataGetter obj)
        {
            yield return obj.CastingLight;
            yield return obj.HitShader;
            yield return obj.EnchantShader;
            yield return obj.Projectile;
            yield return obj.Explosion;
            yield return obj.CastingArt;
            yield return obj.HitEffectArt;
            yield return obj.ImpactData;
            yield return obj.DualCastArt;
            yield return obj.EnchantArt;
            yield return obj.Unknown2;
            yield return obj.Unknown3;
            yield return obj.EquipAbility;
            yield return obj.ImageSpaceModifier;
            yield return obj.PerkToApply;
            yield break;
        }
        
        #endregion
        
    }
    public partial class MagicEffectDataSetterTranslationCommon
    {
        public static readonly MagicEffectDataSetterTranslationCommon Instance = new MagicEffectDataSetterTranslationCommon();

        #region Deep Copy Fields From
        public void DeepCopyIn(
            IMagicEffectData item,
            IMagicEffectDataGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask)
        {
            if ((copyMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.Flags) ?? true))
            {
                item.Flags = rhs.Flags;
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.BaseCost) ?? true))
            {
                item.BaseCost = rhs.BaseCost;
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.MagicSkill) ?? true))
            {
                item.MagicSkill = rhs.MagicSkill;
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.ResistValue) ?? true))
            {
                item.ResistValue = rhs.ResistValue;
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.CounterEffectCount) ?? true))
            {
                item.CounterEffectCount = rhs.CounterEffectCount;
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.Unknown1) ?? true))
            {
                item.Unknown1 = rhs.Unknown1;
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.CastingLight) ?? true))
            {
                item.CastingLight.FormKey = rhs.CastingLight.FormKey;
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.TaperWeight) ?? true))
            {
                item.TaperWeight = rhs.TaperWeight;
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.HitShader) ?? true))
            {
                item.HitShader.FormKey = rhs.HitShader.FormKey;
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.EnchantShader) ?? true))
            {
                item.EnchantShader.FormKey = rhs.EnchantShader.FormKey;
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.MinimumSkillLevel) ?? true))
            {
                item.MinimumSkillLevel = rhs.MinimumSkillLevel;
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.SpellmakingArea) ?? true))
            {
                item.SpellmakingArea = rhs.SpellmakingArea;
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.SpellmakingCastingTime) ?? true))
            {
                item.SpellmakingCastingTime = rhs.SpellmakingCastingTime;
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.TaperCurve) ?? true))
            {
                item.TaperCurve = rhs.TaperCurve;
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.TaperDuration) ?? true))
            {
                item.TaperDuration = rhs.TaperDuration;
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.SecondActorValueWeight) ?? true))
            {
                item.SecondActorValueWeight = rhs.SecondActorValueWeight;
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.Archetype) ?? true))
            {
                errorMask?.PushIndex((int)MagicEffectData_FieldIndex.Archetype);
                try
                {
                    if ((copyMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.Archetype) ?? true))
                    {
                        item.Archetype = rhs.Archetype.DeepCopy(
                            copyMask: copyMask?.GetSubCrystal((int)MagicEffectData_FieldIndex.Archetype),
                            errorMask: errorMask);
                    }
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.Projectile) ?? true))
            {
                item.Projectile.FormKey = rhs.Projectile.FormKey;
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.Explosion) ?? true))
            {
                item.Explosion.FormKey = rhs.Explosion.FormKey;
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.CastType) ?? true))
            {
                item.CastType = rhs.CastType;
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.TargetType) ?? true))
            {
                item.TargetType = rhs.TargetType;
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.SecondActorValue) ?? true))
            {
                item.SecondActorValue = rhs.SecondActorValue;
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.CastingArt) ?? true))
            {
                item.CastingArt.FormKey = rhs.CastingArt.FormKey;
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.HitEffectArt) ?? true))
            {
                item.HitEffectArt.FormKey = rhs.HitEffectArt.FormKey;
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.ImpactData) ?? true))
            {
                item.ImpactData.FormKey = rhs.ImpactData.FormKey;
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.SkillUsageMultiplier) ?? true))
            {
                item.SkillUsageMultiplier = rhs.SkillUsageMultiplier;
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.DualCastArt) ?? true))
            {
                item.DualCastArt.FormKey = rhs.DualCastArt.FormKey;
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.DualCastScale) ?? true))
            {
                item.DualCastScale = rhs.DualCastScale;
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.EnchantArt) ?? true))
            {
                item.EnchantArt.FormKey = rhs.EnchantArt.FormKey;
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.Unknown2) ?? true))
            {
                item.Unknown2.FormKey = rhs.Unknown2.FormKey;
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.Unknown3) ?? true))
            {
                item.Unknown3.FormKey = rhs.Unknown3.FormKey;
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.EquipAbility) ?? true))
            {
                item.EquipAbility.FormKey = rhs.EquipAbility.FormKey;
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.ImageSpaceModifier) ?? true))
            {
                item.ImageSpaceModifier.FormKey = rhs.ImageSpaceModifier.FormKey;
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.PerkToApply) ?? true))
            {
                item.PerkToApply.FormKey = rhs.PerkToApply.FormKey;
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.CastingSoundLevel) ?? true))
            {
                item.CastingSoundLevel = rhs.CastingSoundLevel;
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.ScriptEffectAIScore) ?? true))
            {
                item.ScriptEffectAIScore = rhs.ScriptEffectAIScore;
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.ScriptEffectAIDelayTime) ?? true))
            {
                item.ScriptEffectAIDelayTime = rhs.ScriptEffectAIDelayTime;
            }
        }
        
        #endregion
        
        public MagicEffectData DeepCopy(
            IMagicEffectDataGetter item,
            MagicEffectData.TranslationMask? copyMask = null)
        {
            MagicEffectData ret = (MagicEffectData)((MagicEffectDataCommon)((IMagicEffectDataGetter)item).CommonInstance()!).GetNew();
            ret.DeepCopyIn(
                item,
                copyMask: copyMask);
            return ret;
        }
        
        public MagicEffectData DeepCopy(
            IMagicEffectDataGetter item,
            out MagicEffectData.ErrorMask errorMask,
            MagicEffectData.TranslationMask? copyMask = null)
        {
            MagicEffectData ret = (MagicEffectData)((MagicEffectDataCommon)((IMagicEffectDataGetter)item).CommonInstance()!).GetNew();
            ret.DeepCopyIn(
                item,
                errorMask: out errorMask,
                copyMask: copyMask);
            return ret;
        }
        
        public MagicEffectData DeepCopy(
            IMagicEffectDataGetter item,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask = null)
        {
            MagicEffectData ret = (MagicEffectData)((MagicEffectDataCommon)((IMagicEffectDataGetter)item).CommonInstance()!).GetNew();
            ret.DeepCopyIn(
                item,
                errorMask: errorMask,
                copyMask: copyMask);
            return ret;
        }
        
    }
    #endregion

}

namespace Mutagen.Bethesda.Skyrim
{
    public partial class MagicEffectData
    {
        #region Common Routing
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILoquiRegistration ILoquiObject.Registration => MagicEffectData_Registration.Instance;
        public static MagicEffectData_Registration Registration => MagicEffectData_Registration.Instance;
        [DebuggerStepThrough]
        protected object CommonInstance() => MagicEffectDataCommon.Instance;
        [DebuggerStepThrough]
        protected object CommonSetterInstance()
        {
            return MagicEffectDataSetterCommon.Instance;
        }
        [DebuggerStepThrough]
        protected object CommonSetterTranslationInstance() => MagicEffectDataSetterTranslationCommon.Instance;
        [DebuggerStepThrough]
        object IMagicEffectDataGetter.CommonInstance() => this.CommonInstance();
        [DebuggerStepThrough]
        object IMagicEffectDataGetter.CommonSetterInstance() => this.CommonSetterInstance();
        [DebuggerStepThrough]
        object IMagicEffectDataGetter.CommonSetterTranslationInstance() => this.CommonSetterTranslationInstance();

        #endregion

    }
}

#region Modules
#region Xml Translation
namespace Mutagen.Bethesda.Skyrim.Internals
{
    public partial class MagicEffectDataXmlWriteTranslation : IXmlWriteTranslator
    {
        public readonly static MagicEffectDataXmlWriteTranslation Instance = new MagicEffectDataXmlWriteTranslation();

        public static void WriteToNodeXml(
            IMagicEffectDataGetter item,
            XElement node,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask)
        {
            if ((translationMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.Flags) ?? true))
            {
                EnumXmlTranslation<MagicEffect.Flag>.Instance.Write(
                    node: node,
                    name: nameof(item.Flags),
                    item: item.Flags,
                    fieldIndex: (int)MagicEffectData_FieldIndex.Flags,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.BaseCost) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.BaseCost),
                    item: item.BaseCost,
                    fieldIndex: (int)MagicEffectData_FieldIndex.BaseCost,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.MagicSkill) ?? true))
            {
                EnumXmlTranslation<ActorValueExtended>.Instance.Write(
                    node: node,
                    name: nameof(item.MagicSkill),
                    item: item.MagicSkill,
                    fieldIndex: (int)MagicEffectData_FieldIndex.MagicSkill,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.ResistValue) ?? true))
            {
                EnumXmlTranslation<ActorValueExtended>.Instance.Write(
                    node: node,
                    name: nameof(item.ResistValue),
                    item: item.ResistValue,
                    fieldIndex: (int)MagicEffectData_FieldIndex.ResistValue,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.CounterEffectCount) ?? true))
            {
                UInt16XmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.CounterEffectCount),
                    item: item.CounterEffectCount,
                    fieldIndex: (int)MagicEffectData_FieldIndex.CounterEffectCount,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.Unknown1) ?? true))
            {
                UInt16XmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.Unknown1),
                    item: item.Unknown1,
                    fieldIndex: (int)MagicEffectData_FieldIndex.Unknown1,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.CastingLight) ?? true))
            {
                FormKeyXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.CastingLight),
                    item: item.CastingLight.FormKey,
                    fieldIndex: (int)MagicEffectData_FieldIndex.CastingLight,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.TaperWeight) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.TaperWeight),
                    item: item.TaperWeight,
                    fieldIndex: (int)MagicEffectData_FieldIndex.TaperWeight,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.HitShader) ?? true))
            {
                FormKeyXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.HitShader),
                    item: item.HitShader.FormKey,
                    fieldIndex: (int)MagicEffectData_FieldIndex.HitShader,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.EnchantShader) ?? true))
            {
                FormKeyXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.EnchantShader),
                    item: item.EnchantShader.FormKey,
                    fieldIndex: (int)MagicEffectData_FieldIndex.EnchantShader,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.MinimumSkillLevel) ?? true))
            {
                UInt32XmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.MinimumSkillLevel),
                    item: item.MinimumSkillLevel,
                    fieldIndex: (int)MagicEffectData_FieldIndex.MinimumSkillLevel,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.SpellmakingArea) ?? true))
            {
                UInt32XmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.SpellmakingArea),
                    item: item.SpellmakingArea,
                    fieldIndex: (int)MagicEffectData_FieldIndex.SpellmakingArea,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.SpellmakingCastingTime) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.SpellmakingCastingTime),
                    item: item.SpellmakingCastingTime,
                    fieldIndex: (int)MagicEffectData_FieldIndex.SpellmakingCastingTime,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.TaperCurve) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.TaperCurve),
                    item: item.TaperCurve,
                    fieldIndex: (int)MagicEffectData_FieldIndex.TaperCurve,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.TaperDuration) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.TaperDuration),
                    item: item.TaperDuration,
                    fieldIndex: (int)MagicEffectData_FieldIndex.TaperDuration,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.SecondActorValueWeight) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.SecondActorValueWeight),
                    item: item.SecondActorValueWeight,
                    fieldIndex: (int)MagicEffectData_FieldIndex.SecondActorValueWeight,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.Archetype) ?? true))
            {
                var ArchetypeItem = item.Archetype;
                ((MagicEffectArchetypeXmlWriteTranslation)((IXmlItem)ArchetypeItem).XmlWriteTranslator).Write(
                    item: ArchetypeItem,
                    node: node,
                    name: nameof(item.Archetype),
                    fieldIndex: (int)MagicEffectData_FieldIndex.Archetype,
                    errorMask: errorMask,
                    translationMask: translationMask?.GetSubCrystal((int)MagicEffectData_FieldIndex.Archetype));
            }
            if ((translationMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.Projectile) ?? true))
            {
                FormKeyXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.Projectile),
                    item: item.Projectile.FormKey,
                    fieldIndex: (int)MagicEffectData_FieldIndex.Projectile,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.Explosion) ?? true))
            {
                FormKeyXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.Explosion),
                    item: item.Explosion.FormKey,
                    fieldIndex: (int)MagicEffectData_FieldIndex.Explosion,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.CastType) ?? true))
            {
                EnumXmlTranslation<CastType>.Instance.Write(
                    node: node,
                    name: nameof(item.CastType),
                    item: item.CastType,
                    fieldIndex: (int)MagicEffectData_FieldIndex.CastType,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.TargetType) ?? true))
            {
                EnumXmlTranslation<TargetType>.Instance.Write(
                    node: node,
                    name: nameof(item.TargetType),
                    item: item.TargetType,
                    fieldIndex: (int)MagicEffectData_FieldIndex.TargetType,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.SecondActorValue) ?? true))
            {
                EnumXmlTranslation<ActorValueExtended>.Instance.Write(
                    node: node,
                    name: nameof(item.SecondActorValue),
                    item: item.SecondActorValue,
                    fieldIndex: (int)MagicEffectData_FieldIndex.SecondActorValue,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.CastingArt) ?? true))
            {
                FormKeyXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.CastingArt),
                    item: item.CastingArt.FormKey,
                    fieldIndex: (int)MagicEffectData_FieldIndex.CastingArt,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.HitEffectArt) ?? true))
            {
                FormKeyXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.HitEffectArt),
                    item: item.HitEffectArt.FormKey,
                    fieldIndex: (int)MagicEffectData_FieldIndex.HitEffectArt,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.ImpactData) ?? true))
            {
                FormKeyXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.ImpactData),
                    item: item.ImpactData.FormKey,
                    fieldIndex: (int)MagicEffectData_FieldIndex.ImpactData,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.SkillUsageMultiplier) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.SkillUsageMultiplier),
                    item: item.SkillUsageMultiplier,
                    fieldIndex: (int)MagicEffectData_FieldIndex.SkillUsageMultiplier,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.DualCastArt) ?? true))
            {
                FormKeyXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.DualCastArt),
                    item: item.DualCastArt.FormKey,
                    fieldIndex: (int)MagicEffectData_FieldIndex.DualCastArt,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.DualCastScale) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.DualCastScale),
                    item: item.DualCastScale,
                    fieldIndex: (int)MagicEffectData_FieldIndex.DualCastScale,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.EnchantArt) ?? true))
            {
                FormKeyXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.EnchantArt),
                    item: item.EnchantArt.FormKey,
                    fieldIndex: (int)MagicEffectData_FieldIndex.EnchantArt,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.Unknown2) ?? true))
            {
                FormKeyXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.Unknown2),
                    item: item.Unknown2.FormKey,
                    fieldIndex: (int)MagicEffectData_FieldIndex.Unknown2,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.Unknown3) ?? true))
            {
                FormKeyXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.Unknown3),
                    item: item.Unknown3.FormKey,
                    fieldIndex: (int)MagicEffectData_FieldIndex.Unknown3,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.EquipAbility) ?? true))
            {
                FormKeyXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.EquipAbility),
                    item: item.EquipAbility.FormKey,
                    fieldIndex: (int)MagicEffectData_FieldIndex.EquipAbility,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.ImageSpaceModifier) ?? true))
            {
                FormKeyXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.ImageSpaceModifier),
                    item: item.ImageSpaceModifier.FormKey,
                    fieldIndex: (int)MagicEffectData_FieldIndex.ImageSpaceModifier,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.PerkToApply) ?? true))
            {
                FormKeyXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.PerkToApply),
                    item: item.PerkToApply.FormKey,
                    fieldIndex: (int)MagicEffectData_FieldIndex.PerkToApply,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.CastingSoundLevel) ?? true))
            {
                EnumXmlTranslation<SoundLevel>.Instance.Write(
                    node: node,
                    name: nameof(item.CastingSoundLevel),
                    item: item.CastingSoundLevel,
                    fieldIndex: (int)MagicEffectData_FieldIndex.CastingSoundLevel,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.ScriptEffectAIScore) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.ScriptEffectAIScore),
                    item: item.ScriptEffectAIScore,
                    fieldIndex: (int)MagicEffectData_FieldIndex.ScriptEffectAIScore,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.ScriptEffectAIDelayTime) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.ScriptEffectAIDelayTime),
                    item: item.ScriptEffectAIDelayTime,
                    fieldIndex: (int)MagicEffectData_FieldIndex.ScriptEffectAIDelayTime,
                    errorMask: errorMask);
            }
        }

        public void Write(
            XElement node,
            IMagicEffectDataGetter item,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask,
            string? name = null)
        {
            var elem = new XElement(name ?? "Mutagen.Bethesda.Skyrim.MagicEffectData");
            node.Add(elem);
            if (name != null)
            {
                elem.SetAttributeValue("type", "Mutagen.Bethesda.Skyrim.MagicEffectData");
            }
            WriteToNodeXml(
                item: item,
                node: elem,
                errorMask: errorMask,
                translationMask: translationMask);
        }

        public void Write(
            XElement node,
            object item,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask,
            string? name = null)
        {
            Write(
                item: (IMagicEffectDataGetter)item,
                name: name,
                node: node,
                errorMask: errorMask,
                translationMask: translationMask);
        }

        public void Write(
            XElement node,
            IMagicEffectDataGetter item,
            ErrorMaskBuilder? errorMask,
            int fieldIndex,
            TranslationCrystal? translationMask,
            string? name = null)
        {
            errorMask?.PushIndex(fieldIndex);
            try
            {
                Write(
                    item: (IMagicEffectDataGetter)item,
                    name: name,
                    node: node,
                    errorMask: errorMask,
                    translationMask: translationMask);
            }
            catch (Exception ex)
            when (errorMask != null)
            {
                errorMask.ReportException(ex);
            }
            finally
            {
                errorMask?.PopIndex();
            }
        }

    }

    public partial class MagicEffectDataXmlCreateTranslation
    {
        public readonly static MagicEffectDataXmlCreateTranslation Instance = new MagicEffectDataXmlCreateTranslation();

        public static void FillPublicXml(
            IMagicEffectData item,
            XElement node,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask)
        {
            try
            {
                foreach (var elem in node.Elements())
                {
                    MagicEffectDataXmlCreateTranslation.FillPublicElementXml(
                        item: item,
                        node: elem,
                        name: elem.Name.LocalName,
                        errorMask: errorMask,
                        translationMask: translationMask);
                }
            }
            catch (Exception ex)
            when (errorMask != null)
            {
                errorMask.ReportException(ex);
            }
        }

        public static void FillPublicElementXml(
            IMagicEffectData item,
            XElement node,
            string name,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask)
        {
            switch (name)
            {
                case "Flags":
                    errorMask?.PushIndex((int)MagicEffectData_FieldIndex.Flags);
                    try
                    {
                        item.Flags = EnumXmlTranslation<MagicEffect.Flag>.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "BaseCost":
                    errorMask?.PushIndex((int)MagicEffectData_FieldIndex.BaseCost);
                    try
                    {
                        item.BaseCost = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "MagicSkill":
                    errorMask?.PushIndex((int)MagicEffectData_FieldIndex.MagicSkill);
                    try
                    {
                        item.MagicSkill = EnumXmlTranslation<ActorValueExtended>.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "ResistValue":
                    errorMask?.PushIndex((int)MagicEffectData_FieldIndex.ResistValue);
                    try
                    {
                        item.ResistValue = EnumXmlTranslation<ActorValueExtended>.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "CounterEffectCount":
                    errorMask?.PushIndex((int)MagicEffectData_FieldIndex.CounterEffectCount);
                    try
                    {
                        item.CounterEffectCount = UInt16XmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "Unknown1":
                    errorMask?.PushIndex((int)MagicEffectData_FieldIndex.Unknown1);
                    try
                    {
                        item.Unknown1 = UInt16XmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "CastingLight":
                    errorMask?.PushIndex((int)MagicEffectData_FieldIndex.CastingLight);
                    try
                    {
                        item.CastingLight.FormKey = FormKeyXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "TaperWeight":
                    errorMask?.PushIndex((int)MagicEffectData_FieldIndex.TaperWeight);
                    try
                    {
                        item.TaperWeight = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "HitShader":
                    errorMask?.PushIndex((int)MagicEffectData_FieldIndex.HitShader);
                    try
                    {
                        item.HitShader.FormKey = FormKeyXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "EnchantShader":
                    errorMask?.PushIndex((int)MagicEffectData_FieldIndex.EnchantShader);
                    try
                    {
                        item.EnchantShader.FormKey = FormKeyXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "MinimumSkillLevel":
                    errorMask?.PushIndex((int)MagicEffectData_FieldIndex.MinimumSkillLevel);
                    try
                    {
                        item.MinimumSkillLevel = UInt32XmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "SpellmakingArea":
                    errorMask?.PushIndex((int)MagicEffectData_FieldIndex.SpellmakingArea);
                    try
                    {
                        item.SpellmakingArea = UInt32XmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "SpellmakingCastingTime":
                    errorMask?.PushIndex((int)MagicEffectData_FieldIndex.SpellmakingCastingTime);
                    try
                    {
                        item.SpellmakingCastingTime = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "TaperCurve":
                    errorMask?.PushIndex((int)MagicEffectData_FieldIndex.TaperCurve);
                    try
                    {
                        item.TaperCurve = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "TaperDuration":
                    errorMask?.PushIndex((int)MagicEffectData_FieldIndex.TaperDuration);
                    try
                    {
                        item.TaperDuration = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "SecondActorValueWeight":
                    errorMask?.PushIndex((int)MagicEffectData_FieldIndex.SecondActorValueWeight);
                    try
                    {
                        item.SecondActorValueWeight = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "Archetype":
                    errorMask?.PushIndex((int)MagicEffectData_FieldIndex.Archetype);
                    try
                    {
                        item.Archetype = LoquiXmlTranslation<MagicEffectArchetype>.Instance.Parse(
                            node: node,
                            errorMask: errorMask,
                            translationMask: translationMask?.GetSubCrystal((int)MagicEffectData_FieldIndex.Archetype));
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "Projectile":
                    errorMask?.PushIndex((int)MagicEffectData_FieldIndex.Projectile);
                    try
                    {
                        item.Projectile.FormKey = FormKeyXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "Explosion":
                    errorMask?.PushIndex((int)MagicEffectData_FieldIndex.Explosion);
                    try
                    {
                        item.Explosion.FormKey = FormKeyXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "CastType":
                    errorMask?.PushIndex((int)MagicEffectData_FieldIndex.CastType);
                    try
                    {
                        item.CastType = EnumXmlTranslation<CastType>.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "TargetType":
                    errorMask?.PushIndex((int)MagicEffectData_FieldIndex.TargetType);
                    try
                    {
                        item.TargetType = EnumXmlTranslation<TargetType>.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "SecondActorValue":
                    errorMask?.PushIndex((int)MagicEffectData_FieldIndex.SecondActorValue);
                    try
                    {
                        item.SecondActorValue = EnumXmlTranslation<ActorValueExtended>.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "CastingArt":
                    errorMask?.PushIndex((int)MagicEffectData_FieldIndex.CastingArt);
                    try
                    {
                        item.CastingArt.FormKey = FormKeyXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "HitEffectArt":
                    errorMask?.PushIndex((int)MagicEffectData_FieldIndex.HitEffectArt);
                    try
                    {
                        item.HitEffectArt.FormKey = FormKeyXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "ImpactData":
                    errorMask?.PushIndex((int)MagicEffectData_FieldIndex.ImpactData);
                    try
                    {
                        item.ImpactData.FormKey = FormKeyXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "SkillUsageMultiplier":
                    errorMask?.PushIndex((int)MagicEffectData_FieldIndex.SkillUsageMultiplier);
                    try
                    {
                        item.SkillUsageMultiplier = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "DualCastArt":
                    errorMask?.PushIndex((int)MagicEffectData_FieldIndex.DualCastArt);
                    try
                    {
                        item.DualCastArt.FormKey = FormKeyXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "DualCastScale":
                    errorMask?.PushIndex((int)MagicEffectData_FieldIndex.DualCastScale);
                    try
                    {
                        item.DualCastScale = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "EnchantArt":
                    errorMask?.PushIndex((int)MagicEffectData_FieldIndex.EnchantArt);
                    try
                    {
                        item.EnchantArt.FormKey = FormKeyXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "Unknown2":
                    errorMask?.PushIndex((int)MagicEffectData_FieldIndex.Unknown2);
                    try
                    {
                        item.Unknown2.FormKey = FormKeyXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "Unknown3":
                    errorMask?.PushIndex((int)MagicEffectData_FieldIndex.Unknown3);
                    try
                    {
                        item.Unknown3.FormKey = FormKeyXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "EquipAbility":
                    errorMask?.PushIndex((int)MagicEffectData_FieldIndex.EquipAbility);
                    try
                    {
                        item.EquipAbility.FormKey = FormKeyXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "ImageSpaceModifier":
                    errorMask?.PushIndex((int)MagicEffectData_FieldIndex.ImageSpaceModifier);
                    try
                    {
                        item.ImageSpaceModifier.FormKey = FormKeyXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "PerkToApply":
                    errorMask?.PushIndex((int)MagicEffectData_FieldIndex.PerkToApply);
                    try
                    {
                        item.PerkToApply.FormKey = FormKeyXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "CastingSoundLevel":
                    errorMask?.PushIndex((int)MagicEffectData_FieldIndex.CastingSoundLevel);
                    try
                    {
                        item.CastingSoundLevel = EnumXmlTranslation<SoundLevel>.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "ScriptEffectAIScore":
                    errorMask?.PushIndex((int)MagicEffectData_FieldIndex.ScriptEffectAIScore);
                    try
                    {
                        item.ScriptEffectAIScore = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "ScriptEffectAIDelayTime":
                    errorMask?.PushIndex((int)MagicEffectData_FieldIndex.ScriptEffectAIDelayTime);
                    try
                    {
                        item.ScriptEffectAIDelayTime = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                default:
                    break;
            }
        }

    }

}
namespace Mutagen.Bethesda.Skyrim
{
    #region Xml Write Mixins
    public static class MagicEffectDataXmlTranslationMixIn
    {
        public static void WriteToXml(
            this IMagicEffectDataGetter item,
            XElement node,
            out MagicEffectData.ErrorMask errorMask,
            MagicEffectData.TranslationMask? translationMask = null,
            string? name = null)
        {
            ErrorMaskBuilder errorMaskBuilder = new ErrorMaskBuilder();
            ((MagicEffectDataXmlWriteTranslation)item.XmlWriteTranslator).Write(
                item: item,
                name: name,
                node: node,
                errorMask: errorMaskBuilder,
                translationMask: translationMask?.GetCrystal());
            errorMask = MagicEffectData.ErrorMask.Factory(errorMaskBuilder);
        }

        public static void WriteToXml(
            this IMagicEffectDataGetter item,
            string path,
            out MagicEffectData.ErrorMask errorMask,
            MagicEffectData.TranslationMask? translationMask = null,
            string? name = null)
        {
            var node = new XElement("topnode");
            WriteToXml(
                item: item,
                name: name,
                node: node,
                errorMask: out errorMask,
                translationMask: translationMask);
            node.Elements().First().SaveIfChanged(path);
        }

        public static void WriteToXml(
            this IMagicEffectDataGetter item,
            string path,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask = null,
            string? name = null)
        {
            var node = new XElement("topnode");
            WriteToXml(
                item: item,
                name: name,
                node: node,
                errorMask: errorMask,
                translationMask: translationMask);
            node.Elements().First().SaveIfChanged(path);
        }

        public static void WriteToXml(
            this IMagicEffectDataGetter item,
            Stream stream,
            out MagicEffectData.ErrorMask errorMask,
            MagicEffectData.TranslationMask? translationMask = null,
            string? name = null)
        {
            var node = new XElement("topnode");
            WriteToXml(
                item: item,
                name: name,
                node: node,
                errorMask: out errorMask,
                translationMask: translationMask);
            node.Elements().First().Save(stream);
        }

        public static void WriteToXml(
            this IMagicEffectDataGetter item,
            Stream stream,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask = null,
            string? name = null)
        {
            var node = new XElement("topnode");
            WriteToXml(
                item: item,
                name: name,
                node: node,
                errorMask: errorMask,
                translationMask: translationMask);
            node.Elements().First().Save(stream);
        }

        public static void WriteToXml(
            this IMagicEffectDataGetter item,
            XElement node,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask = null,
            string? name = null)
        {
            ((MagicEffectDataXmlWriteTranslation)item.XmlWriteTranslator).Write(
                item: item,
                name: name,
                node: node,
                errorMask: errorMask,
                translationMask: translationMask);
        }

        public static void WriteToXml(
            this IMagicEffectDataGetter item,
            XElement node,
            string? name = null,
            MagicEffectData.TranslationMask? translationMask = null)
        {
            ((MagicEffectDataXmlWriteTranslation)item.XmlWriteTranslator).Write(
                item: item,
                name: name,
                node: node,
                errorMask: null,
                translationMask: translationMask?.GetCrystal());
        }

        public static void WriteToXml(
            this IMagicEffectDataGetter item,
            string path,
            string? name = null)
        {
            var node = new XElement("topnode");
            ((MagicEffectDataXmlWriteTranslation)item.XmlWriteTranslator).Write(
                item: item,
                name: name,
                node: node,
                errorMask: null,
                translationMask: null);
            node.Elements().First().SaveIfChanged(path);
        }

        public static void WriteToXml(
            this IMagicEffectDataGetter item,
            Stream stream,
            string? name = null)
        {
            var node = new XElement("topnode");
            ((MagicEffectDataXmlWriteTranslation)item.XmlWriteTranslator).Write(
                item: item,
                name: name,
                node: node,
                errorMask: null,
                translationMask: null);
            node.Elements().First().Save(stream);
        }

    }
    #endregion


}
#endregion

#region Binary Translation
namespace Mutagen.Bethesda.Skyrim.Internals
{
    public partial class MagicEffectDataBinaryWriteTranslation : IBinaryWriteTranslator
    {
        public readonly static MagicEffectDataBinaryWriteTranslation Instance = new MagicEffectDataBinaryWriteTranslation();

        static partial void WriteBinaryAssociatedItemCustom(
            MutagenWriter writer,
            IMagicEffectDataGetter item);

        public static void WriteBinaryAssociatedItem(
            MutagenWriter writer,
            IMagicEffectDataGetter item)
        {
            WriteBinaryAssociatedItemCustom(
                writer: writer,
                item: item);
        }

        static partial void WriteBinaryArchetypeCustom(
            MutagenWriter writer,
            IMagicEffectDataGetter item);

        public static void WriteBinaryArchetype(
            MutagenWriter writer,
            IMagicEffectDataGetter item)
        {
            WriteBinaryArchetypeCustom(
                writer: writer,
                item: item);
        }

        public static void WriteEmbedded(
            IMagicEffectDataGetter item,
            MutagenWriter writer)
        {
            Mutagen.Bethesda.Binary.EnumBinaryTranslation<MagicEffect.Flag>.Instance.Write(
                writer,
                item.Flags,
                length: 4);
            Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.BaseCost);
            MagicEffectDataBinaryWriteTranslation.WriteBinaryAssociatedItem(
                writer: writer,
                item: item);
            Mutagen.Bethesda.Binary.EnumBinaryTranslation<ActorValueExtended>.Instance.Write(
                writer,
                item.MagicSkill,
                length: 4);
            Mutagen.Bethesda.Binary.EnumBinaryTranslation<ActorValueExtended>.Instance.Write(
                writer,
                item.ResistValue,
                length: 4);
            writer.Write(item.CounterEffectCount);
            writer.Write(item.Unknown1);
            Mutagen.Bethesda.Binary.FormLinkBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.CastingLight);
            Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.TaperWeight);
            Mutagen.Bethesda.Binary.FormLinkBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.HitShader);
            Mutagen.Bethesda.Binary.FormLinkBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.EnchantShader);
            writer.Write(item.MinimumSkillLevel);
            writer.Write(item.SpellmakingArea);
            Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.SpellmakingCastingTime);
            Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.TaperCurve);
            Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.TaperDuration);
            Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.SecondActorValueWeight);
            MagicEffectDataBinaryWriteTranslation.WriteBinaryArchetype(
                writer: writer,
                item: item);
            Mutagen.Bethesda.Binary.FormLinkBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.Projectile);
            Mutagen.Bethesda.Binary.FormLinkBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.Explosion);
            Mutagen.Bethesda.Binary.EnumBinaryTranslation<CastType>.Instance.Write(
                writer,
                item.CastType,
                length: 4);
            Mutagen.Bethesda.Binary.EnumBinaryTranslation<TargetType>.Instance.Write(
                writer,
                item.TargetType,
                length: 4);
            Mutagen.Bethesda.Binary.EnumBinaryTranslation<ActorValueExtended>.Instance.Write(
                writer,
                item.SecondActorValue,
                length: 4);
            Mutagen.Bethesda.Binary.FormLinkBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.CastingArt);
            Mutagen.Bethesda.Binary.FormLinkBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.HitEffectArt);
            Mutagen.Bethesda.Binary.FormLinkBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.ImpactData);
            Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.SkillUsageMultiplier);
            Mutagen.Bethesda.Binary.FormLinkBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.DualCastArt);
            Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.DualCastScale);
            Mutagen.Bethesda.Binary.FormLinkBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.EnchantArt);
            Mutagen.Bethesda.Binary.FormLinkBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.Unknown2);
            Mutagen.Bethesda.Binary.FormLinkBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.Unknown3);
            Mutagen.Bethesda.Binary.FormLinkBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.EquipAbility);
            Mutagen.Bethesda.Binary.FormLinkBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.ImageSpaceModifier);
            Mutagen.Bethesda.Binary.FormLinkBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.PerkToApply);
            Mutagen.Bethesda.Binary.EnumBinaryTranslation<SoundLevel>.Instance.Write(
                writer,
                item.CastingSoundLevel,
                length: 4);
            Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.ScriptEffectAIScore);
            Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.ScriptEffectAIDelayTime);
        }

        public void Write(
            MutagenWriter writer,
            IMagicEffectDataGetter item,
            RecordTypeConverter? recordTypeConverter = null)
        {
            using (HeaderExport.ExportHeader(
                writer: writer,
                record: recordTypeConverter.ConvertToCustom(MagicEffectData_Registration.DATA_HEADER),
                type: ObjectType.Subrecord))
            {
                WriteEmbedded(
                    item: item,
                    writer: writer);
            }
        }

        public void Write(
            MutagenWriter writer,
            object item,
            RecordTypeConverter? recordTypeConverter = null)
        {
            Write(
                item: (IMagicEffectDataGetter)item,
                writer: writer,
                recordTypeConverter: recordTypeConverter);
        }

    }

    public partial class MagicEffectDataBinaryCreateTranslation
    {
        public readonly static MagicEffectDataBinaryCreateTranslation Instance = new MagicEffectDataBinaryCreateTranslation();

        static partial void FillBinaryAssociatedItemCustom(
            MutagenFrame frame,
            IMagicEffectData item);

        public static void FillBinaryAssociatedItemCustomPublic(
            MutagenFrame frame,
            IMagicEffectData item)
        {
            FillBinaryAssociatedItemCustom(
                frame: frame,
                item: item);
        }

        static partial void FillBinaryArchetypeCustom(
            MutagenFrame frame,
            IMagicEffectData item);

        public static void FillBinaryArchetypeCustomPublic(
            MutagenFrame frame,
            IMagicEffectData item)
        {
            FillBinaryArchetypeCustom(
                frame: frame,
                item: item);
        }

    }

}
namespace Mutagen.Bethesda.Skyrim
{
    #region Binary Write Mixins
    public static class MagicEffectDataBinaryTranslationMixIn
    {
        public static void WriteToBinary(
            this IMagicEffectDataGetter item,
            MutagenWriter writer)
        {
            ((MagicEffectDataBinaryWriteTranslation)item.BinaryWriteTranslator).Write(
                item: item,
                writer: writer,
                recordTypeConverter: null);
        }

    }
    #endregion


}
namespace Mutagen.Bethesda.Skyrim.Internals
{
    public partial class MagicEffectDataBinaryOverlay :
        BinaryOverlay,
        IMagicEffectDataGetter
    {
        #region Common Routing
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILoquiRegistration ILoquiObject.Registration => MagicEffectData_Registration.Instance;
        public static MagicEffectData_Registration Registration => MagicEffectData_Registration.Instance;
        [DebuggerStepThrough]
        protected object CommonInstance() => MagicEffectDataCommon.Instance;
        [DebuggerStepThrough]
        protected object CommonSetterTranslationInstance() => MagicEffectDataSetterTranslationCommon.Instance;
        [DebuggerStepThrough]
        object IMagicEffectDataGetter.CommonInstance() => this.CommonInstance();
        [DebuggerStepThrough]
        object? IMagicEffectDataGetter.CommonSetterInstance() => null;
        [DebuggerStepThrough]
        object IMagicEffectDataGetter.CommonSetterTranslationInstance() => this.CommonSetterTranslationInstance();

        #endregion

        void IPrintable.ToString(FileGeneration fg, string? name) => this.ToString(fg, name);
        IMask<bool> ILoquiObjectGetter.GetHasBeenSetIMask() => this.GetHasBeenSetMask();
        IMask<bool> IEqualsMask.GetEqualsIMask(object rhs, EqualsMaskHelper.Include include) => this.GetEqualsMask((IMagicEffectDataGetter)rhs, include);

        public IEnumerable<ILinkGetter> Links => MagicEffectDataCommon.Instance.GetLinks(this);
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected object XmlWriteTranslator => MagicEffectDataXmlWriteTranslation.Instance;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        object IXmlItem.XmlWriteTranslator => this.XmlWriteTranslator;
        void IXmlItem.WriteToXml(
            XElement node,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask,
            string? name = null)
        {
            ((MagicEffectDataXmlWriteTranslation)this.XmlWriteTranslator).Write(
                item: this,
                name: name,
                node: node,
                errorMask: errorMask,
                translationMask: translationMask);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected object BinaryWriteTranslator => MagicEffectDataBinaryWriteTranslation.Instance;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        object IBinaryItem.BinaryWriteTranslator => this.BinaryWriteTranslator;
        void IBinaryItem.WriteToBinary(
            MutagenWriter writer,
            RecordTypeConverter? recordTypeConverter = null)
        {
            ((MagicEffectDataBinaryWriteTranslation)this.BinaryWriteTranslator).Write(
                item: this,
                writer: writer,
                recordTypeConverter: recordTypeConverter);
        }

        public MagicEffect.Flag Flags => (MagicEffect.Flag)BinaryPrimitives.ReadInt32LittleEndian(_data.Span.Slice(0x0, 0x4));
        public Single BaseCost => SpanExt.GetFloat(_data.Slice(0x4, 0x4));
        #region AssociatedItem
        partial void AssociatedItemCustomParse(
            BinaryMemoryReadStream stream,
            int offset);
        #endregion
        public ActorValueExtended MagicSkill => (ActorValueExtended)BinaryPrimitives.ReadInt32LittleEndian(_data.Span.Slice(0xC, 0x4));
        public ActorValueExtended ResistValue => (ActorValueExtended)BinaryPrimitives.ReadInt32LittleEndian(_data.Span.Slice(0x10, 0x4));
        public UInt16 CounterEffectCount => BinaryPrimitives.ReadUInt16LittleEndian(_data.Slice(0x14, 0x2));
        public UInt16 Unknown1 => BinaryPrimitives.ReadUInt16LittleEndian(_data.Slice(0x16, 0x2));
        public IFormLinkGetter<ILightGetter> CastingLight => new FormLink<ILightGetter>(FormKey.Factory(_package.MasterReferences!, BinaryPrimitives.ReadUInt32LittleEndian(_data.Span.Slice(0x18, 0x4))));
        public Single TaperWeight => SpanExt.GetFloat(_data.Slice(0x1C, 0x4));
        public IFormLinkGetter<IEffectShaderGetter> HitShader => new FormLink<IEffectShaderGetter>(FormKey.Factory(_package.MasterReferences!, BinaryPrimitives.ReadUInt32LittleEndian(_data.Span.Slice(0x20, 0x4))));
        public IFormLinkGetter<IEffectShaderGetter> EnchantShader => new FormLink<IEffectShaderGetter>(FormKey.Factory(_package.MasterReferences!, BinaryPrimitives.ReadUInt32LittleEndian(_data.Span.Slice(0x24, 0x4))));
        public UInt32 MinimumSkillLevel => BinaryPrimitives.ReadUInt32LittleEndian(_data.Slice(0x28, 0x4));
        public UInt32 SpellmakingArea => BinaryPrimitives.ReadUInt32LittleEndian(_data.Slice(0x2C, 0x4));
        public Single SpellmakingCastingTime => SpanExt.GetFloat(_data.Slice(0x30, 0x4));
        public Single TaperCurve => SpanExt.GetFloat(_data.Slice(0x34, 0x4));
        public Single TaperDuration => SpanExt.GetFloat(_data.Slice(0x38, 0x4));
        public Single SecondActorValueWeight => SpanExt.GetFloat(_data.Slice(0x3C, 0x4));
        public IMagicEffectArchetypeGetter Archetype => GetArchetypeCustom(location: 0x40);
        public IFormLinkGetter<IProjectileGetter> Projectile => new FormLink<IProjectileGetter>(FormKey.Factory(_package.MasterReferences!, BinaryPrimitives.ReadUInt32LittleEndian(_data.Span.Slice(0x48, 0x4))));
        public IFormLinkGetter<IExplosionGetter> Explosion => new FormLink<IExplosionGetter>(FormKey.Factory(_package.MasterReferences!, BinaryPrimitives.ReadUInt32LittleEndian(_data.Span.Slice(0x4C, 0x4))));
        public CastType CastType => (CastType)BinaryPrimitives.ReadInt32LittleEndian(_data.Span.Slice(0x50, 0x4));
        public TargetType TargetType => (TargetType)BinaryPrimitives.ReadInt32LittleEndian(_data.Span.Slice(0x54, 0x4));
        public ActorValueExtended SecondActorValue => (ActorValueExtended)BinaryPrimitives.ReadInt32LittleEndian(_data.Span.Slice(0x58, 0x4));
        public IFormLinkGetter<IArtObjectGetter> CastingArt => new FormLink<IArtObjectGetter>(FormKey.Factory(_package.MasterReferences!, BinaryPrimitives.ReadUInt32LittleEndian(_data.Span.Slice(0x5C, 0x4))));
        public IFormLinkGetter<IArtObjectGetter> HitEffectArt => new FormLink<IArtObjectGetter>(FormKey.Factory(_package.MasterReferences!, BinaryPrimitives.ReadUInt32LittleEndian(_data.Span.Slice(0x60, 0x4))));
        public IFormLinkGetter<IImpactDataSetGetter> ImpactData => new FormLink<IImpactDataSetGetter>(FormKey.Factory(_package.MasterReferences!, BinaryPrimitives.ReadUInt32LittleEndian(_data.Span.Slice(0x64, 0x4))));
        public Single SkillUsageMultiplier => SpanExt.GetFloat(_data.Slice(0x68, 0x4));
        public IFormLinkGetter<IDualCastDataGetter> DualCastArt => new FormLink<IDualCastDataGetter>(FormKey.Factory(_package.MasterReferences!, BinaryPrimitives.ReadUInt32LittleEndian(_data.Span.Slice(0x6C, 0x4))));
        public Single DualCastScale => SpanExt.GetFloat(_data.Slice(0x70, 0x4));
        public IFormLinkGetter<IArtObjectGetter> EnchantArt => new FormLink<IArtObjectGetter>(FormKey.Factory(_package.MasterReferences!, BinaryPrimitives.ReadUInt32LittleEndian(_data.Span.Slice(0x74, 0x4))));
        public IFormLinkGetter<ISkyrimMajorRecordGetter> Unknown2 => new FormLink<ISkyrimMajorRecordGetter>(FormKey.Factory(_package.MasterReferences!, BinaryPrimitives.ReadUInt32LittleEndian(_data.Span.Slice(0x78, 0x4))));
        public IFormLinkGetter<ISkyrimMajorRecordGetter> Unknown3 => new FormLink<ISkyrimMajorRecordGetter>(FormKey.Factory(_package.MasterReferences!, BinaryPrimitives.ReadUInt32LittleEndian(_data.Span.Slice(0x7C, 0x4))));
        public IFormLinkGetter<ISpellGetter> EquipAbility => new FormLink<ISpellGetter>(FormKey.Factory(_package.MasterReferences!, BinaryPrimitives.ReadUInt32LittleEndian(_data.Span.Slice(0x80, 0x4))));
        public IFormLinkGetter<IImageSpaceAdapterGetter> ImageSpaceModifier => new FormLink<IImageSpaceAdapterGetter>(FormKey.Factory(_package.MasterReferences!, BinaryPrimitives.ReadUInt32LittleEndian(_data.Span.Slice(0x84, 0x4))));
        public IFormLinkGetter<IPerkGetter> PerkToApply => new FormLink<IPerkGetter>(FormKey.Factory(_package.MasterReferences!, BinaryPrimitives.ReadUInt32LittleEndian(_data.Span.Slice(0x88, 0x4))));
        public SoundLevel CastingSoundLevel => (SoundLevel)BinaryPrimitives.ReadInt32LittleEndian(_data.Span.Slice(0x8C, 0x4));
        public Single ScriptEffectAIScore => SpanExt.GetFloat(_data.Slice(0x90, 0x4));
        public Single ScriptEffectAIDelayTime => SpanExt.GetFloat(_data.Slice(0x94, 0x4));
        partial void CustomCtor(
            IBinaryReadStream stream,
            int finalPos,
            int offset);

        protected MagicEffectDataBinaryOverlay(
            ReadOnlyMemorySlice<byte> bytes,
            BinaryOverlayFactoryPackage package)
            : base(
                bytes: bytes,
                package: package)
        {
        }

        public static MagicEffectDataBinaryOverlay MagicEffectDataFactory(
            BinaryMemoryReadStream stream,
            BinaryOverlayFactoryPackage package,
            RecordTypeConverter? recordTypeConverter = null)
        {
            var ret = new MagicEffectDataBinaryOverlay(
                bytes: HeaderTranslation.ExtractSubrecordMemory(stream.RemainingMemory, package.Meta),
                package: package);
            var finalPos = checked((int)(stream.Position + package.Meta.Subrecord(stream.RemainingSpan).TotalLength));
            int offset = stream.Position + package.Meta.SubConstants.TypeAndLengthLength;
            stream.Position += 0x9C + package.Meta.SubConstants.HeaderLength;
            ret.CustomCtor(
                stream: stream,
                finalPos: stream.Length,
                offset: offset);
            return ret;
        }

        public static MagicEffectDataBinaryOverlay MagicEffectDataFactory(
            ReadOnlyMemorySlice<byte> slice,
            BinaryOverlayFactoryPackage package,
            RecordTypeConverter? recordTypeConverter = null)
        {
            return MagicEffectDataFactory(
                stream: new BinaryMemoryReadStream(slice),
                package: package,
                recordTypeConverter: recordTypeConverter);
        }

        #region To String

        public void ToString(
            FileGeneration fg,
            string? name = null)
        {
            MagicEffectDataMixIn.ToString(
                item: this,
                name: name);
        }

        #endregion

    }

}
#endregion

#endregion

