/*
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
 * Autogenerated by Loqui.  Do not manually change.
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
*/
#region Usings
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Loqui;
using Loqui.Internal;
using Noggog;
using Mutagen.Bethesda.Skyrim.Internals;
using System.Reactive.Disposables;
using System.Reactive.Linq;
using System.Xml;
using System.Xml.Linq;
using System.IO;
using Noggog.Xml;
using Loqui.Xml;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using Mutagen.Bethesda.Binary;
using System.Buffers.Binary;
using Mutagen.Bethesda.Internals;
#endregion

#nullable enable
namespace Mutagen.Bethesda.Skyrim
{
    #region Class
    public partial class Phoneme :
        IPhoneme,
        ILoquiObjectSetter<Phoneme>,
        IEquatable<Phoneme>,
        IEqualsMask
    {
        #region Ctor
        public Phoneme()
        {
            CustomCtor();
        }
        partial void CustomCtor();
        #endregion

        #region IY
        public Single IY { get; set; } = default;
        #endregion
        #region IH
        public Single IH { get; set; } = default;
        #endregion
        #region EH
        public Single EH { get; set; } = default;
        #endregion
        #region EY
        public Single EY { get; set; } = default;
        #endregion
        #region AE
        public Single AE { get; set; } = default;
        #endregion
        #region AA
        public Single AA { get; set; } = default;
        #endregion
        #region AW
        public Single AW { get; set; } = default;
        #endregion
        #region AY
        public Single AY { get; set; } = default;
        #endregion
        #region AH
        public Single AH { get; set; } = default;
        #endregion
        #region AO
        public Single AO { get; set; } = default;
        #endregion
        #region OY
        public Single OY { get; set; } = default;
        #endregion
        #region OW
        public Single OW { get; set; } = default;
        #endregion
        #region UH
        public Single UH { get; set; } = default;
        #endregion
        #region UW
        public Single UW { get; set; } = default;
        #endregion
        #region ER
        public Single ER { get; set; } = default;
        #endregion
        #region AX
        public Single AX { get; set; } = default;
        #endregion
        #region S
        public Single S { get; set; } = default;
        #endregion
        #region SH
        public Single SH { get; set; } = default;
        #endregion
        #region Z
        public Single Z { get; set; } = default;
        #endregion
        #region ZH
        public Single ZH { get; set; } = default;
        #endregion
        #region F
        public Single F { get; set; } = default;
        #endregion
        #region TH
        public Single TH { get; set; } = default;
        #endregion
        #region V
        public Single V { get; set; } = default;
        #endregion
        #region DH
        public Single DH { get; set; } = default;
        #endregion
        #region M
        public Single M { get; set; } = default;
        #endregion
        #region N
        public Single N { get; set; } = default;
        #endregion
        #region NG
        public Single NG { get; set; } = default;
        #endregion
        #region L
        public Single L { get; set; } = default;
        #endregion
        #region R
        public Single R { get; set; } = default;
        #endregion
        #region W
        public Single W { get; set; } = default;
        #endregion
        #region Y
        public Single Y { get; set; } = default;
        #endregion
        #region HH
        public Single HH { get; set; } = default;
        #endregion
        #region B
        public Single B { get; set; } = default;
        #endregion
        #region D
        public Single D { get; set; } = default;
        #endregion
        #region JH
        public Single JH { get; set; } = default;
        #endregion
        #region G
        public Single G { get; set; } = default;
        #endregion
        #region P
        public Single P { get; set; } = default;
        #endregion
        #region T
        public Single T { get; set; } = default;
        #endregion
        #region K
        public Single K { get; set; } = default;
        #endregion
        #region CH
        public Single CH { get; set; } = default;
        #endregion
        #region SIL
        public Single SIL { get; set; } = default;
        #endregion
        #region SHOTSIL
        public Single SHOTSIL { get; set; } = default;
        #endregion
        #region FLAP
        public Single FLAP { get; set; } = default;
        #endregion

        #region To String

        public void ToString(
            FileGeneration fg,
            string? name = null)
        {
            PhonemeMixIn.ToString(
                item: this,
                name: name);
        }

        #endregion

        #region Equals and Hash
        public override bool Equals(object? obj)
        {
            if (!(obj is IPhonemeGetter rhs)) return false;
            return ((PhonemeCommon)((IPhonemeGetter)this).CommonInstance()!).Equals(this, rhs);
        }

        public bool Equals(Phoneme obj)
        {
            return ((PhonemeCommon)((IPhonemeGetter)this).CommonInstance()!).Equals(this, obj);
        }

        public override int GetHashCode() => ((PhonemeCommon)((IPhonemeGetter)this).CommonInstance()!).GetHashCode(this);

        #endregion

        #region Xml Translation
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected object XmlWriteTranslator => PhonemeXmlWriteTranslation.Instance;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        object IXmlItem.XmlWriteTranslator => this.XmlWriteTranslator;
        void IXmlItem.WriteToXml(
            XElement node,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask,
            string? name = null)
        {
            ((PhonemeXmlWriteTranslation)this.XmlWriteTranslator).Write(
                item: this,
                name: name,
                node: node,
                errorMask: errorMask,
                translationMask: translationMask);
        }
        #region Xml Create
        [DebuggerStepThrough]
        public static Phoneme CreateFromXml(
            XElement node,
            Phoneme.TranslationMask? translationMask = null)
        {
            return CreateFromXml(
                node: node,
                errorMask: null,
                translationMask: translationMask?.GetCrystal());
        }

        [DebuggerStepThrough]
        public static Phoneme CreateFromXml(
            XElement node,
            out Phoneme.ErrorMask errorMask,
            Phoneme.TranslationMask? translationMask = null)
        {
            ErrorMaskBuilder errorMaskBuilder = new ErrorMaskBuilder();
            var ret = CreateFromXml(
                node: node,
                errorMask: errorMaskBuilder,
                translationMask: translationMask?.GetCrystal());
            errorMask = Phoneme.ErrorMask.Factory(errorMaskBuilder);
            return ret;
        }

        public static Phoneme CreateFromXml(
            XElement node,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask)
        {
            var ret = new Phoneme();
            ((PhonemeSetterCommon)((IPhonemeGetter)ret).CommonSetterInstance()!).CopyInFromXml(
                item: ret,
                node: node,
                errorMask: errorMask,
                translationMask: translationMask);
            return ret;
        }

        public static Phoneme CreateFromXml(
            string path,
            Phoneme.TranslationMask? translationMask = null)
        {
            var node = XDocument.Load(path).Root;
            return CreateFromXml(
                node: node,
                translationMask: translationMask);
        }

        public static Phoneme CreateFromXml(
            string path,
            out Phoneme.ErrorMask errorMask,
            Phoneme.TranslationMask? translationMask = null)
        {
            var node = XDocument.Load(path).Root;
            return CreateFromXml(
                node: node,
                errorMask: out errorMask,
                translationMask: translationMask);
        }

        public static Phoneme CreateFromXml(
            string path,
            ErrorMaskBuilder? errorMask,
            Phoneme.TranslationMask? translationMask = null)
        {
            var node = XDocument.Load(path).Root;
            return CreateFromXml(
                node: node,
                errorMask: errorMask,
                translationMask: translationMask?.GetCrystal());
        }

        public static Phoneme CreateFromXml(
            Stream stream,
            Phoneme.TranslationMask? translationMask = null)
        {
            var node = XDocument.Load(stream).Root;
            return CreateFromXml(
                node: node,
                translationMask: translationMask);
        }

        public static Phoneme CreateFromXml(
            Stream stream,
            out Phoneme.ErrorMask errorMask,
            Phoneme.TranslationMask? translationMask = null)
        {
            var node = XDocument.Load(stream).Root;
            return CreateFromXml(
                node: node,
                errorMask: out errorMask,
                translationMask: translationMask);
        }

        public static Phoneme CreateFromXml(
            Stream stream,
            ErrorMaskBuilder? errorMask,
            Phoneme.TranslationMask? translationMask = null)
        {
            var node = XDocument.Load(stream).Root;
            return CreateFromXml(
                node: node,
                errorMask: errorMask,
                translationMask: translationMask?.GetCrystal());
        }

        #endregion

        #endregion

        #region Mask
        public class Mask<TItem> :
            IMask<TItem>,
            IEquatable<Mask<TItem>>
            where TItem : notnull
        {
            #region Ctors
            public Mask(TItem initialValue)
            {
                this.IY = initialValue;
                this.IH = initialValue;
                this.EH = initialValue;
                this.EY = initialValue;
                this.AE = initialValue;
                this.AA = initialValue;
                this.AW = initialValue;
                this.AY = initialValue;
                this.AH = initialValue;
                this.AO = initialValue;
                this.OY = initialValue;
                this.OW = initialValue;
                this.UH = initialValue;
                this.UW = initialValue;
                this.ER = initialValue;
                this.AX = initialValue;
                this.S = initialValue;
                this.SH = initialValue;
                this.Z = initialValue;
                this.ZH = initialValue;
                this.F = initialValue;
                this.TH = initialValue;
                this.V = initialValue;
                this.DH = initialValue;
                this.M = initialValue;
                this.N = initialValue;
                this.NG = initialValue;
                this.L = initialValue;
                this.R = initialValue;
                this.W = initialValue;
                this.Y = initialValue;
                this.HH = initialValue;
                this.B = initialValue;
                this.D = initialValue;
                this.JH = initialValue;
                this.G = initialValue;
                this.P = initialValue;
                this.T = initialValue;
                this.K = initialValue;
                this.CH = initialValue;
                this.SIL = initialValue;
                this.SHOTSIL = initialValue;
                this.FLAP = initialValue;
            }

            public Mask(
                TItem IY,
                TItem IH,
                TItem EH,
                TItem EY,
                TItem AE,
                TItem AA,
                TItem AW,
                TItem AY,
                TItem AH,
                TItem AO,
                TItem OY,
                TItem OW,
                TItem UH,
                TItem UW,
                TItem ER,
                TItem AX,
                TItem S,
                TItem SH,
                TItem Z,
                TItem ZH,
                TItem F,
                TItem TH,
                TItem V,
                TItem DH,
                TItem M,
                TItem N,
                TItem NG,
                TItem L,
                TItem R,
                TItem W,
                TItem Y,
                TItem HH,
                TItem B,
                TItem D,
                TItem JH,
                TItem G,
                TItem P,
                TItem T,
                TItem K,
                TItem CH,
                TItem SIL,
                TItem SHOTSIL,
                TItem FLAP)
            {
                this.IY = IY;
                this.IH = IH;
                this.EH = EH;
                this.EY = EY;
                this.AE = AE;
                this.AA = AA;
                this.AW = AW;
                this.AY = AY;
                this.AH = AH;
                this.AO = AO;
                this.OY = OY;
                this.OW = OW;
                this.UH = UH;
                this.UW = UW;
                this.ER = ER;
                this.AX = AX;
                this.S = S;
                this.SH = SH;
                this.Z = Z;
                this.ZH = ZH;
                this.F = F;
                this.TH = TH;
                this.V = V;
                this.DH = DH;
                this.M = M;
                this.N = N;
                this.NG = NG;
                this.L = L;
                this.R = R;
                this.W = W;
                this.Y = Y;
                this.HH = HH;
                this.B = B;
                this.D = D;
                this.JH = JH;
                this.G = G;
                this.P = P;
                this.T = T;
                this.K = K;
                this.CH = CH;
                this.SIL = SIL;
                this.SHOTSIL = SHOTSIL;
                this.FLAP = FLAP;
            }

            #pragma warning disable CS8618
            protected Mask()
            {
            }
            #pragma warning restore CS8618

            #endregion

            #region Members
            public TItem IY;
            public TItem IH;
            public TItem EH;
            public TItem EY;
            public TItem AE;
            public TItem AA;
            public TItem AW;
            public TItem AY;
            public TItem AH;
            public TItem AO;
            public TItem OY;
            public TItem OW;
            public TItem UH;
            public TItem UW;
            public TItem ER;
            public TItem AX;
            public TItem S;
            public TItem SH;
            public TItem Z;
            public TItem ZH;
            public TItem F;
            public TItem TH;
            public TItem V;
            public TItem DH;
            public TItem M;
            public TItem N;
            public TItem NG;
            public TItem L;
            public TItem R;
            public TItem W;
            public TItem Y;
            public TItem HH;
            public TItem B;
            public TItem D;
            public TItem JH;
            public TItem G;
            public TItem P;
            public TItem T;
            public TItem K;
            public TItem CH;
            public TItem SIL;
            public TItem SHOTSIL;
            public TItem FLAP;
            #endregion

            #region Equals
            public override bool Equals(object? obj)
            {
                if (!(obj is Mask<TItem> rhs)) return false;
                return Equals(rhs);
            }

            public bool Equals(Mask<TItem> rhs)
            {
                if (rhs == null) return false;
                if (!object.Equals(this.IY, rhs.IY)) return false;
                if (!object.Equals(this.IH, rhs.IH)) return false;
                if (!object.Equals(this.EH, rhs.EH)) return false;
                if (!object.Equals(this.EY, rhs.EY)) return false;
                if (!object.Equals(this.AE, rhs.AE)) return false;
                if (!object.Equals(this.AA, rhs.AA)) return false;
                if (!object.Equals(this.AW, rhs.AW)) return false;
                if (!object.Equals(this.AY, rhs.AY)) return false;
                if (!object.Equals(this.AH, rhs.AH)) return false;
                if (!object.Equals(this.AO, rhs.AO)) return false;
                if (!object.Equals(this.OY, rhs.OY)) return false;
                if (!object.Equals(this.OW, rhs.OW)) return false;
                if (!object.Equals(this.UH, rhs.UH)) return false;
                if (!object.Equals(this.UW, rhs.UW)) return false;
                if (!object.Equals(this.ER, rhs.ER)) return false;
                if (!object.Equals(this.AX, rhs.AX)) return false;
                if (!object.Equals(this.S, rhs.S)) return false;
                if (!object.Equals(this.SH, rhs.SH)) return false;
                if (!object.Equals(this.Z, rhs.Z)) return false;
                if (!object.Equals(this.ZH, rhs.ZH)) return false;
                if (!object.Equals(this.F, rhs.F)) return false;
                if (!object.Equals(this.TH, rhs.TH)) return false;
                if (!object.Equals(this.V, rhs.V)) return false;
                if (!object.Equals(this.DH, rhs.DH)) return false;
                if (!object.Equals(this.M, rhs.M)) return false;
                if (!object.Equals(this.N, rhs.N)) return false;
                if (!object.Equals(this.NG, rhs.NG)) return false;
                if (!object.Equals(this.L, rhs.L)) return false;
                if (!object.Equals(this.R, rhs.R)) return false;
                if (!object.Equals(this.W, rhs.W)) return false;
                if (!object.Equals(this.Y, rhs.Y)) return false;
                if (!object.Equals(this.HH, rhs.HH)) return false;
                if (!object.Equals(this.B, rhs.B)) return false;
                if (!object.Equals(this.D, rhs.D)) return false;
                if (!object.Equals(this.JH, rhs.JH)) return false;
                if (!object.Equals(this.G, rhs.G)) return false;
                if (!object.Equals(this.P, rhs.P)) return false;
                if (!object.Equals(this.T, rhs.T)) return false;
                if (!object.Equals(this.K, rhs.K)) return false;
                if (!object.Equals(this.CH, rhs.CH)) return false;
                if (!object.Equals(this.SIL, rhs.SIL)) return false;
                if (!object.Equals(this.SHOTSIL, rhs.SHOTSIL)) return false;
                if (!object.Equals(this.FLAP, rhs.FLAP)) return false;
                return true;
            }
            public override int GetHashCode()
            {
                var hash = new HashCode();
                hash.Add(this.IY);
                hash.Add(this.IH);
                hash.Add(this.EH);
                hash.Add(this.EY);
                hash.Add(this.AE);
                hash.Add(this.AA);
                hash.Add(this.AW);
                hash.Add(this.AY);
                hash.Add(this.AH);
                hash.Add(this.AO);
                hash.Add(this.OY);
                hash.Add(this.OW);
                hash.Add(this.UH);
                hash.Add(this.UW);
                hash.Add(this.ER);
                hash.Add(this.AX);
                hash.Add(this.S);
                hash.Add(this.SH);
                hash.Add(this.Z);
                hash.Add(this.ZH);
                hash.Add(this.F);
                hash.Add(this.TH);
                hash.Add(this.V);
                hash.Add(this.DH);
                hash.Add(this.M);
                hash.Add(this.N);
                hash.Add(this.NG);
                hash.Add(this.L);
                hash.Add(this.R);
                hash.Add(this.W);
                hash.Add(this.Y);
                hash.Add(this.HH);
                hash.Add(this.B);
                hash.Add(this.D);
                hash.Add(this.JH);
                hash.Add(this.G);
                hash.Add(this.P);
                hash.Add(this.T);
                hash.Add(this.K);
                hash.Add(this.CH);
                hash.Add(this.SIL);
                hash.Add(this.SHOTSIL);
                hash.Add(this.FLAP);
                return hash.ToHashCode();
            }

            #endregion

            #region All
            public bool All(Func<TItem, bool> eval)
            {
                if (!eval(this.IY)) return false;
                if (!eval(this.IH)) return false;
                if (!eval(this.EH)) return false;
                if (!eval(this.EY)) return false;
                if (!eval(this.AE)) return false;
                if (!eval(this.AA)) return false;
                if (!eval(this.AW)) return false;
                if (!eval(this.AY)) return false;
                if (!eval(this.AH)) return false;
                if (!eval(this.AO)) return false;
                if (!eval(this.OY)) return false;
                if (!eval(this.OW)) return false;
                if (!eval(this.UH)) return false;
                if (!eval(this.UW)) return false;
                if (!eval(this.ER)) return false;
                if (!eval(this.AX)) return false;
                if (!eval(this.S)) return false;
                if (!eval(this.SH)) return false;
                if (!eval(this.Z)) return false;
                if (!eval(this.ZH)) return false;
                if (!eval(this.F)) return false;
                if (!eval(this.TH)) return false;
                if (!eval(this.V)) return false;
                if (!eval(this.DH)) return false;
                if (!eval(this.M)) return false;
                if (!eval(this.N)) return false;
                if (!eval(this.NG)) return false;
                if (!eval(this.L)) return false;
                if (!eval(this.R)) return false;
                if (!eval(this.W)) return false;
                if (!eval(this.Y)) return false;
                if (!eval(this.HH)) return false;
                if (!eval(this.B)) return false;
                if (!eval(this.D)) return false;
                if (!eval(this.JH)) return false;
                if (!eval(this.G)) return false;
                if (!eval(this.P)) return false;
                if (!eval(this.T)) return false;
                if (!eval(this.K)) return false;
                if (!eval(this.CH)) return false;
                if (!eval(this.SIL)) return false;
                if (!eval(this.SHOTSIL)) return false;
                if (!eval(this.FLAP)) return false;
                return true;
            }
            #endregion

            #region Any
            public bool Any(Func<TItem, bool> eval)
            {
                if (eval(this.IY)) return true;
                if (eval(this.IH)) return true;
                if (eval(this.EH)) return true;
                if (eval(this.EY)) return true;
                if (eval(this.AE)) return true;
                if (eval(this.AA)) return true;
                if (eval(this.AW)) return true;
                if (eval(this.AY)) return true;
                if (eval(this.AH)) return true;
                if (eval(this.AO)) return true;
                if (eval(this.OY)) return true;
                if (eval(this.OW)) return true;
                if (eval(this.UH)) return true;
                if (eval(this.UW)) return true;
                if (eval(this.ER)) return true;
                if (eval(this.AX)) return true;
                if (eval(this.S)) return true;
                if (eval(this.SH)) return true;
                if (eval(this.Z)) return true;
                if (eval(this.ZH)) return true;
                if (eval(this.F)) return true;
                if (eval(this.TH)) return true;
                if (eval(this.V)) return true;
                if (eval(this.DH)) return true;
                if (eval(this.M)) return true;
                if (eval(this.N)) return true;
                if (eval(this.NG)) return true;
                if (eval(this.L)) return true;
                if (eval(this.R)) return true;
                if (eval(this.W)) return true;
                if (eval(this.Y)) return true;
                if (eval(this.HH)) return true;
                if (eval(this.B)) return true;
                if (eval(this.D)) return true;
                if (eval(this.JH)) return true;
                if (eval(this.G)) return true;
                if (eval(this.P)) return true;
                if (eval(this.T)) return true;
                if (eval(this.K)) return true;
                if (eval(this.CH)) return true;
                if (eval(this.SIL)) return true;
                if (eval(this.SHOTSIL)) return true;
                if (eval(this.FLAP)) return true;
                return false;
            }
            #endregion

            #region Translate
            public Mask<R> Translate<R>(Func<TItem, R> eval)
            {
                var ret = new Phoneme.Mask<R>();
                this.Translate_InternalFill(ret, eval);
                return ret;
            }

            protected void Translate_InternalFill<R>(Mask<R> obj, Func<TItem, R> eval)
            {
                obj.IY = eval(this.IY);
                obj.IH = eval(this.IH);
                obj.EH = eval(this.EH);
                obj.EY = eval(this.EY);
                obj.AE = eval(this.AE);
                obj.AA = eval(this.AA);
                obj.AW = eval(this.AW);
                obj.AY = eval(this.AY);
                obj.AH = eval(this.AH);
                obj.AO = eval(this.AO);
                obj.OY = eval(this.OY);
                obj.OW = eval(this.OW);
                obj.UH = eval(this.UH);
                obj.UW = eval(this.UW);
                obj.ER = eval(this.ER);
                obj.AX = eval(this.AX);
                obj.S = eval(this.S);
                obj.SH = eval(this.SH);
                obj.Z = eval(this.Z);
                obj.ZH = eval(this.ZH);
                obj.F = eval(this.F);
                obj.TH = eval(this.TH);
                obj.V = eval(this.V);
                obj.DH = eval(this.DH);
                obj.M = eval(this.M);
                obj.N = eval(this.N);
                obj.NG = eval(this.NG);
                obj.L = eval(this.L);
                obj.R = eval(this.R);
                obj.W = eval(this.W);
                obj.Y = eval(this.Y);
                obj.HH = eval(this.HH);
                obj.B = eval(this.B);
                obj.D = eval(this.D);
                obj.JH = eval(this.JH);
                obj.G = eval(this.G);
                obj.P = eval(this.P);
                obj.T = eval(this.T);
                obj.K = eval(this.K);
                obj.CH = eval(this.CH);
                obj.SIL = eval(this.SIL);
                obj.SHOTSIL = eval(this.SHOTSIL);
                obj.FLAP = eval(this.FLAP);
            }
            #endregion

            #region To String
            public override string ToString()
            {
                return ToString(printMask: null);
            }

            public string ToString(Phoneme.Mask<bool>? printMask = null)
            {
                var fg = new FileGeneration();
                ToString(fg, printMask);
                return fg.ToString();
            }

            public void ToString(FileGeneration fg, Phoneme.Mask<bool>? printMask = null)
            {
                fg.AppendLine($"{nameof(Phoneme.Mask<TItem>)} =>");
                fg.AppendLine("[");
                using (new DepthWrapper(fg))
                {
                    if (printMask?.IY ?? true)
                    {
                        fg.AppendItem(IY, "IY");
                    }
                    if (printMask?.IH ?? true)
                    {
                        fg.AppendItem(IH, "IH");
                    }
                    if (printMask?.EH ?? true)
                    {
                        fg.AppendItem(EH, "EH");
                    }
                    if (printMask?.EY ?? true)
                    {
                        fg.AppendItem(EY, "EY");
                    }
                    if (printMask?.AE ?? true)
                    {
                        fg.AppendItem(AE, "AE");
                    }
                    if (printMask?.AA ?? true)
                    {
                        fg.AppendItem(AA, "AA");
                    }
                    if (printMask?.AW ?? true)
                    {
                        fg.AppendItem(AW, "AW");
                    }
                    if (printMask?.AY ?? true)
                    {
                        fg.AppendItem(AY, "AY");
                    }
                    if (printMask?.AH ?? true)
                    {
                        fg.AppendItem(AH, "AH");
                    }
                    if (printMask?.AO ?? true)
                    {
                        fg.AppendItem(AO, "AO");
                    }
                    if (printMask?.OY ?? true)
                    {
                        fg.AppendItem(OY, "OY");
                    }
                    if (printMask?.OW ?? true)
                    {
                        fg.AppendItem(OW, "OW");
                    }
                    if (printMask?.UH ?? true)
                    {
                        fg.AppendItem(UH, "UH");
                    }
                    if (printMask?.UW ?? true)
                    {
                        fg.AppendItem(UW, "UW");
                    }
                    if (printMask?.ER ?? true)
                    {
                        fg.AppendItem(ER, "ER");
                    }
                    if (printMask?.AX ?? true)
                    {
                        fg.AppendItem(AX, "AX");
                    }
                    if (printMask?.S ?? true)
                    {
                        fg.AppendItem(S, "S");
                    }
                    if (printMask?.SH ?? true)
                    {
                        fg.AppendItem(SH, "SH");
                    }
                    if (printMask?.Z ?? true)
                    {
                        fg.AppendItem(Z, "Z");
                    }
                    if (printMask?.ZH ?? true)
                    {
                        fg.AppendItem(ZH, "ZH");
                    }
                    if (printMask?.F ?? true)
                    {
                        fg.AppendItem(F, "F");
                    }
                    if (printMask?.TH ?? true)
                    {
                        fg.AppendItem(TH, "TH");
                    }
                    if (printMask?.V ?? true)
                    {
                        fg.AppendItem(V, "V");
                    }
                    if (printMask?.DH ?? true)
                    {
                        fg.AppendItem(DH, "DH");
                    }
                    if (printMask?.M ?? true)
                    {
                        fg.AppendItem(M, "M");
                    }
                    if (printMask?.N ?? true)
                    {
                        fg.AppendItem(N, "N");
                    }
                    if (printMask?.NG ?? true)
                    {
                        fg.AppendItem(NG, "NG");
                    }
                    if (printMask?.L ?? true)
                    {
                        fg.AppendItem(L, "L");
                    }
                    if (printMask?.R ?? true)
                    {
                        fg.AppendItem(R, "R");
                    }
                    if (printMask?.W ?? true)
                    {
                        fg.AppendItem(W, "W");
                    }
                    if (printMask?.Y ?? true)
                    {
                        fg.AppendItem(Y, "Y");
                    }
                    if (printMask?.HH ?? true)
                    {
                        fg.AppendItem(HH, "HH");
                    }
                    if (printMask?.B ?? true)
                    {
                        fg.AppendItem(B, "B");
                    }
                    if (printMask?.D ?? true)
                    {
                        fg.AppendItem(D, "D");
                    }
                    if (printMask?.JH ?? true)
                    {
                        fg.AppendItem(JH, "JH");
                    }
                    if (printMask?.G ?? true)
                    {
                        fg.AppendItem(G, "G");
                    }
                    if (printMask?.P ?? true)
                    {
                        fg.AppendItem(P, "P");
                    }
                    if (printMask?.T ?? true)
                    {
                        fg.AppendItem(T, "T");
                    }
                    if (printMask?.K ?? true)
                    {
                        fg.AppendItem(K, "K");
                    }
                    if (printMask?.CH ?? true)
                    {
                        fg.AppendItem(CH, "CH");
                    }
                    if (printMask?.SIL ?? true)
                    {
                        fg.AppendItem(SIL, "SIL");
                    }
                    if (printMask?.SHOTSIL ?? true)
                    {
                        fg.AppendItem(SHOTSIL, "SHOTSIL");
                    }
                    if (printMask?.FLAP ?? true)
                    {
                        fg.AppendItem(FLAP, "FLAP");
                    }
                }
                fg.AppendLine("]");
            }
            #endregion

        }

        public class ErrorMask :
            IErrorMask,
            IErrorMask<ErrorMask>
        {
            #region Members
            public Exception? Overall { get; set; }
            private List<string>? _warnings;
            public List<string> Warnings
            {
                get
                {
                    if (_warnings == null)
                    {
                        _warnings = new List<string>();
                    }
                    return _warnings;
                }
            }
            public Exception? IY;
            public Exception? IH;
            public Exception? EH;
            public Exception? EY;
            public Exception? AE;
            public Exception? AA;
            public Exception? AW;
            public Exception? AY;
            public Exception? AH;
            public Exception? AO;
            public Exception? OY;
            public Exception? OW;
            public Exception? UH;
            public Exception? UW;
            public Exception? ER;
            public Exception? AX;
            public Exception? S;
            public Exception? SH;
            public Exception? Z;
            public Exception? ZH;
            public Exception? F;
            public Exception? TH;
            public Exception? V;
            public Exception? DH;
            public Exception? M;
            public Exception? N;
            public Exception? NG;
            public Exception? L;
            public Exception? R;
            public Exception? W;
            public Exception? Y;
            public Exception? HH;
            public Exception? B;
            public Exception? D;
            public Exception? JH;
            public Exception? G;
            public Exception? P;
            public Exception? T;
            public Exception? K;
            public Exception? CH;
            public Exception? SIL;
            public Exception? SHOTSIL;
            public Exception? FLAP;
            #endregion

            #region IErrorMask
            public object? GetNthMask(int index)
            {
                Phoneme_FieldIndex enu = (Phoneme_FieldIndex)index;
                switch (enu)
                {
                    case Phoneme_FieldIndex.IY:
                        return IY;
                    case Phoneme_FieldIndex.IH:
                        return IH;
                    case Phoneme_FieldIndex.EH:
                        return EH;
                    case Phoneme_FieldIndex.EY:
                        return EY;
                    case Phoneme_FieldIndex.AE:
                        return AE;
                    case Phoneme_FieldIndex.AA:
                        return AA;
                    case Phoneme_FieldIndex.AW:
                        return AW;
                    case Phoneme_FieldIndex.AY:
                        return AY;
                    case Phoneme_FieldIndex.AH:
                        return AH;
                    case Phoneme_FieldIndex.AO:
                        return AO;
                    case Phoneme_FieldIndex.OY:
                        return OY;
                    case Phoneme_FieldIndex.OW:
                        return OW;
                    case Phoneme_FieldIndex.UH:
                        return UH;
                    case Phoneme_FieldIndex.UW:
                        return UW;
                    case Phoneme_FieldIndex.ER:
                        return ER;
                    case Phoneme_FieldIndex.AX:
                        return AX;
                    case Phoneme_FieldIndex.S:
                        return S;
                    case Phoneme_FieldIndex.SH:
                        return SH;
                    case Phoneme_FieldIndex.Z:
                        return Z;
                    case Phoneme_FieldIndex.ZH:
                        return ZH;
                    case Phoneme_FieldIndex.F:
                        return F;
                    case Phoneme_FieldIndex.TH:
                        return TH;
                    case Phoneme_FieldIndex.V:
                        return V;
                    case Phoneme_FieldIndex.DH:
                        return DH;
                    case Phoneme_FieldIndex.M:
                        return M;
                    case Phoneme_FieldIndex.N:
                        return N;
                    case Phoneme_FieldIndex.NG:
                        return NG;
                    case Phoneme_FieldIndex.L:
                        return L;
                    case Phoneme_FieldIndex.R:
                        return R;
                    case Phoneme_FieldIndex.W:
                        return W;
                    case Phoneme_FieldIndex.Y:
                        return Y;
                    case Phoneme_FieldIndex.HH:
                        return HH;
                    case Phoneme_FieldIndex.B:
                        return B;
                    case Phoneme_FieldIndex.D:
                        return D;
                    case Phoneme_FieldIndex.JH:
                        return JH;
                    case Phoneme_FieldIndex.G:
                        return G;
                    case Phoneme_FieldIndex.P:
                        return P;
                    case Phoneme_FieldIndex.T:
                        return T;
                    case Phoneme_FieldIndex.K:
                        return K;
                    case Phoneme_FieldIndex.CH:
                        return CH;
                    case Phoneme_FieldIndex.SIL:
                        return SIL;
                    case Phoneme_FieldIndex.SHOTSIL:
                        return SHOTSIL;
                    case Phoneme_FieldIndex.FLAP:
                        return FLAP;
                    default:
                        throw new ArgumentException($"Index is out of range: {index}");
                }
            }

            public void SetNthException(int index, Exception ex)
            {
                Phoneme_FieldIndex enu = (Phoneme_FieldIndex)index;
                switch (enu)
                {
                    case Phoneme_FieldIndex.IY:
                        this.IY = ex;
                        break;
                    case Phoneme_FieldIndex.IH:
                        this.IH = ex;
                        break;
                    case Phoneme_FieldIndex.EH:
                        this.EH = ex;
                        break;
                    case Phoneme_FieldIndex.EY:
                        this.EY = ex;
                        break;
                    case Phoneme_FieldIndex.AE:
                        this.AE = ex;
                        break;
                    case Phoneme_FieldIndex.AA:
                        this.AA = ex;
                        break;
                    case Phoneme_FieldIndex.AW:
                        this.AW = ex;
                        break;
                    case Phoneme_FieldIndex.AY:
                        this.AY = ex;
                        break;
                    case Phoneme_FieldIndex.AH:
                        this.AH = ex;
                        break;
                    case Phoneme_FieldIndex.AO:
                        this.AO = ex;
                        break;
                    case Phoneme_FieldIndex.OY:
                        this.OY = ex;
                        break;
                    case Phoneme_FieldIndex.OW:
                        this.OW = ex;
                        break;
                    case Phoneme_FieldIndex.UH:
                        this.UH = ex;
                        break;
                    case Phoneme_FieldIndex.UW:
                        this.UW = ex;
                        break;
                    case Phoneme_FieldIndex.ER:
                        this.ER = ex;
                        break;
                    case Phoneme_FieldIndex.AX:
                        this.AX = ex;
                        break;
                    case Phoneme_FieldIndex.S:
                        this.S = ex;
                        break;
                    case Phoneme_FieldIndex.SH:
                        this.SH = ex;
                        break;
                    case Phoneme_FieldIndex.Z:
                        this.Z = ex;
                        break;
                    case Phoneme_FieldIndex.ZH:
                        this.ZH = ex;
                        break;
                    case Phoneme_FieldIndex.F:
                        this.F = ex;
                        break;
                    case Phoneme_FieldIndex.TH:
                        this.TH = ex;
                        break;
                    case Phoneme_FieldIndex.V:
                        this.V = ex;
                        break;
                    case Phoneme_FieldIndex.DH:
                        this.DH = ex;
                        break;
                    case Phoneme_FieldIndex.M:
                        this.M = ex;
                        break;
                    case Phoneme_FieldIndex.N:
                        this.N = ex;
                        break;
                    case Phoneme_FieldIndex.NG:
                        this.NG = ex;
                        break;
                    case Phoneme_FieldIndex.L:
                        this.L = ex;
                        break;
                    case Phoneme_FieldIndex.R:
                        this.R = ex;
                        break;
                    case Phoneme_FieldIndex.W:
                        this.W = ex;
                        break;
                    case Phoneme_FieldIndex.Y:
                        this.Y = ex;
                        break;
                    case Phoneme_FieldIndex.HH:
                        this.HH = ex;
                        break;
                    case Phoneme_FieldIndex.B:
                        this.B = ex;
                        break;
                    case Phoneme_FieldIndex.D:
                        this.D = ex;
                        break;
                    case Phoneme_FieldIndex.JH:
                        this.JH = ex;
                        break;
                    case Phoneme_FieldIndex.G:
                        this.G = ex;
                        break;
                    case Phoneme_FieldIndex.P:
                        this.P = ex;
                        break;
                    case Phoneme_FieldIndex.T:
                        this.T = ex;
                        break;
                    case Phoneme_FieldIndex.K:
                        this.K = ex;
                        break;
                    case Phoneme_FieldIndex.CH:
                        this.CH = ex;
                        break;
                    case Phoneme_FieldIndex.SIL:
                        this.SIL = ex;
                        break;
                    case Phoneme_FieldIndex.SHOTSIL:
                        this.SHOTSIL = ex;
                        break;
                    case Phoneme_FieldIndex.FLAP:
                        this.FLAP = ex;
                        break;
                    default:
                        throw new ArgumentException($"Index is out of range: {index}");
                }
            }

            public void SetNthMask(int index, object obj)
            {
                Phoneme_FieldIndex enu = (Phoneme_FieldIndex)index;
                switch (enu)
                {
                    case Phoneme_FieldIndex.IY:
                        this.IY = (Exception?)obj;
                        break;
                    case Phoneme_FieldIndex.IH:
                        this.IH = (Exception?)obj;
                        break;
                    case Phoneme_FieldIndex.EH:
                        this.EH = (Exception?)obj;
                        break;
                    case Phoneme_FieldIndex.EY:
                        this.EY = (Exception?)obj;
                        break;
                    case Phoneme_FieldIndex.AE:
                        this.AE = (Exception?)obj;
                        break;
                    case Phoneme_FieldIndex.AA:
                        this.AA = (Exception?)obj;
                        break;
                    case Phoneme_FieldIndex.AW:
                        this.AW = (Exception?)obj;
                        break;
                    case Phoneme_FieldIndex.AY:
                        this.AY = (Exception?)obj;
                        break;
                    case Phoneme_FieldIndex.AH:
                        this.AH = (Exception?)obj;
                        break;
                    case Phoneme_FieldIndex.AO:
                        this.AO = (Exception?)obj;
                        break;
                    case Phoneme_FieldIndex.OY:
                        this.OY = (Exception?)obj;
                        break;
                    case Phoneme_FieldIndex.OW:
                        this.OW = (Exception?)obj;
                        break;
                    case Phoneme_FieldIndex.UH:
                        this.UH = (Exception?)obj;
                        break;
                    case Phoneme_FieldIndex.UW:
                        this.UW = (Exception?)obj;
                        break;
                    case Phoneme_FieldIndex.ER:
                        this.ER = (Exception?)obj;
                        break;
                    case Phoneme_FieldIndex.AX:
                        this.AX = (Exception?)obj;
                        break;
                    case Phoneme_FieldIndex.S:
                        this.S = (Exception?)obj;
                        break;
                    case Phoneme_FieldIndex.SH:
                        this.SH = (Exception?)obj;
                        break;
                    case Phoneme_FieldIndex.Z:
                        this.Z = (Exception?)obj;
                        break;
                    case Phoneme_FieldIndex.ZH:
                        this.ZH = (Exception?)obj;
                        break;
                    case Phoneme_FieldIndex.F:
                        this.F = (Exception?)obj;
                        break;
                    case Phoneme_FieldIndex.TH:
                        this.TH = (Exception?)obj;
                        break;
                    case Phoneme_FieldIndex.V:
                        this.V = (Exception?)obj;
                        break;
                    case Phoneme_FieldIndex.DH:
                        this.DH = (Exception?)obj;
                        break;
                    case Phoneme_FieldIndex.M:
                        this.M = (Exception?)obj;
                        break;
                    case Phoneme_FieldIndex.N:
                        this.N = (Exception?)obj;
                        break;
                    case Phoneme_FieldIndex.NG:
                        this.NG = (Exception?)obj;
                        break;
                    case Phoneme_FieldIndex.L:
                        this.L = (Exception?)obj;
                        break;
                    case Phoneme_FieldIndex.R:
                        this.R = (Exception?)obj;
                        break;
                    case Phoneme_FieldIndex.W:
                        this.W = (Exception?)obj;
                        break;
                    case Phoneme_FieldIndex.Y:
                        this.Y = (Exception?)obj;
                        break;
                    case Phoneme_FieldIndex.HH:
                        this.HH = (Exception?)obj;
                        break;
                    case Phoneme_FieldIndex.B:
                        this.B = (Exception?)obj;
                        break;
                    case Phoneme_FieldIndex.D:
                        this.D = (Exception?)obj;
                        break;
                    case Phoneme_FieldIndex.JH:
                        this.JH = (Exception?)obj;
                        break;
                    case Phoneme_FieldIndex.G:
                        this.G = (Exception?)obj;
                        break;
                    case Phoneme_FieldIndex.P:
                        this.P = (Exception?)obj;
                        break;
                    case Phoneme_FieldIndex.T:
                        this.T = (Exception?)obj;
                        break;
                    case Phoneme_FieldIndex.K:
                        this.K = (Exception?)obj;
                        break;
                    case Phoneme_FieldIndex.CH:
                        this.CH = (Exception?)obj;
                        break;
                    case Phoneme_FieldIndex.SIL:
                        this.SIL = (Exception?)obj;
                        break;
                    case Phoneme_FieldIndex.SHOTSIL:
                        this.SHOTSIL = (Exception?)obj;
                        break;
                    case Phoneme_FieldIndex.FLAP:
                        this.FLAP = (Exception?)obj;
                        break;
                    default:
                        throw new ArgumentException($"Index is out of range: {index}");
                }
            }

            public bool IsInError()
            {
                if (Overall != null) return true;
                if (IY != null) return true;
                if (IH != null) return true;
                if (EH != null) return true;
                if (EY != null) return true;
                if (AE != null) return true;
                if (AA != null) return true;
                if (AW != null) return true;
                if (AY != null) return true;
                if (AH != null) return true;
                if (AO != null) return true;
                if (OY != null) return true;
                if (OW != null) return true;
                if (UH != null) return true;
                if (UW != null) return true;
                if (ER != null) return true;
                if (AX != null) return true;
                if (S != null) return true;
                if (SH != null) return true;
                if (Z != null) return true;
                if (ZH != null) return true;
                if (F != null) return true;
                if (TH != null) return true;
                if (V != null) return true;
                if (DH != null) return true;
                if (M != null) return true;
                if (N != null) return true;
                if (NG != null) return true;
                if (L != null) return true;
                if (R != null) return true;
                if (W != null) return true;
                if (Y != null) return true;
                if (HH != null) return true;
                if (B != null) return true;
                if (D != null) return true;
                if (JH != null) return true;
                if (G != null) return true;
                if (P != null) return true;
                if (T != null) return true;
                if (K != null) return true;
                if (CH != null) return true;
                if (SIL != null) return true;
                if (SHOTSIL != null) return true;
                if (FLAP != null) return true;
                return false;
            }
            #endregion

            #region To String
            public override string ToString()
            {
                var fg = new FileGeneration();
                ToString(fg, null);
                return fg.ToString();
            }

            public void ToString(FileGeneration fg, string? name = null)
            {
                fg.AppendLine($"{(name ?? "ErrorMask")} =>");
                fg.AppendLine("[");
                using (new DepthWrapper(fg))
                {
                    if (this.Overall != null)
                    {
                        fg.AppendLine("Overall =>");
                        fg.AppendLine("[");
                        using (new DepthWrapper(fg))
                        {
                            fg.AppendLine($"{this.Overall}");
                        }
                        fg.AppendLine("]");
                    }
                    ToString_FillInternal(fg);
                }
                fg.AppendLine("]");
            }
            protected void ToString_FillInternal(FileGeneration fg)
            {
                fg.AppendItem(IY, "IY");
                fg.AppendItem(IH, "IH");
                fg.AppendItem(EH, "EH");
                fg.AppendItem(EY, "EY");
                fg.AppendItem(AE, "AE");
                fg.AppendItem(AA, "AA");
                fg.AppendItem(AW, "AW");
                fg.AppendItem(AY, "AY");
                fg.AppendItem(AH, "AH");
                fg.AppendItem(AO, "AO");
                fg.AppendItem(OY, "OY");
                fg.AppendItem(OW, "OW");
                fg.AppendItem(UH, "UH");
                fg.AppendItem(UW, "UW");
                fg.AppendItem(ER, "ER");
                fg.AppendItem(AX, "AX");
                fg.AppendItem(S, "S");
                fg.AppendItem(SH, "SH");
                fg.AppendItem(Z, "Z");
                fg.AppendItem(ZH, "ZH");
                fg.AppendItem(F, "F");
                fg.AppendItem(TH, "TH");
                fg.AppendItem(V, "V");
                fg.AppendItem(DH, "DH");
                fg.AppendItem(M, "M");
                fg.AppendItem(N, "N");
                fg.AppendItem(NG, "NG");
                fg.AppendItem(L, "L");
                fg.AppendItem(R, "R");
                fg.AppendItem(W, "W");
                fg.AppendItem(Y, "Y");
                fg.AppendItem(HH, "HH");
                fg.AppendItem(B, "B");
                fg.AppendItem(D, "D");
                fg.AppendItem(JH, "JH");
                fg.AppendItem(G, "G");
                fg.AppendItem(P, "P");
                fg.AppendItem(T, "T");
                fg.AppendItem(K, "K");
                fg.AppendItem(CH, "CH");
                fg.AppendItem(SIL, "SIL");
                fg.AppendItem(SHOTSIL, "SHOTSIL");
                fg.AppendItem(FLAP, "FLAP");
            }
            #endregion

            #region Combine
            public ErrorMask Combine(ErrorMask? rhs)
            {
                if (rhs == null) return this;
                var ret = new ErrorMask();
                ret.IY = this.IY.Combine(rhs.IY);
                ret.IH = this.IH.Combine(rhs.IH);
                ret.EH = this.EH.Combine(rhs.EH);
                ret.EY = this.EY.Combine(rhs.EY);
                ret.AE = this.AE.Combine(rhs.AE);
                ret.AA = this.AA.Combine(rhs.AA);
                ret.AW = this.AW.Combine(rhs.AW);
                ret.AY = this.AY.Combine(rhs.AY);
                ret.AH = this.AH.Combine(rhs.AH);
                ret.AO = this.AO.Combine(rhs.AO);
                ret.OY = this.OY.Combine(rhs.OY);
                ret.OW = this.OW.Combine(rhs.OW);
                ret.UH = this.UH.Combine(rhs.UH);
                ret.UW = this.UW.Combine(rhs.UW);
                ret.ER = this.ER.Combine(rhs.ER);
                ret.AX = this.AX.Combine(rhs.AX);
                ret.S = this.S.Combine(rhs.S);
                ret.SH = this.SH.Combine(rhs.SH);
                ret.Z = this.Z.Combine(rhs.Z);
                ret.ZH = this.ZH.Combine(rhs.ZH);
                ret.F = this.F.Combine(rhs.F);
                ret.TH = this.TH.Combine(rhs.TH);
                ret.V = this.V.Combine(rhs.V);
                ret.DH = this.DH.Combine(rhs.DH);
                ret.M = this.M.Combine(rhs.M);
                ret.N = this.N.Combine(rhs.N);
                ret.NG = this.NG.Combine(rhs.NG);
                ret.L = this.L.Combine(rhs.L);
                ret.R = this.R.Combine(rhs.R);
                ret.W = this.W.Combine(rhs.W);
                ret.Y = this.Y.Combine(rhs.Y);
                ret.HH = this.HH.Combine(rhs.HH);
                ret.B = this.B.Combine(rhs.B);
                ret.D = this.D.Combine(rhs.D);
                ret.JH = this.JH.Combine(rhs.JH);
                ret.G = this.G.Combine(rhs.G);
                ret.P = this.P.Combine(rhs.P);
                ret.T = this.T.Combine(rhs.T);
                ret.K = this.K.Combine(rhs.K);
                ret.CH = this.CH.Combine(rhs.CH);
                ret.SIL = this.SIL.Combine(rhs.SIL);
                ret.SHOTSIL = this.SHOTSIL.Combine(rhs.SHOTSIL);
                ret.FLAP = this.FLAP.Combine(rhs.FLAP);
                return ret;
            }
            public static ErrorMask? Combine(ErrorMask? lhs, ErrorMask? rhs)
            {
                if (lhs != null && rhs != null) return lhs.Combine(rhs);
                return lhs ?? rhs;
            }
            #endregion

            #region Factory
            public static ErrorMask Factory(ErrorMaskBuilder errorMask)
            {
                return new ErrorMask();
            }
            #endregion

        }
        public class TranslationMask : ITranslationMask
        {
            #region Members
            private TranslationCrystal? _crystal;
            public bool IY;
            public bool IH;
            public bool EH;
            public bool EY;
            public bool AE;
            public bool AA;
            public bool AW;
            public bool AY;
            public bool AH;
            public bool AO;
            public bool OY;
            public bool OW;
            public bool UH;
            public bool UW;
            public bool ER;
            public bool AX;
            public bool S;
            public bool SH;
            public bool Z;
            public bool ZH;
            public bool F;
            public bool TH;
            public bool V;
            public bool DH;
            public bool M;
            public bool N;
            public bool NG;
            public bool L;
            public bool R;
            public bool W;
            public bool Y;
            public bool HH;
            public bool B;
            public bool D;
            public bool JH;
            public bool G;
            public bool P;
            public bool T;
            public bool K;
            public bool CH;
            public bool SIL;
            public bool SHOTSIL;
            public bool FLAP;
            #endregion

            #region Ctors
            public TranslationMask(bool defaultOn)
            {
                this.IY = defaultOn;
                this.IH = defaultOn;
                this.EH = defaultOn;
                this.EY = defaultOn;
                this.AE = defaultOn;
                this.AA = defaultOn;
                this.AW = defaultOn;
                this.AY = defaultOn;
                this.AH = defaultOn;
                this.AO = defaultOn;
                this.OY = defaultOn;
                this.OW = defaultOn;
                this.UH = defaultOn;
                this.UW = defaultOn;
                this.ER = defaultOn;
                this.AX = defaultOn;
                this.S = defaultOn;
                this.SH = defaultOn;
                this.Z = defaultOn;
                this.ZH = defaultOn;
                this.F = defaultOn;
                this.TH = defaultOn;
                this.V = defaultOn;
                this.DH = defaultOn;
                this.M = defaultOn;
                this.N = defaultOn;
                this.NG = defaultOn;
                this.L = defaultOn;
                this.R = defaultOn;
                this.W = defaultOn;
                this.Y = defaultOn;
                this.HH = defaultOn;
                this.B = defaultOn;
                this.D = defaultOn;
                this.JH = defaultOn;
                this.G = defaultOn;
                this.P = defaultOn;
                this.T = defaultOn;
                this.K = defaultOn;
                this.CH = defaultOn;
                this.SIL = defaultOn;
                this.SHOTSIL = defaultOn;
                this.FLAP = defaultOn;
            }

            #endregion

            public TranslationCrystal GetCrystal()
            {
                if (_crystal != null) return _crystal;
                var ret = new List<(bool On, TranslationCrystal? SubCrystal)>();
                GetCrystal(ret);
                _crystal = new TranslationCrystal(ret.ToArray());
                return _crystal;
            }

            protected void GetCrystal(List<(bool On, TranslationCrystal? SubCrystal)> ret)
            {
                ret.Add((IY, null));
                ret.Add((IH, null));
                ret.Add((EH, null));
                ret.Add((EY, null));
                ret.Add((AE, null));
                ret.Add((AA, null));
                ret.Add((AW, null));
                ret.Add((AY, null));
                ret.Add((AH, null));
                ret.Add((AO, null));
                ret.Add((OY, null));
                ret.Add((OW, null));
                ret.Add((UH, null));
                ret.Add((UW, null));
                ret.Add((ER, null));
                ret.Add((AX, null));
                ret.Add((S, null));
                ret.Add((SH, null));
                ret.Add((Z, null));
                ret.Add((ZH, null));
                ret.Add((F, null));
                ret.Add((TH, null));
                ret.Add((V, null));
                ret.Add((DH, null));
                ret.Add((M, null));
                ret.Add((N, null));
                ret.Add((NG, null));
                ret.Add((L, null));
                ret.Add((R, null));
                ret.Add((W, null));
                ret.Add((Y, null));
                ret.Add((HH, null));
                ret.Add((B, null));
                ret.Add((D, null));
                ret.Add((JH, null));
                ret.Add((G, null));
                ret.Add((P, null));
                ret.Add((T, null));
                ret.Add((K, null));
                ret.Add((CH, null));
                ret.Add((SIL, null));
                ret.Add((SHOTSIL, null));
                ret.Add((FLAP, null));
            }
        }
        #endregion

        #region Binary Translation
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected object BinaryWriteTranslator => PhonemeBinaryWriteTranslation.Instance;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        object IBinaryItem.BinaryWriteTranslator => this.BinaryWriteTranslator;
        void IBinaryItem.WriteToBinary(
            MutagenWriter writer,
            RecordTypeConverter? recordTypeConverter = null)
        {
            ((PhonemeBinaryWriteTranslation)this.BinaryWriteTranslator).Write(
                item: this,
                writer: writer,
                recordTypeConverter: recordTypeConverter);
        }
        #region Binary Create
        [DebuggerStepThrough]
        public static Phoneme CreateFromBinary(MutagenFrame frame)
        {
            return CreateFromBinary(
                frame: frame,
                recordTypeConverter: null);
        }

        public static Phoneme CreateFromBinary(
            MutagenFrame frame,
            RecordTypeConverter? recordTypeConverter = null)
        {
            var ret = new Phoneme();
            ((PhonemeSetterCommon)((IPhonemeGetter)ret).CommonSetterInstance()!).CopyInFromBinary(
                item: ret,
                frame: frame,
                recordTypeConverter: recordTypeConverter);
            return ret;
        }

        #endregion

        #endregion

        void IPrintable.ToString(FileGeneration fg, string? name) => this.ToString(fg, name);
        IMask<bool> ILoquiObjectGetter.GetHasBeenSetIMask() => this.GetHasBeenSetMask();
        IMask<bool> IEqualsMask.GetEqualsIMask(object rhs, EqualsMaskHelper.Include include) => this.GetEqualsMask((IPhonemeGetter)rhs, include);

        void IClearable.Clear()
        {
            ((PhonemeSetterCommon)((IPhonemeGetter)this).CommonSetterInstance()!).Clear(this);
        }

        internal static Phoneme GetNew()
        {
            return new Phoneme();
        }

    }
    #endregion

    #region Interface
    public partial interface IPhoneme :
        IPhonemeGetter,
        ILoquiObjectSetter<IPhoneme>
    {
        new Single IY { get; set; }
        new Single IH { get; set; }
        new Single EH { get; set; }
        new Single EY { get; set; }
        new Single AE { get; set; }
        new Single AA { get; set; }
        new Single AW { get; set; }
        new Single AY { get; set; }
        new Single AH { get; set; }
        new Single AO { get; set; }
        new Single OY { get; set; }
        new Single OW { get; set; }
        new Single UH { get; set; }
        new Single UW { get; set; }
        new Single ER { get; set; }
        new Single AX { get; set; }
        new Single S { get; set; }
        new Single SH { get; set; }
        new Single Z { get; set; }
        new Single ZH { get; set; }
        new Single F { get; set; }
        new Single TH { get; set; }
        new Single V { get; set; }
        new Single DH { get; set; }
        new Single M { get; set; }
        new Single N { get; set; }
        new Single NG { get; set; }
        new Single L { get; set; }
        new Single R { get; set; }
        new Single W { get; set; }
        new Single Y { get; set; }
        new Single HH { get; set; }
        new Single B { get; set; }
        new Single D { get; set; }
        new Single JH { get; set; }
        new Single G { get; set; }
        new Single P { get; set; }
        new Single T { get; set; }
        new Single K { get; set; }
        new Single CH { get; set; }
        new Single SIL { get; set; }
        new Single SHOTSIL { get; set; }
        new Single FLAP { get; set; }
    }

    public partial interface IPhonemeGetter :
        ILoquiObject,
        ILoquiObject<IPhonemeGetter>,
        IXmlItem,
        IBinaryItem
    {
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        object CommonInstance();
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        object? CommonSetterInstance();
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        object CommonSetterTranslationInstance();
        Single IY { get; }
        Single IH { get; }
        Single EH { get; }
        Single EY { get; }
        Single AE { get; }
        Single AA { get; }
        Single AW { get; }
        Single AY { get; }
        Single AH { get; }
        Single AO { get; }
        Single OY { get; }
        Single OW { get; }
        Single UH { get; }
        Single UW { get; }
        Single ER { get; }
        Single AX { get; }
        Single S { get; }
        Single SH { get; }
        Single Z { get; }
        Single ZH { get; }
        Single F { get; }
        Single TH { get; }
        Single V { get; }
        Single DH { get; }
        Single M { get; }
        Single N { get; }
        Single NG { get; }
        Single L { get; }
        Single R { get; }
        Single W { get; }
        Single Y { get; }
        Single HH { get; }
        Single B { get; }
        Single D { get; }
        Single JH { get; }
        Single G { get; }
        Single P { get; }
        Single T { get; }
        Single K { get; }
        Single CH { get; }
        Single SIL { get; }
        Single SHOTSIL { get; }
        Single FLAP { get; }

    }

    #endregion

    #region Common MixIn
    public static partial class PhonemeMixIn
    {
        public static void Clear(this IPhoneme item)
        {
            ((PhonemeSetterCommon)((IPhonemeGetter)item).CommonSetterInstance()!).Clear(item: item);
        }

        public static Phoneme.Mask<bool> GetEqualsMask(
            this IPhonemeGetter item,
            IPhonemeGetter rhs,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            return ((PhonemeCommon)((IPhonemeGetter)item).CommonInstance()!).GetEqualsMask(
                item: item,
                rhs: rhs,
                include: include);
        }

        public static string ToString(
            this IPhonemeGetter item,
            string? name = null,
            Phoneme.Mask<bool>? printMask = null)
        {
            return ((PhonemeCommon)((IPhonemeGetter)item).CommonInstance()!).ToString(
                item: item,
                name: name,
                printMask: printMask);
        }

        public static void ToString(
            this IPhonemeGetter item,
            FileGeneration fg,
            string? name = null,
            Phoneme.Mask<bool>? printMask = null)
        {
            ((PhonemeCommon)((IPhonemeGetter)item).CommonInstance()!).ToString(
                item: item,
                fg: fg,
                name: name,
                printMask: printMask);
        }

        public static bool HasBeenSet(
            this IPhonemeGetter item,
            Phoneme.Mask<bool?> checkMask)
        {
            return ((PhonemeCommon)((IPhonemeGetter)item).CommonInstance()!).HasBeenSet(
                item: item,
                checkMask: checkMask);
        }

        public static Phoneme.Mask<bool> GetHasBeenSetMask(this IPhonemeGetter item)
        {
            var ret = new Phoneme.Mask<bool>(false);
            ((PhonemeCommon)((IPhonemeGetter)item).CommonInstance()!).FillHasBeenSetMask(
                item: item,
                mask: ret);
            return ret;
        }

        public static bool Equals(
            this IPhonemeGetter item,
            IPhonemeGetter rhs)
        {
            return ((PhonemeCommon)((IPhonemeGetter)item).CommonInstance()!).Equals(
                lhs: item,
                rhs: rhs);
        }

        public static void DeepCopyIn(
            this IPhoneme lhs,
            IPhonemeGetter rhs,
            Phoneme.TranslationMask? copyMask = null)
        {
            ((PhonemeSetterTranslationCommon)((IPhonemeGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: default,
                copyMask: default);
        }

        public static void DeepCopyIn(
            this IPhoneme lhs,
            IPhonemeGetter rhs,
            out Phoneme.ErrorMask errorMask,
            Phoneme.TranslationMask? copyMask = null)
        {
            var errorMaskBuilder = new ErrorMaskBuilder();
            ((PhonemeSetterTranslationCommon)((IPhonemeGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: errorMaskBuilder,
                copyMask: copyMask?.GetCrystal());
            errorMask = Phoneme.ErrorMask.Factory(errorMaskBuilder);
        }

        public static void DeepCopyIn(
            this IPhoneme lhs,
            IPhonemeGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask)
        {
            ((PhonemeSetterTranslationCommon)((IPhonemeGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: errorMask,
                copyMask: copyMask);
        }

        public static Phoneme DeepCopy(
            this IPhonemeGetter item,
            Phoneme.TranslationMask? copyMask = null)
        {
            return ((PhonemeSetterTranslationCommon)((IPhonemeGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask);
        }

        public static Phoneme DeepCopy(
            this IPhonemeGetter item,
            out Phoneme.ErrorMask errorMask,
            Phoneme.TranslationMask? copyMask = null)
        {
            return ((PhonemeSetterTranslationCommon)((IPhonemeGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask,
                errorMask: out errorMask);
        }

        public static Phoneme DeepCopy(
            this IPhonemeGetter item,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask = null)
        {
            return ((PhonemeSetterTranslationCommon)((IPhonemeGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask,
                errorMask: errorMask);
        }

        #region Xml Translation
        [DebuggerStepThrough]
        public static void CopyInFromXml(
            this IPhoneme item,
            XElement node,
            Phoneme.TranslationMask? translationMask = null)
        {
            CopyInFromXml(
                item: item,
                node: node,
                errorMask: null,
                translationMask: translationMask?.GetCrystal());
        }

        [DebuggerStepThrough]
        public static void CopyInFromXml(
            this IPhoneme item,
            XElement node,
            out Phoneme.ErrorMask errorMask,
            Phoneme.TranslationMask? translationMask = null)
        {
            ErrorMaskBuilder errorMaskBuilder = new ErrorMaskBuilder();
            CopyInFromXml(
                item: item,
                node: node,
                errorMask: errorMaskBuilder,
                translationMask: translationMask?.GetCrystal());
            errorMask = Phoneme.ErrorMask.Factory(errorMaskBuilder);
        }

        public static void CopyInFromXml(
            this IPhoneme item,
            XElement node,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask)
        {
            ((PhonemeSetterCommon)((IPhonemeGetter)item).CommonSetterInstance()!).CopyInFromXml(
                item: item,
                node: node,
                errorMask: errorMask,
                translationMask: translationMask);
        }

        public static void CopyInFromXml(
            this IPhoneme item,
            string path,
            Phoneme.TranslationMask? translationMask = null)
        {
            var node = XDocument.Load(path).Root;
            CopyInFromXml(
                item: item,
                node: node,
                translationMask: translationMask);
        }

        public static void CopyInFromXml(
            this IPhoneme item,
            string path,
            out Phoneme.ErrorMask errorMask,
            Phoneme.TranslationMask? translationMask = null)
        {
            var node = XDocument.Load(path).Root;
            CopyInFromXml(
                item: item,
                node: node,
                errorMask: out errorMask,
                translationMask: translationMask);
        }

        public static void CopyInFromXml(
            this IPhoneme item,
            string path,
            ErrorMaskBuilder? errorMask,
            Phoneme.TranslationMask? translationMask = null)
        {
            var node = XDocument.Load(path).Root;
            CopyInFromXml(
                item: item,
                node: node,
                errorMask: errorMask,
                translationMask: translationMask?.GetCrystal());
        }

        public static void CopyInFromXml(
            this IPhoneme item,
            Stream stream,
            Phoneme.TranslationMask? translationMask = null)
        {
            var node = XDocument.Load(stream).Root;
            CopyInFromXml(
                item: item,
                node: node,
                translationMask: translationMask);
        }

        public static void CopyInFromXml(
            this IPhoneme item,
            Stream stream,
            out Phoneme.ErrorMask errorMask,
            Phoneme.TranslationMask? translationMask = null)
        {
            var node = XDocument.Load(stream).Root;
            CopyInFromXml(
                item: item,
                node: node,
                errorMask: out errorMask,
                translationMask: translationMask);
        }

        public static void CopyInFromXml(
            this IPhoneme item,
            Stream stream,
            ErrorMaskBuilder? errorMask,
            Phoneme.TranslationMask? translationMask = null)
        {
            var node = XDocument.Load(stream).Root;
            CopyInFromXml(
                item: item,
                node: node,
                errorMask: errorMask,
                translationMask: translationMask?.GetCrystal());
        }

        #endregion

        #region Binary Translation
        [DebuggerStepThrough]
        public static void CopyInFromBinary(
            this IPhoneme item,
            MutagenFrame frame)
        {
            CopyInFromBinary(
                item: item,
                frame: frame,
                recordTypeConverter: null);
        }

        public static void CopyInFromBinary(
            this IPhoneme item,
            MutagenFrame frame,
            RecordTypeConverter? recordTypeConverter = null)
        {
            ((PhonemeSetterCommon)((IPhonemeGetter)item).CommonSetterInstance()!).CopyInFromBinary(
                item: item,
                frame: frame,
                recordTypeConverter: recordTypeConverter);
        }

        #endregion

    }
    #endregion

}

namespace Mutagen.Bethesda.Skyrim.Internals
{
    #region Field Index
    public enum Phoneme_FieldIndex
    {
        IY = 0,
        IH = 1,
        EH = 2,
        EY = 3,
        AE = 4,
        AA = 5,
        AW = 6,
        AY = 7,
        AH = 8,
        AO = 9,
        OY = 10,
        OW = 11,
        UH = 12,
        UW = 13,
        ER = 14,
        AX = 15,
        S = 16,
        SH = 17,
        Z = 18,
        ZH = 19,
        F = 20,
        TH = 21,
        V = 22,
        DH = 23,
        M = 24,
        N = 25,
        NG = 26,
        L = 27,
        R = 28,
        W = 29,
        Y = 30,
        HH = 31,
        B = 32,
        D = 33,
        JH = 34,
        G = 35,
        P = 36,
        T = 37,
        K = 38,
        CH = 39,
        SIL = 40,
        SHOTSIL = 41,
        FLAP = 42,
    }
    #endregion

    #region Registration
    public partial class Phoneme_Registration : ILoquiRegistration
    {
        public static readonly Phoneme_Registration Instance = new Phoneme_Registration();

        public static ProtocolKey ProtocolKey => ProtocolDefinition_Skyrim.ProtocolKey;

        public static readonly ObjectKey ObjectKey = new ObjectKey(
            protocolKey: ProtocolDefinition_Skyrim.ProtocolKey,
            msgID: 71,
            version: 0);

        public const string GUID = "de2d7619-85dc-497e-b8a2-b955f9340a93";

        public const ushort AdditionalFieldCount = 43;

        public const ushort FieldCount = 43;

        public static readonly Type MaskType = typeof(Phoneme.Mask<>);

        public static readonly Type ErrorMaskType = typeof(Phoneme.ErrorMask);

        public static readonly Type ClassType = typeof(Phoneme);

        public static readonly Type GetterType = typeof(IPhonemeGetter);

        public static readonly Type? InternalGetterType = null;

        public static readonly Type SetterType = typeof(IPhoneme);

        public static readonly Type? InternalSetterType = null;

        public const string FullName = "Mutagen.Bethesda.Skyrim.Phoneme";

        public const string Name = "Phoneme";

        public const string Namespace = "Mutagen.Bethesda.Skyrim";

        public const byte GenericCount = 0;

        public static readonly Type? GenericRegistrationType = null;

        public static ushort? GetNameIndex(StringCaseAgnostic str)
        {
            switch (str.Upper)
            {
                case "IY":
                    return (ushort)Phoneme_FieldIndex.IY;
                case "IH":
                    return (ushort)Phoneme_FieldIndex.IH;
                case "EH":
                    return (ushort)Phoneme_FieldIndex.EH;
                case "EY":
                    return (ushort)Phoneme_FieldIndex.EY;
                case "AE":
                    return (ushort)Phoneme_FieldIndex.AE;
                case "AA":
                    return (ushort)Phoneme_FieldIndex.AA;
                case "AW":
                    return (ushort)Phoneme_FieldIndex.AW;
                case "AY":
                    return (ushort)Phoneme_FieldIndex.AY;
                case "AH":
                    return (ushort)Phoneme_FieldIndex.AH;
                case "AO":
                    return (ushort)Phoneme_FieldIndex.AO;
                case "OY":
                    return (ushort)Phoneme_FieldIndex.OY;
                case "OW":
                    return (ushort)Phoneme_FieldIndex.OW;
                case "UH":
                    return (ushort)Phoneme_FieldIndex.UH;
                case "UW":
                    return (ushort)Phoneme_FieldIndex.UW;
                case "ER":
                    return (ushort)Phoneme_FieldIndex.ER;
                case "AX":
                    return (ushort)Phoneme_FieldIndex.AX;
                case "S":
                    return (ushort)Phoneme_FieldIndex.S;
                case "SH":
                    return (ushort)Phoneme_FieldIndex.SH;
                case "Z":
                    return (ushort)Phoneme_FieldIndex.Z;
                case "ZH":
                    return (ushort)Phoneme_FieldIndex.ZH;
                case "F":
                    return (ushort)Phoneme_FieldIndex.F;
                case "TH":
                    return (ushort)Phoneme_FieldIndex.TH;
                case "V":
                    return (ushort)Phoneme_FieldIndex.V;
                case "DH":
                    return (ushort)Phoneme_FieldIndex.DH;
                case "M":
                    return (ushort)Phoneme_FieldIndex.M;
                case "N":
                    return (ushort)Phoneme_FieldIndex.N;
                case "NG":
                    return (ushort)Phoneme_FieldIndex.NG;
                case "L":
                    return (ushort)Phoneme_FieldIndex.L;
                case "R":
                    return (ushort)Phoneme_FieldIndex.R;
                case "W":
                    return (ushort)Phoneme_FieldIndex.W;
                case "Y":
                    return (ushort)Phoneme_FieldIndex.Y;
                case "HH":
                    return (ushort)Phoneme_FieldIndex.HH;
                case "B":
                    return (ushort)Phoneme_FieldIndex.B;
                case "D":
                    return (ushort)Phoneme_FieldIndex.D;
                case "JH":
                    return (ushort)Phoneme_FieldIndex.JH;
                case "G":
                    return (ushort)Phoneme_FieldIndex.G;
                case "P":
                    return (ushort)Phoneme_FieldIndex.P;
                case "T":
                    return (ushort)Phoneme_FieldIndex.T;
                case "K":
                    return (ushort)Phoneme_FieldIndex.K;
                case "CH":
                    return (ushort)Phoneme_FieldIndex.CH;
                case "SIL":
                    return (ushort)Phoneme_FieldIndex.SIL;
                case "SHOTSIL":
                    return (ushort)Phoneme_FieldIndex.SHOTSIL;
                case "FLAP":
                    return (ushort)Phoneme_FieldIndex.FLAP;
                default:
                    return null;
            }
        }

        public static bool GetNthIsEnumerable(ushort index)
        {
            Phoneme_FieldIndex enu = (Phoneme_FieldIndex)index;
            switch (enu)
            {
                case Phoneme_FieldIndex.IY:
                case Phoneme_FieldIndex.IH:
                case Phoneme_FieldIndex.EH:
                case Phoneme_FieldIndex.EY:
                case Phoneme_FieldIndex.AE:
                case Phoneme_FieldIndex.AA:
                case Phoneme_FieldIndex.AW:
                case Phoneme_FieldIndex.AY:
                case Phoneme_FieldIndex.AH:
                case Phoneme_FieldIndex.AO:
                case Phoneme_FieldIndex.OY:
                case Phoneme_FieldIndex.OW:
                case Phoneme_FieldIndex.UH:
                case Phoneme_FieldIndex.UW:
                case Phoneme_FieldIndex.ER:
                case Phoneme_FieldIndex.AX:
                case Phoneme_FieldIndex.S:
                case Phoneme_FieldIndex.SH:
                case Phoneme_FieldIndex.Z:
                case Phoneme_FieldIndex.ZH:
                case Phoneme_FieldIndex.F:
                case Phoneme_FieldIndex.TH:
                case Phoneme_FieldIndex.V:
                case Phoneme_FieldIndex.DH:
                case Phoneme_FieldIndex.M:
                case Phoneme_FieldIndex.N:
                case Phoneme_FieldIndex.NG:
                case Phoneme_FieldIndex.L:
                case Phoneme_FieldIndex.R:
                case Phoneme_FieldIndex.W:
                case Phoneme_FieldIndex.Y:
                case Phoneme_FieldIndex.HH:
                case Phoneme_FieldIndex.B:
                case Phoneme_FieldIndex.D:
                case Phoneme_FieldIndex.JH:
                case Phoneme_FieldIndex.G:
                case Phoneme_FieldIndex.P:
                case Phoneme_FieldIndex.T:
                case Phoneme_FieldIndex.K:
                case Phoneme_FieldIndex.CH:
                case Phoneme_FieldIndex.SIL:
                case Phoneme_FieldIndex.SHOTSIL:
                case Phoneme_FieldIndex.FLAP:
                    return false;
                default:
                    throw new ArgumentException($"Index is out of range: {index}");
            }
        }

        public static bool GetNthIsLoqui(ushort index)
        {
            Phoneme_FieldIndex enu = (Phoneme_FieldIndex)index;
            switch (enu)
            {
                case Phoneme_FieldIndex.IY:
                case Phoneme_FieldIndex.IH:
                case Phoneme_FieldIndex.EH:
                case Phoneme_FieldIndex.EY:
                case Phoneme_FieldIndex.AE:
                case Phoneme_FieldIndex.AA:
                case Phoneme_FieldIndex.AW:
                case Phoneme_FieldIndex.AY:
                case Phoneme_FieldIndex.AH:
                case Phoneme_FieldIndex.AO:
                case Phoneme_FieldIndex.OY:
                case Phoneme_FieldIndex.OW:
                case Phoneme_FieldIndex.UH:
                case Phoneme_FieldIndex.UW:
                case Phoneme_FieldIndex.ER:
                case Phoneme_FieldIndex.AX:
                case Phoneme_FieldIndex.S:
                case Phoneme_FieldIndex.SH:
                case Phoneme_FieldIndex.Z:
                case Phoneme_FieldIndex.ZH:
                case Phoneme_FieldIndex.F:
                case Phoneme_FieldIndex.TH:
                case Phoneme_FieldIndex.V:
                case Phoneme_FieldIndex.DH:
                case Phoneme_FieldIndex.M:
                case Phoneme_FieldIndex.N:
                case Phoneme_FieldIndex.NG:
                case Phoneme_FieldIndex.L:
                case Phoneme_FieldIndex.R:
                case Phoneme_FieldIndex.W:
                case Phoneme_FieldIndex.Y:
                case Phoneme_FieldIndex.HH:
                case Phoneme_FieldIndex.B:
                case Phoneme_FieldIndex.D:
                case Phoneme_FieldIndex.JH:
                case Phoneme_FieldIndex.G:
                case Phoneme_FieldIndex.P:
                case Phoneme_FieldIndex.T:
                case Phoneme_FieldIndex.K:
                case Phoneme_FieldIndex.CH:
                case Phoneme_FieldIndex.SIL:
                case Phoneme_FieldIndex.SHOTSIL:
                case Phoneme_FieldIndex.FLAP:
                    return false;
                default:
                    throw new ArgumentException($"Index is out of range: {index}");
            }
        }

        public static bool GetNthIsSingleton(ushort index)
        {
            Phoneme_FieldIndex enu = (Phoneme_FieldIndex)index;
            switch (enu)
            {
                case Phoneme_FieldIndex.IY:
                case Phoneme_FieldIndex.IH:
                case Phoneme_FieldIndex.EH:
                case Phoneme_FieldIndex.EY:
                case Phoneme_FieldIndex.AE:
                case Phoneme_FieldIndex.AA:
                case Phoneme_FieldIndex.AW:
                case Phoneme_FieldIndex.AY:
                case Phoneme_FieldIndex.AH:
                case Phoneme_FieldIndex.AO:
                case Phoneme_FieldIndex.OY:
                case Phoneme_FieldIndex.OW:
                case Phoneme_FieldIndex.UH:
                case Phoneme_FieldIndex.UW:
                case Phoneme_FieldIndex.ER:
                case Phoneme_FieldIndex.AX:
                case Phoneme_FieldIndex.S:
                case Phoneme_FieldIndex.SH:
                case Phoneme_FieldIndex.Z:
                case Phoneme_FieldIndex.ZH:
                case Phoneme_FieldIndex.F:
                case Phoneme_FieldIndex.TH:
                case Phoneme_FieldIndex.V:
                case Phoneme_FieldIndex.DH:
                case Phoneme_FieldIndex.M:
                case Phoneme_FieldIndex.N:
                case Phoneme_FieldIndex.NG:
                case Phoneme_FieldIndex.L:
                case Phoneme_FieldIndex.R:
                case Phoneme_FieldIndex.W:
                case Phoneme_FieldIndex.Y:
                case Phoneme_FieldIndex.HH:
                case Phoneme_FieldIndex.B:
                case Phoneme_FieldIndex.D:
                case Phoneme_FieldIndex.JH:
                case Phoneme_FieldIndex.G:
                case Phoneme_FieldIndex.P:
                case Phoneme_FieldIndex.T:
                case Phoneme_FieldIndex.K:
                case Phoneme_FieldIndex.CH:
                case Phoneme_FieldIndex.SIL:
                case Phoneme_FieldIndex.SHOTSIL:
                case Phoneme_FieldIndex.FLAP:
                    return false;
                default:
                    throw new ArgumentException($"Index is out of range: {index}");
            }
        }

        public static string GetNthName(ushort index)
        {
            Phoneme_FieldIndex enu = (Phoneme_FieldIndex)index;
            switch (enu)
            {
                case Phoneme_FieldIndex.IY:
                    return "IY";
                case Phoneme_FieldIndex.IH:
                    return "IH";
                case Phoneme_FieldIndex.EH:
                    return "EH";
                case Phoneme_FieldIndex.EY:
                    return "EY";
                case Phoneme_FieldIndex.AE:
                    return "AE";
                case Phoneme_FieldIndex.AA:
                    return "AA";
                case Phoneme_FieldIndex.AW:
                    return "AW";
                case Phoneme_FieldIndex.AY:
                    return "AY";
                case Phoneme_FieldIndex.AH:
                    return "AH";
                case Phoneme_FieldIndex.AO:
                    return "AO";
                case Phoneme_FieldIndex.OY:
                    return "OY";
                case Phoneme_FieldIndex.OW:
                    return "OW";
                case Phoneme_FieldIndex.UH:
                    return "UH";
                case Phoneme_FieldIndex.UW:
                    return "UW";
                case Phoneme_FieldIndex.ER:
                    return "ER";
                case Phoneme_FieldIndex.AX:
                    return "AX";
                case Phoneme_FieldIndex.S:
                    return "S";
                case Phoneme_FieldIndex.SH:
                    return "SH";
                case Phoneme_FieldIndex.Z:
                    return "Z";
                case Phoneme_FieldIndex.ZH:
                    return "ZH";
                case Phoneme_FieldIndex.F:
                    return "F";
                case Phoneme_FieldIndex.TH:
                    return "TH";
                case Phoneme_FieldIndex.V:
                    return "V";
                case Phoneme_FieldIndex.DH:
                    return "DH";
                case Phoneme_FieldIndex.M:
                    return "M";
                case Phoneme_FieldIndex.N:
                    return "N";
                case Phoneme_FieldIndex.NG:
                    return "NG";
                case Phoneme_FieldIndex.L:
                    return "L";
                case Phoneme_FieldIndex.R:
                    return "R";
                case Phoneme_FieldIndex.W:
                    return "W";
                case Phoneme_FieldIndex.Y:
                    return "Y";
                case Phoneme_FieldIndex.HH:
                    return "HH";
                case Phoneme_FieldIndex.B:
                    return "B";
                case Phoneme_FieldIndex.D:
                    return "D";
                case Phoneme_FieldIndex.JH:
                    return "JH";
                case Phoneme_FieldIndex.G:
                    return "G";
                case Phoneme_FieldIndex.P:
                    return "P";
                case Phoneme_FieldIndex.T:
                    return "T";
                case Phoneme_FieldIndex.K:
                    return "K";
                case Phoneme_FieldIndex.CH:
                    return "CH";
                case Phoneme_FieldIndex.SIL:
                    return "SIL";
                case Phoneme_FieldIndex.SHOTSIL:
                    return "SHOTSIL";
                case Phoneme_FieldIndex.FLAP:
                    return "FLAP";
                default:
                    throw new ArgumentException($"Index is out of range: {index}");
            }
        }

        public static bool IsNthDerivative(ushort index)
        {
            Phoneme_FieldIndex enu = (Phoneme_FieldIndex)index;
            switch (enu)
            {
                case Phoneme_FieldIndex.IY:
                case Phoneme_FieldIndex.IH:
                case Phoneme_FieldIndex.EH:
                case Phoneme_FieldIndex.EY:
                case Phoneme_FieldIndex.AE:
                case Phoneme_FieldIndex.AA:
                case Phoneme_FieldIndex.AW:
                case Phoneme_FieldIndex.AY:
                case Phoneme_FieldIndex.AH:
                case Phoneme_FieldIndex.AO:
                case Phoneme_FieldIndex.OY:
                case Phoneme_FieldIndex.OW:
                case Phoneme_FieldIndex.UH:
                case Phoneme_FieldIndex.UW:
                case Phoneme_FieldIndex.ER:
                case Phoneme_FieldIndex.AX:
                case Phoneme_FieldIndex.S:
                case Phoneme_FieldIndex.SH:
                case Phoneme_FieldIndex.Z:
                case Phoneme_FieldIndex.ZH:
                case Phoneme_FieldIndex.F:
                case Phoneme_FieldIndex.TH:
                case Phoneme_FieldIndex.V:
                case Phoneme_FieldIndex.DH:
                case Phoneme_FieldIndex.M:
                case Phoneme_FieldIndex.N:
                case Phoneme_FieldIndex.NG:
                case Phoneme_FieldIndex.L:
                case Phoneme_FieldIndex.R:
                case Phoneme_FieldIndex.W:
                case Phoneme_FieldIndex.Y:
                case Phoneme_FieldIndex.HH:
                case Phoneme_FieldIndex.B:
                case Phoneme_FieldIndex.D:
                case Phoneme_FieldIndex.JH:
                case Phoneme_FieldIndex.G:
                case Phoneme_FieldIndex.P:
                case Phoneme_FieldIndex.T:
                case Phoneme_FieldIndex.K:
                case Phoneme_FieldIndex.CH:
                case Phoneme_FieldIndex.SIL:
                case Phoneme_FieldIndex.SHOTSIL:
                case Phoneme_FieldIndex.FLAP:
                    return false;
                default:
                    throw new ArgumentException($"Index is out of range: {index}");
            }
        }

        public static bool IsProtected(ushort index)
        {
            Phoneme_FieldIndex enu = (Phoneme_FieldIndex)index;
            switch (enu)
            {
                case Phoneme_FieldIndex.IY:
                case Phoneme_FieldIndex.IH:
                case Phoneme_FieldIndex.EH:
                case Phoneme_FieldIndex.EY:
                case Phoneme_FieldIndex.AE:
                case Phoneme_FieldIndex.AA:
                case Phoneme_FieldIndex.AW:
                case Phoneme_FieldIndex.AY:
                case Phoneme_FieldIndex.AH:
                case Phoneme_FieldIndex.AO:
                case Phoneme_FieldIndex.OY:
                case Phoneme_FieldIndex.OW:
                case Phoneme_FieldIndex.UH:
                case Phoneme_FieldIndex.UW:
                case Phoneme_FieldIndex.ER:
                case Phoneme_FieldIndex.AX:
                case Phoneme_FieldIndex.S:
                case Phoneme_FieldIndex.SH:
                case Phoneme_FieldIndex.Z:
                case Phoneme_FieldIndex.ZH:
                case Phoneme_FieldIndex.F:
                case Phoneme_FieldIndex.TH:
                case Phoneme_FieldIndex.V:
                case Phoneme_FieldIndex.DH:
                case Phoneme_FieldIndex.M:
                case Phoneme_FieldIndex.N:
                case Phoneme_FieldIndex.NG:
                case Phoneme_FieldIndex.L:
                case Phoneme_FieldIndex.R:
                case Phoneme_FieldIndex.W:
                case Phoneme_FieldIndex.Y:
                case Phoneme_FieldIndex.HH:
                case Phoneme_FieldIndex.B:
                case Phoneme_FieldIndex.D:
                case Phoneme_FieldIndex.JH:
                case Phoneme_FieldIndex.G:
                case Phoneme_FieldIndex.P:
                case Phoneme_FieldIndex.T:
                case Phoneme_FieldIndex.K:
                case Phoneme_FieldIndex.CH:
                case Phoneme_FieldIndex.SIL:
                case Phoneme_FieldIndex.SHOTSIL:
                case Phoneme_FieldIndex.FLAP:
                    return false;
                default:
                    throw new ArgumentException($"Index is out of range: {index}");
            }
        }

        public static Type GetNthType(ushort index)
        {
            Phoneme_FieldIndex enu = (Phoneme_FieldIndex)index;
            switch (enu)
            {
                case Phoneme_FieldIndex.IY:
                    return typeof(Single);
                case Phoneme_FieldIndex.IH:
                    return typeof(Single);
                case Phoneme_FieldIndex.EH:
                    return typeof(Single);
                case Phoneme_FieldIndex.EY:
                    return typeof(Single);
                case Phoneme_FieldIndex.AE:
                    return typeof(Single);
                case Phoneme_FieldIndex.AA:
                    return typeof(Single);
                case Phoneme_FieldIndex.AW:
                    return typeof(Single);
                case Phoneme_FieldIndex.AY:
                    return typeof(Single);
                case Phoneme_FieldIndex.AH:
                    return typeof(Single);
                case Phoneme_FieldIndex.AO:
                    return typeof(Single);
                case Phoneme_FieldIndex.OY:
                    return typeof(Single);
                case Phoneme_FieldIndex.OW:
                    return typeof(Single);
                case Phoneme_FieldIndex.UH:
                    return typeof(Single);
                case Phoneme_FieldIndex.UW:
                    return typeof(Single);
                case Phoneme_FieldIndex.ER:
                    return typeof(Single);
                case Phoneme_FieldIndex.AX:
                    return typeof(Single);
                case Phoneme_FieldIndex.S:
                    return typeof(Single);
                case Phoneme_FieldIndex.SH:
                    return typeof(Single);
                case Phoneme_FieldIndex.Z:
                    return typeof(Single);
                case Phoneme_FieldIndex.ZH:
                    return typeof(Single);
                case Phoneme_FieldIndex.F:
                    return typeof(Single);
                case Phoneme_FieldIndex.TH:
                    return typeof(Single);
                case Phoneme_FieldIndex.V:
                    return typeof(Single);
                case Phoneme_FieldIndex.DH:
                    return typeof(Single);
                case Phoneme_FieldIndex.M:
                    return typeof(Single);
                case Phoneme_FieldIndex.N:
                    return typeof(Single);
                case Phoneme_FieldIndex.NG:
                    return typeof(Single);
                case Phoneme_FieldIndex.L:
                    return typeof(Single);
                case Phoneme_FieldIndex.R:
                    return typeof(Single);
                case Phoneme_FieldIndex.W:
                    return typeof(Single);
                case Phoneme_FieldIndex.Y:
                    return typeof(Single);
                case Phoneme_FieldIndex.HH:
                    return typeof(Single);
                case Phoneme_FieldIndex.B:
                    return typeof(Single);
                case Phoneme_FieldIndex.D:
                    return typeof(Single);
                case Phoneme_FieldIndex.JH:
                    return typeof(Single);
                case Phoneme_FieldIndex.G:
                    return typeof(Single);
                case Phoneme_FieldIndex.P:
                    return typeof(Single);
                case Phoneme_FieldIndex.T:
                    return typeof(Single);
                case Phoneme_FieldIndex.K:
                    return typeof(Single);
                case Phoneme_FieldIndex.CH:
                    return typeof(Single);
                case Phoneme_FieldIndex.SIL:
                    return typeof(Single);
                case Phoneme_FieldIndex.SHOTSIL:
                    return typeof(Single);
                case Phoneme_FieldIndex.FLAP:
                    return typeof(Single);
                default:
                    throw new ArgumentException($"Index is out of range: {index}");
            }
        }

        public static readonly Type XmlWriteTranslation = typeof(PhonemeXmlWriteTranslation);
        public const int NumStructFields = 0;
        public const int NumTypedFields = 0;
        public static readonly Type BinaryWriteTranslation = typeof(PhonemeBinaryWriteTranslation);
        #region Interface
        ProtocolKey ILoquiRegistration.ProtocolKey => ProtocolKey;
        ObjectKey ILoquiRegistration.ObjectKey => ObjectKey;
        string ILoquiRegistration.GUID => GUID;
        ushort ILoquiRegistration.FieldCount => FieldCount;
        ushort ILoquiRegistration.AdditionalFieldCount => AdditionalFieldCount;
        Type ILoquiRegistration.MaskType => MaskType;
        Type ILoquiRegistration.ErrorMaskType => ErrorMaskType;
        Type ILoquiRegistration.ClassType => ClassType;
        Type ILoquiRegistration.SetterType => SetterType;
        Type? ILoquiRegistration.InternalSetterType => InternalSetterType;
        Type ILoquiRegistration.GetterType => GetterType;
        Type? ILoquiRegistration.InternalGetterType => InternalGetterType;
        string ILoquiRegistration.FullName => FullName;
        string ILoquiRegistration.Name => Name;
        string ILoquiRegistration.Namespace => Namespace;
        byte ILoquiRegistration.GenericCount => GenericCount;
        Type? ILoquiRegistration.GenericRegistrationType => GenericRegistrationType;
        ushort? ILoquiRegistration.GetNameIndex(StringCaseAgnostic name) => GetNameIndex(name);
        bool ILoquiRegistration.GetNthIsEnumerable(ushort index) => GetNthIsEnumerable(index);
        bool ILoquiRegistration.GetNthIsLoqui(ushort index) => GetNthIsLoqui(index);
        bool ILoquiRegistration.GetNthIsSingleton(ushort index) => GetNthIsSingleton(index);
        string ILoquiRegistration.GetNthName(ushort index) => GetNthName(index);
        bool ILoquiRegistration.IsNthDerivative(ushort index) => IsNthDerivative(index);
        bool ILoquiRegistration.IsProtected(ushort index) => IsProtected(index);
        Type ILoquiRegistration.GetNthType(ushort index) => GetNthType(index);
        #endregion

    }
    #endregion

    #region Common
    public partial class PhonemeSetterCommon
    {
        public static readonly PhonemeSetterCommon Instance = new PhonemeSetterCommon();

        partial void ClearPartial();
        
        public void Clear(IPhoneme item)
        {
            ClearPartial();
            item.IY = default;
            item.IH = default;
            item.EH = default;
            item.EY = default;
            item.AE = default;
            item.AA = default;
            item.AW = default;
            item.AY = default;
            item.AH = default;
            item.AO = default;
            item.OY = default;
            item.OW = default;
            item.UH = default;
            item.UW = default;
            item.ER = default;
            item.AX = default;
            item.S = default;
            item.SH = default;
            item.Z = default;
            item.ZH = default;
            item.F = default;
            item.TH = default;
            item.V = default;
            item.DH = default;
            item.M = default;
            item.N = default;
            item.NG = default;
            item.L = default;
            item.R = default;
            item.W = default;
            item.Y = default;
            item.HH = default;
            item.B = default;
            item.D = default;
            item.JH = default;
            item.G = default;
            item.P = default;
            item.T = default;
            item.K = default;
            item.CH = default;
            item.SIL = default;
            item.SHOTSIL = default;
            item.FLAP = default;
        }
        
        #region Xml Translation
        public virtual void CopyInFromXml(
            IPhoneme item,
            XElement node,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask)
        {
            try
            {
                foreach (var elem in node.Elements())
                {
                    PhonemeXmlCreateTranslation.FillPublicElementXml(
                        item: item,
                        node: elem,
                        name: elem.Name.LocalName,
                        errorMask: errorMask,
                        translationMask: translationMask);
                }
            }
            catch (Exception ex)
            when (errorMask != null)
            {
                errorMask.ReportException(ex);
            }
        }
        
        #endregion
        
        #region Binary Translation
        protected static void FillBinaryStructs(
            IPhoneme item,
            MutagenFrame frame)
        {
        }
        
        public virtual void CopyInFromBinary(
            IPhoneme item,
            MutagenFrame frame,
            RecordTypeConverter? recordTypeConverter = null)
        {
            UtilityTranslation.SubrecordParse(
                record: item,
                frame: frame,
                recordTypeConverter: recordTypeConverter,
                fillStructs: FillBinaryStructs);
        }
        
        #endregion
        
    }
    public partial class PhonemeCommon
    {
        public static readonly PhonemeCommon Instance = new PhonemeCommon();

        public Phoneme.Mask<bool> GetEqualsMask(
            IPhonemeGetter item,
            IPhonemeGetter rhs,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            var ret = new Phoneme.Mask<bool>(false);
            ((PhonemeCommon)((IPhonemeGetter)item).CommonInstance()!).FillEqualsMask(
                item: item,
                rhs: rhs,
                ret: ret,
                include: include);
            return ret;
        }
        
        public void FillEqualsMask(
            IPhonemeGetter item,
            IPhonemeGetter rhs,
            Phoneme.Mask<bool> ret,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            if (rhs == null) return;
            ret.IY = item.IY.EqualsWithin(rhs.IY);
            ret.IH = item.IH.EqualsWithin(rhs.IH);
            ret.EH = item.EH.EqualsWithin(rhs.EH);
            ret.EY = item.EY.EqualsWithin(rhs.EY);
            ret.AE = item.AE.EqualsWithin(rhs.AE);
            ret.AA = item.AA.EqualsWithin(rhs.AA);
            ret.AW = item.AW.EqualsWithin(rhs.AW);
            ret.AY = item.AY.EqualsWithin(rhs.AY);
            ret.AH = item.AH.EqualsWithin(rhs.AH);
            ret.AO = item.AO.EqualsWithin(rhs.AO);
            ret.OY = item.OY.EqualsWithin(rhs.OY);
            ret.OW = item.OW.EqualsWithin(rhs.OW);
            ret.UH = item.UH.EqualsWithin(rhs.UH);
            ret.UW = item.UW.EqualsWithin(rhs.UW);
            ret.ER = item.ER.EqualsWithin(rhs.ER);
            ret.AX = item.AX.EqualsWithin(rhs.AX);
            ret.S = item.S.EqualsWithin(rhs.S);
            ret.SH = item.SH.EqualsWithin(rhs.SH);
            ret.Z = item.Z.EqualsWithin(rhs.Z);
            ret.ZH = item.ZH.EqualsWithin(rhs.ZH);
            ret.F = item.F.EqualsWithin(rhs.F);
            ret.TH = item.TH.EqualsWithin(rhs.TH);
            ret.V = item.V.EqualsWithin(rhs.V);
            ret.DH = item.DH.EqualsWithin(rhs.DH);
            ret.M = item.M.EqualsWithin(rhs.M);
            ret.N = item.N.EqualsWithin(rhs.N);
            ret.NG = item.NG.EqualsWithin(rhs.NG);
            ret.L = item.L.EqualsWithin(rhs.L);
            ret.R = item.R.EqualsWithin(rhs.R);
            ret.W = item.W.EqualsWithin(rhs.W);
            ret.Y = item.Y.EqualsWithin(rhs.Y);
            ret.HH = item.HH.EqualsWithin(rhs.HH);
            ret.B = item.B.EqualsWithin(rhs.B);
            ret.D = item.D.EqualsWithin(rhs.D);
            ret.JH = item.JH.EqualsWithin(rhs.JH);
            ret.G = item.G.EqualsWithin(rhs.G);
            ret.P = item.P.EqualsWithin(rhs.P);
            ret.T = item.T.EqualsWithin(rhs.T);
            ret.K = item.K.EqualsWithin(rhs.K);
            ret.CH = item.CH.EqualsWithin(rhs.CH);
            ret.SIL = item.SIL.EqualsWithin(rhs.SIL);
            ret.SHOTSIL = item.SHOTSIL.EqualsWithin(rhs.SHOTSIL);
            ret.FLAP = item.FLAP.EqualsWithin(rhs.FLAP);
        }
        
        public string ToString(
            IPhonemeGetter item,
            string? name = null,
            Phoneme.Mask<bool>? printMask = null)
        {
            var fg = new FileGeneration();
            ToString(
                item: item,
                fg: fg,
                name: name,
                printMask: printMask);
            return fg.ToString();
        }
        
        public void ToString(
            IPhonemeGetter item,
            FileGeneration fg,
            string? name = null,
            Phoneme.Mask<bool>? printMask = null)
        {
            if (name == null)
            {
                fg.AppendLine($"Phoneme =>");
            }
            else
            {
                fg.AppendLine($"{name} (Phoneme) =>");
            }
            fg.AppendLine("[");
            using (new DepthWrapper(fg))
            {
                ToStringFields(
                    item: item,
                    fg: fg,
                    printMask: printMask);
            }
            fg.AppendLine("]");
        }
        
        protected static void ToStringFields(
            IPhonemeGetter item,
            FileGeneration fg,
            Phoneme.Mask<bool>? printMask = null)
        {
            if (printMask?.IY ?? true)
            {
                fg.AppendItem(item.IY, "IY");
            }
            if (printMask?.IH ?? true)
            {
                fg.AppendItem(item.IH, "IH");
            }
            if (printMask?.EH ?? true)
            {
                fg.AppendItem(item.EH, "EH");
            }
            if (printMask?.EY ?? true)
            {
                fg.AppendItem(item.EY, "EY");
            }
            if (printMask?.AE ?? true)
            {
                fg.AppendItem(item.AE, "AE");
            }
            if (printMask?.AA ?? true)
            {
                fg.AppendItem(item.AA, "AA");
            }
            if (printMask?.AW ?? true)
            {
                fg.AppendItem(item.AW, "AW");
            }
            if (printMask?.AY ?? true)
            {
                fg.AppendItem(item.AY, "AY");
            }
            if (printMask?.AH ?? true)
            {
                fg.AppendItem(item.AH, "AH");
            }
            if (printMask?.AO ?? true)
            {
                fg.AppendItem(item.AO, "AO");
            }
            if (printMask?.OY ?? true)
            {
                fg.AppendItem(item.OY, "OY");
            }
            if (printMask?.OW ?? true)
            {
                fg.AppendItem(item.OW, "OW");
            }
            if (printMask?.UH ?? true)
            {
                fg.AppendItem(item.UH, "UH");
            }
            if (printMask?.UW ?? true)
            {
                fg.AppendItem(item.UW, "UW");
            }
            if (printMask?.ER ?? true)
            {
                fg.AppendItem(item.ER, "ER");
            }
            if (printMask?.AX ?? true)
            {
                fg.AppendItem(item.AX, "AX");
            }
            if (printMask?.S ?? true)
            {
                fg.AppendItem(item.S, "S");
            }
            if (printMask?.SH ?? true)
            {
                fg.AppendItem(item.SH, "SH");
            }
            if (printMask?.Z ?? true)
            {
                fg.AppendItem(item.Z, "Z");
            }
            if (printMask?.ZH ?? true)
            {
                fg.AppendItem(item.ZH, "ZH");
            }
            if (printMask?.F ?? true)
            {
                fg.AppendItem(item.F, "F");
            }
            if (printMask?.TH ?? true)
            {
                fg.AppendItem(item.TH, "TH");
            }
            if (printMask?.V ?? true)
            {
                fg.AppendItem(item.V, "V");
            }
            if (printMask?.DH ?? true)
            {
                fg.AppendItem(item.DH, "DH");
            }
            if (printMask?.M ?? true)
            {
                fg.AppendItem(item.M, "M");
            }
            if (printMask?.N ?? true)
            {
                fg.AppendItem(item.N, "N");
            }
            if (printMask?.NG ?? true)
            {
                fg.AppendItem(item.NG, "NG");
            }
            if (printMask?.L ?? true)
            {
                fg.AppendItem(item.L, "L");
            }
            if (printMask?.R ?? true)
            {
                fg.AppendItem(item.R, "R");
            }
            if (printMask?.W ?? true)
            {
                fg.AppendItem(item.W, "W");
            }
            if (printMask?.Y ?? true)
            {
                fg.AppendItem(item.Y, "Y");
            }
            if (printMask?.HH ?? true)
            {
                fg.AppendItem(item.HH, "HH");
            }
            if (printMask?.B ?? true)
            {
                fg.AppendItem(item.B, "B");
            }
            if (printMask?.D ?? true)
            {
                fg.AppendItem(item.D, "D");
            }
            if (printMask?.JH ?? true)
            {
                fg.AppendItem(item.JH, "JH");
            }
            if (printMask?.G ?? true)
            {
                fg.AppendItem(item.G, "G");
            }
            if (printMask?.P ?? true)
            {
                fg.AppendItem(item.P, "P");
            }
            if (printMask?.T ?? true)
            {
                fg.AppendItem(item.T, "T");
            }
            if (printMask?.K ?? true)
            {
                fg.AppendItem(item.K, "K");
            }
            if (printMask?.CH ?? true)
            {
                fg.AppendItem(item.CH, "CH");
            }
            if (printMask?.SIL ?? true)
            {
                fg.AppendItem(item.SIL, "SIL");
            }
            if (printMask?.SHOTSIL ?? true)
            {
                fg.AppendItem(item.SHOTSIL, "SHOTSIL");
            }
            if (printMask?.FLAP ?? true)
            {
                fg.AppendItem(item.FLAP, "FLAP");
            }
        }
        
        public bool HasBeenSet(
            IPhonemeGetter item,
            Phoneme.Mask<bool?> checkMask)
        {
            return true;
        }
        
        public void FillHasBeenSetMask(
            IPhonemeGetter item,
            Phoneme.Mask<bool> mask)
        {
            mask.IY = true;
            mask.IH = true;
            mask.EH = true;
            mask.EY = true;
            mask.AE = true;
            mask.AA = true;
            mask.AW = true;
            mask.AY = true;
            mask.AH = true;
            mask.AO = true;
            mask.OY = true;
            mask.OW = true;
            mask.UH = true;
            mask.UW = true;
            mask.ER = true;
            mask.AX = true;
            mask.S = true;
            mask.SH = true;
            mask.Z = true;
            mask.ZH = true;
            mask.F = true;
            mask.TH = true;
            mask.V = true;
            mask.DH = true;
            mask.M = true;
            mask.N = true;
            mask.NG = true;
            mask.L = true;
            mask.R = true;
            mask.W = true;
            mask.Y = true;
            mask.HH = true;
            mask.B = true;
            mask.D = true;
            mask.JH = true;
            mask.G = true;
            mask.P = true;
            mask.T = true;
            mask.K = true;
            mask.CH = true;
            mask.SIL = true;
            mask.SHOTSIL = true;
            mask.FLAP = true;
        }
        
        #region Equals and Hash
        public virtual bool Equals(
            IPhonemeGetter? lhs,
            IPhonemeGetter? rhs)
        {
            if (lhs == null && rhs == null) return false;
            if (lhs == null || rhs == null) return false;
            if (!lhs.IY.EqualsWithin(rhs.IY)) return false;
            if (!lhs.IH.EqualsWithin(rhs.IH)) return false;
            if (!lhs.EH.EqualsWithin(rhs.EH)) return false;
            if (!lhs.EY.EqualsWithin(rhs.EY)) return false;
            if (!lhs.AE.EqualsWithin(rhs.AE)) return false;
            if (!lhs.AA.EqualsWithin(rhs.AA)) return false;
            if (!lhs.AW.EqualsWithin(rhs.AW)) return false;
            if (!lhs.AY.EqualsWithin(rhs.AY)) return false;
            if (!lhs.AH.EqualsWithin(rhs.AH)) return false;
            if (!lhs.AO.EqualsWithin(rhs.AO)) return false;
            if (!lhs.OY.EqualsWithin(rhs.OY)) return false;
            if (!lhs.OW.EqualsWithin(rhs.OW)) return false;
            if (!lhs.UH.EqualsWithin(rhs.UH)) return false;
            if (!lhs.UW.EqualsWithin(rhs.UW)) return false;
            if (!lhs.ER.EqualsWithin(rhs.ER)) return false;
            if (!lhs.AX.EqualsWithin(rhs.AX)) return false;
            if (!lhs.S.EqualsWithin(rhs.S)) return false;
            if (!lhs.SH.EqualsWithin(rhs.SH)) return false;
            if (!lhs.Z.EqualsWithin(rhs.Z)) return false;
            if (!lhs.ZH.EqualsWithin(rhs.ZH)) return false;
            if (!lhs.F.EqualsWithin(rhs.F)) return false;
            if (!lhs.TH.EqualsWithin(rhs.TH)) return false;
            if (!lhs.V.EqualsWithin(rhs.V)) return false;
            if (!lhs.DH.EqualsWithin(rhs.DH)) return false;
            if (!lhs.M.EqualsWithin(rhs.M)) return false;
            if (!lhs.N.EqualsWithin(rhs.N)) return false;
            if (!lhs.NG.EqualsWithin(rhs.NG)) return false;
            if (!lhs.L.EqualsWithin(rhs.L)) return false;
            if (!lhs.R.EqualsWithin(rhs.R)) return false;
            if (!lhs.W.EqualsWithin(rhs.W)) return false;
            if (!lhs.Y.EqualsWithin(rhs.Y)) return false;
            if (!lhs.HH.EqualsWithin(rhs.HH)) return false;
            if (!lhs.B.EqualsWithin(rhs.B)) return false;
            if (!lhs.D.EqualsWithin(rhs.D)) return false;
            if (!lhs.JH.EqualsWithin(rhs.JH)) return false;
            if (!lhs.G.EqualsWithin(rhs.G)) return false;
            if (!lhs.P.EqualsWithin(rhs.P)) return false;
            if (!lhs.T.EqualsWithin(rhs.T)) return false;
            if (!lhs.K.EqualsWithin(rhs.K)) return false;
            if (!lhs.CH.EqualsWithin(rhs.CH)) return false;
            if (!lhs.SIL.EqualsWithin(rhs.SIL)) return false;
            if (!lhs.SHOTSIL.EqualsWithin(rhs.SHOTSIL)) return false;
            if (!lhs.FLAP.EqualsWithin(rhs.FLAP)) return false;
            return true;
        }
        
        public virtual int GetHashCode(IPhonemeGetter item)
        {
            var hash = new HashCode();
            hash.Add(item.IY);
            hash.Add(item.IH);
            hash.Add(item.EH);
            hash.Add(item.EY);
            hash.Add(item.AE);
            hash.Add(item.AA);
            hash.Add(item.AW);
            hash.Add(item.AY);
            hash.Add(item.AH);
            hash.Add(item.AO);
            hash.Add(item.OY);
            hash.Add(item.OW);
            hash.Add(item.UH);
            hash.Add(item.UW);
            hash.Add(item.ER);
            hash.Add(item.AX);
            hash.Add(item.S);
            hash.Add(item.SH);
            hash.Add(item.Z);
            hash.Add(item.ZH);
            hash.Add(item.F);
            hash.Add(item.TH);
            hash.Add(item.V);
            hash.Add(item.DH);
            hash.Add(item.M);
            hash.Add(item.N);
            hash.Add(item.NG);
            hash.Add(item.L);
            hash.Add(item.R);
            hash.Add(item.W);
            hash.Add(item.Y);
            hash.Add(item.HH);
            hash.Add(item.B);
            hash.Add(item.D);
            hash.Add(item.JH);
            hash.Add(item.G);
            hash.Add(item.P);
            hash.Add(item.T);
            hash.Add(item.K);
            hash.Add(item.CH);
            hash.Add(item.SIL);
            hash.Add(item.SHOTSIL);
            hash.Add(item.FLAP);
            return hash.ToHashCode();
        }
        
        #endregion
        
        
        public object GetNew()
        {
            return Phoneme.GetNew();
        }
        
        #region Mutagen
        public IEnumerable<ILinkGetter> GetLinks(IPhonemeGetter obj)
        {
            yield break;
        }
        
        #endregion
        
    }
    public partial class PhonemeSetterTranslationCommon
    {
        public static readonly PhonemeSetterTranslationCommon Instance = new PhonemeSetterTranslationCommon();

        #region Deep Copy Fields From
        public void DeepCopyIn(
            IPhoneme item,
            IPhonemeGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask)
        {
            if ((copyMask?.GetShouldTranslate((int)Phoneme_FieldIndex.IY) ?? true))
            {
                item.IY = rhs.IY;
            }
            if ((copyMask?.GetShouldTranslate((int)Phoneme_FieldIndex.IH) ?? true))
            {
                item.IH = rhs.IH;
            }
            if ((copyMask?.GetShouldTranslate((int)Phoneme_FieldIndex.EH) ?? true))
            {
                item.EH = rhs.EH;
            }
            if ((copyMask?.GetShouldTranslate((int)Phoneme_FieldIndex.EY) ?? true))
            {
                item.EY = rhs.EY;
            }
            if ((copyMask?.GetShouldTranslate((int)Phoneme_FieldIndex.AE) ?? true))
            {
                item.AE = rhs.AE;
            }
            if ((copyMask?.GetShouldTranslate((int)Phoneme_FieldIndex.AA) ?? true))
            {
                item.AA = rhs.AA;
            }
            if ((copyMask?.GetShouldTranslate((int)Phoneme_FieldIndex.AW) ?? true))
            {
                item.AW = rhs.AW;
            }
            if ((copyMask?.GetShouldTranslate((int)Phoneme_FieldIndex.AY) ?? true))
            {
                item.AY = rhs.AY;
            }
            if ((copyMask?.GetShouldTranslate((int)Phoneme_FieldIndex.AH) ?? true))
            {
                item.AH = rhs.AH;
            }
            if ((copyMask?.GetShouldTranslate((int)Phoneme_FieldIndex.AO) ?? true))
            {
                item.AO = rhs.AO;
            }
            if ((copyMask?.GetShouldTranslate((int)Phoneme_FieldIndex.OY) ?? true))
            {
                item.OY = rhs.OY;
            }
            if ((copyMask?.GetShouldTranslate((int)Phoneme_FieldIndex.OW) ?? true))
            {
                item.OW = rhs.OW;
            }
            if ((copyMask?.GetShouldTranslate((int)Phoneme_FieldIndex.UH) ?? true))
            {
                item.UH = rhs.UH;
            }
            if ((copyMask?.GetShouldTranslate((int)Phoneme_FieldIndex.UW) ?? true))
            {
                item.UW = rhs.UW;
            }
            if ((copyMask?.GetShouldTranslate((int)Phoneme_FieldIndex.ER) ?? true))
            {
                item.ER = rhs.ER;
            }
            if ((copyMask?.GetShouldTranslate((int)Phoneme_FieldIndex.AX) ?? true))
            {
                item.AX = rhs.AX;
            }
            if ((copyMask?.GetShouldTranslate((int)Phoneme_FieldIndex.S) ?? true))
            {
                item.S = rhs.S;
            }
            if ((copyMask?.GetShouldTranslate((int)Phoneme_FieldIndex.SH) ?? true))
            {
                item.SH = rhs.SH;
            }
            if ((copyMask?.GetShouldTranslate((int)Phoneme_FieldIndex.Z) ?? true))
            {
                item.Z = rhs.Z;
            }
            if ((copyMask?.GetShouldTranslate((int)Phoneme_FieldIndex.ZH) ?? true))
            {
                item.ZH = rhs.ZH;
            }
            if ((copyMask?.GetShouldTranslate((int)Phoneme_FieldIndex.F) ?? true))
            {
                item.F = rhs.F;
            }
            if ((copyMask?.GetShouldTranslate((int)Phoneme_FieldIndex.TH) ?? true))
            {
                item.TH = rhs.TH;
            }
            if ((copyMask?.GetShouldTranslate((int)Phoneme_FieldIndex.V) ?? true))
            {
                item.V = rhs.V;
            }
            if ((copyMask?.GetShouldTranslate((int)Phoneme_FieldIndex.DH) ?? true))
            {
                item.DH = rhs.DH;
            }
            if ((copyMask?.GetShouldTranslate((int)Phoneme_FieldIndex.M) ?? true))
            {
                item.M = rhs.M;
            }
            if ((copyMask?.GetShouldTranslate((int)Phoneme_FieldIndex.N) ?? true))
            {
                item.N = rhs.N;
            }
            if ((copyMask?.GetShouldTranslate((int)Phoneme_FieldIndex.NG) ?? true))
            {
                item.NG = rhs.NG;
            }
            if ((copyMask?.GetShouldTranslate((int)Phoneme_FieldIndex.L) ?? true))
            {
                item.L = rhs.L;
            }
            if ((copyMask?.GetShouldTranslate((int)Phoneme_FieldIndex.R) ?? true))
            {
                item.R = rhs.R;
            }
            if ((copyMask?.GetShouldTranslate((int)Phoneme_FieldIndex.W) ?? true))
            {
                item.W = rhs.W;
            }
            if ((copyMask?.GetShouldTranslate((int)Phoneme_FieldIndex.Y) ?? true))
            {
                item.Y = rhs.Y;
            }
            if ((copyMask?.GetShouldTranslate((int)Phoneme_FieldIndex.HH) ?? true))
            {
                item.HH = rhs.HH;
            }
            if ((copyMask?.GetShouldTranslate((int)Phoneme_FieldIndex.B) ?? true))
            {
                item.B = rhs.B;
            }
            if ((copyMask?.GetShouldTranslate((int)Phoneme_FieldIndex.D) ?? true))
            {
                item.D = rhs.D;
            }
            if ((copyMask?.GetShouldTranslate((int)Phoneme_FieldIndex.JH) ?? true))
            {
                item.JH = rhs.JH;
            }
            if ((copyMask?.GetShouldTranslate((int)Phoneme_FieldIndex.G) ?? true))
            {
                item.G = rhs.G;
            }
            if ((copyMask?.GetShouldTranslate((int)Phoneme_FieldIndex.P) ?? true))
            {
                item.P = rhs.P;
            }
            if ((copyMask?.GetShouldTranslate((int)Phoneme_FieldIndex.T) ?? true))
            {
                item.T = rhs.T;
            }
            if ((copyMask?.GetShouldTranslate((int)Phoneme_FieldIndex.K) ?? true))
            {
                item.K = rhs.K;
            }
            if ((copyMask?.GetShouldTranslate((int)Phoneme_FieldIndex.CH) ?? true))
            {
                item.CH = rhs.CH;
            }
            if ((copyMask?.GetShouldTranslate((int)Phoneme_FieldIndex.SIL) ?? true))
            {
                item.SIL = rhs.SIL;
            }
            if ((copyMask?.GetShouldTranslate((int)Phoneme_FieldIndex.SHOTSIL) ?? true))
            {
                item.SHOTSIL = rhs.SHOTSIL;
            }
            if ((copyMask?.GetShouldTranslate((int)Phoneme_FieldIndex.FLAP) ?? true))
            {
                item.FLAP = rhs.FLAP;
            }
        }
        
        #endregion
        
        public Phoneme DeepCopy(
            IPhonemeGetter item,
            Phoneme.TranslationMask? copyMask = null)
        {
            Phoneme ret = (Phoneme)((PhonemeCommon)((IPhonemeGetter)item).CommonInstance()!).GetNew();
            ret.DeepCopyIn(
                item,
                copyMask: copyMask);
            return ret;
        }
        
        public Phoneme DeepCopy(
            IPhonemeGetter item,
            out Phoneme.ErrorMask errorMask,
            Phoneme.TranslationMask? copyMask = null)
        {
            Phoneme ret = (Phoneme)((PhonemeCommon)((IPhonemeGetter)item).CommonInstance()!).GetNew();
            ret.DeepCopyIn(
                item,
                errorMask: out errorMask,
                copyMask: copyMask);
            return ret;
        }
        
        public Phoneme DeepCopy(
            IPhonemeGetter item,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask = null)
        {
            Phoneme ret = (Phoneme)((PhonemeCommon)((IPhonemeGetter)item).CommonInstance()!).GetNew();
            ret.DeepCopyIn(
                item,
                errorMask: errorMask,
                copyMask: copyMask);
            return ret;
        }
        
    }
    #endregion

}

namespace Mutagen.Bethesda.Skyrim
{
    public partial class Phoneme
    {
        #region Common Routing
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILoquiRegistration ILoquiObject.Registration => Phoneme_Registration.Instance;
        public static Phoneme_Registration Registration => Phoneme_Registration.Instance;
        [DebuggerStepThrough]
        protected object CommonInstance() => PhonemeCommon.Instance;
        [DebuggerStepThrough]
        protected object CommonSetterInstance()
        {
            return PhonemeSetterCommon.Instance;
        }
        [DebuggerStepThrough]
        protected object CommonSetterTranslationInstance() => PhonemeSetterTranslationCommon.Instance;
        [DebuggerStepThrough]
        object IPhonemeGetter.CommonInstance() => this.CommonInstance();
        [DebuggerStepThrough]
        object IPhonemeGetter.CommonSetterInstance() => this.CommonSetterInstance();
        [DebuggerStepThrough]
        object IPhonemeGetter.CommonSetterTranslationInstance() => this.CommonSetterTranslationInstance();

        #endregion

    }
}

#region Modules
#region Xml Translation
namespace Mutagen.Bethesda.Skyrim.Internals
{
    public partial class PhonemeXmlWriteTranslation : IXmlWriteTranslator
    {
        public readonly static PhonemeXmlWriteTranslation Instance = new PhonemeXmlWriteTranslation();

        public static void WriteToNodeXml(
            IPhonemeGetter item,
            XElement node,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask)
        {
            if ((translationMask?.GetShouldTranslate((int)Phoneme_FieldIndex.IY) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.IY),
                    item: item.IY,
                    fieldIndex: (int)Phoneme_FieldIndex.IY,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)Phoneme_FieldIndex.IH) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.IH),
                    item: item.IH,
                    fieldIndex: (int)Phoneme_FieldIndex.IH,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)Phoneme_FieldIndex.EH) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.EH),
                    item: item.EH,
                    fieldIndex: (int)Phoneme_FieldIndex.EH,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)Phoneme_FieldIndex.EY) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.EY),
                    item: item.EY,
                    fieldIndex: (int)Phoneme_FieldIndex.EY,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)Phoneme_FieldIndex.AE) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.AE),
                    item: item.AE,
                    fieldIndex: (int)Phoneme_FieldIndex.AE,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)Phoneme_FieldIndex.AA) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.AA),
                    item: item.AA,
                    fieldIndex: (int)Phoneme_FieldIndex.AA,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)Phoneme_FieldIndex.AW) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.AW),
                    item: item.AW,
                    fieldIndex: (int)Phoneme_FieldIndex.AW,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)Phoneme_FieldIndex.AY) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.AY),
                    item: item.AY,
                    fieldIndex: (int)Phoneme_FieldIndex.AY,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)Phoneme_FieldIndex.AH) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.AH),
                    item: item.AH,
                    fieldIndex: (int)Phoneme_FieldIndex.AH,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)Phoneme_FieldIndex.AO) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.AO),
                    item: item.AO,
                    fieldIndex: (int)Phoneme_FieldIndex.AO,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)Phoneme_FieldIndex.OY) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.OY),
                    item: item.OY,
                    fieldIndex: (int)Phoneme_FieldIndex.OY,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)Phoneme_FieldIndex.OW) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.OW),
                    item: item.OW,
                    fieldIndex: (int)Phoneme_FieldIndex.OW,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)Phoneme_FieldIndex.UH) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.UH),
                    item: item.UH,
                    fieldIndex: (int)Phoneme_FieldIndex.UH,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)Phoneme_FieldIndex.UW) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.UW),
                    item: item.UW,
                    fieldIndex: (int)Phoneme_FieldIndex.UW,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)Phoneme_FieldIndex.ER) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.ER),
                    item: item.ER,
                    fieldIndex: (int)Phoneme_FieldIndex.ER,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)Phoneme_FieldIndex.AX) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.AX),
                    item: item.AX,
                    fieldIndex: (int)Phoneme_FieldIndex.AX,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)Phoneme_FieldIndex.S) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.S),
                    item: item.S,
                    fieldIndex: (int)Phoneme_FieldIndex.S,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)Phoneme_FieldIndex.SH) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.SH),
                    item: item.SH,
                    fieldIndex: (int)Phoneme_FieldIndex.SH,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)Phoneme_FieldIndex.Z) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.Z),
                    item: item.Z,
                    fieldIndex: (int)Phoneme_FieldIndex.Z,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)Phoneme_FieldIndex.ZH) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.ZH),
                    item: item.ZH,
                    fieldIndex: (int)Phoneme_FieldIndex.ZH,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)Phoneme_FieldIndex.F) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.F),
                    item: item.F,
                    fieldIndex: (int)Phoneme_FieldIndex.F,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)Phoneme_FieldIndex.TH) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.TH),
                    item: item.TH,
                    fieldIndex: (int)Phoneme_FieldIndex.TH,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)Phoneme_FieldIndex.V) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.V),
                    item: item.V,
                    fieldIndex: (int)Phoneme_FieldIndex.V,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)Phoneme_FieldIndex.DH) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.DH),
                    item: item.DH,
                    fieldIndex: (int)Phoneme_FieldIndex.DH,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)Phoneme_FieldIndex.M) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.M),
                    item: item.M,
                    fieldIndex: (int)Phoneme_FieldIndex.M,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)Phoneme_FieldIndex.N) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.N),
                    item: item.N,
                    fieldIndex: (int)Phoneme_FieldIndex.N,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)Phoneme_FieldIndex.NG) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.NG),
                    item: item.NG,
                    fieldIndex: (int)Phoneme_FieldIndex.NG,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)Phoneme_FieldIndex.L) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.L),
                    item: item.L,
                    fieldIndex: (int)Phoneme_FieldIndex.L,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)Phoneme_FieldIndex.R) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.R),
                    item: item.R,
                    fieldIndex: (int)Phoneme_FieldIndex.R,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)Phoneme_FieldIndex.W) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.W),
                    item: item.W,
                    fieldIndex: (int)Phoneme_FieldIndex.W,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)Phoneme_FieldIndex.Y) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.Y),
                    item: item.Y,
                    fieldIndex: (int)Phoneme_FieldIndex.Y,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)Phoneme_FieldIndex.HH) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.HH),
                    item: item.HH,
                    fieldIndex: (int)Phoneme_FieldIndex.HH,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)Phoneme_FieldIndex.B) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.B),
                    item: item.B,
                    fieldIndex: (int)Phoneme_FieldIndex.B,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)Phoneme_FieldIndex.D) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.D),
                    item: item.D,
                    fieldIndex: (int)Phoneme_FieldIndex.D,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)Phoneme_FieldIndex.JH) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.JH),
                    item: item.JH,
                    fieldIndex: (int)Phoneme_FieldIndex.JH,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)Phoneme_FieldIndex.G) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.G),
                    item: item.G,
                    fieldIndex: (int)Phoneme_FieldIndex.G,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)Phoneme_FieldIndex.P) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.P),
                    item: item.P,
                    fieldIndex: (int)Phoneme_FieldIndex.P,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)Phoneme_FieldIndex.T) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.T),
                    item: item.T,
                    fieldIndex: (int)Phoneme_FieldIndex.T,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)Phoneme_FieldIndex.K) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.K),
                    item: item.K,
                    fieldIndex: (int)Phoneme_FieldIndex.K,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)Phoneme_FieldIndex.CH) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.CH),
                    item: item.CH,
                    fieldIndex: (int)Phoneme_FieldIndex.CH,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)Phoneme_FieldIndex.SIL) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.SIL),
                    item: item.SIL,
                    fieldIndex: (int)Phoneme_FieldIndex.SIL,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)Phoneme_FieldIndex.SHOTSIL) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.SHOTSIL),
                    item: item.SHOTSIL,
                    fieldIndex: (int)Phoneme_FieldIndex.SHOTSIL,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)Phoneme_FieldIndex.FLAP) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.FLAP),
                    item: item.FLAP,
                    fieldIndex: (int)Phoneme_FieldIndex.FLAP,
                    errorMask: errorMask);
            }
        }

        public void Write(
            XElement node,
            IPhonemeGetter item,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask,
            string? name = null)
        {
            var elem = new XElement(name ?? "Mutagen.Bethesda.Skyrim.Phoneme");
            node.Add(elem);
            if (name != null)
            {
                elem.SetAttributeValue("type", "Mutagen.Bethesda.Skyrim.Phoneme");
            }
            WriteToNodeXml(
                item: item,
                node: elem,
                errorMask: errorMask,
                translationMask: translationMask);
        }

        public void Write(
            XElement node,
            object item,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask,
            string? name = null)
        {
            Write(
                item: (IPhonemeGetter)item,
                name: name,
                node: node,
                errorMask: errorMask,
                translationMask: translationMask);
        }

        public void Write(
            XElement node,
            IPhonemeGetter item,
            ErrorMaskBuilder? errorMask,
            int fieldIndex,
            TranslationCrystal? translationMask,
            string? name = null)
        {
            errorMask?.PushIndex(fieldIndex);
            try
            {
                Write(
                    item: (IPhonemeGetter)item,
                    name: name,
                    node: node,
                    errorMask: errorMask,
                    translationMask: translationMask);
            }
            catch (Exception ex)
            when (errorMask != null)
            {
                errorMask.ReportException(ex);
            }
            finally
            {
                errorMask?.PopIndex();
            }
        }

    }

    public partial class PhonemeXmlCreateTranslation
    {
        public readonly static PhonemeXmlCreateTranslation Instance = new PhonemeXmlCreateTranslation();

        public static void FillPublicXml(
            IPhoneme item,
            XElement node,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask)
        {
            try
            {
                foreach (var elem in node.Elements())
                {
                    PhonemeXmlCreateTranslation.FillPublicElementXml(
                        item: item,
                        node: elem,
                        name: elem.Name.LocalName,
                        errorMask: errorMask,
                        translationMask: translationMask);
                }
            }
            catch (Exception ex)
            when (errorMask != null)
            {
                errorMask.ReportException(ex);
            }
        }

        public static void FillPublicElementXml(
            IPhoneme item,
            XElement node,
            string name,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask)
        {
            switch (name)
            {
                case "IY":
                    errorMask?.PushIndex((int)Phoneme_FieldIndex.IY);
                    try
                    {
                        item.IY = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "IH":
                    errorMask?.PushIndex((int)Phoneme_FieldIndex.IH);
                    try
                    {
                        item.IH = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "EH":
                    errorMask?.PushIndex((int)Phoneme_FieldIndex.EH);
                    try
                    {
                        item.EH = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "EY":
                    errorMask?.PushIndex((int)Phoneme_FieldIndex.EY);
                    try
                    {
                        item.EY = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "AE":
                    errorMask?.PushIndex((int)Phoneme_FieldIndex.AE);
                    try
                    {
                        item.AE = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "AA":
                    errorMask?.PushIndex((int)Phoneme_FieldIndex.AA);
                    try
                    {
                        item.AA = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "AW":
                    errorMask?.PushIndex((int)Phoneme_FieldIndex.AW);
                    try
                    {
                        item.AW = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "AY":
                    errorMask?.PushIndex((int)Phoneme_FieldIndex.AY);
                    try
                    {
                        item.AY = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "AH":
                    errorMask?.PushIndex((int)Phoneme_FieldIndex.AH);
                    try
                    {
                        item.AH = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "AO":
                    errorMask?.PushIndex((int)Phoneme_FieldIndex.AO);
                    try
                    {
                        item.AO = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "OY":
                    errorMask?.PushIndex((int)Phoneme_FieldIndex.OY);
                    try
                    {
                        item.OY = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "OW":
                    errorMask?.PushIndex((int)Phoneme_FieldIndex.OW);
                    try
                    {
                        item.OW = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "UH":
                    errorMask?.PushIndex((int)Phoneme_FieldIndex.UH);
                    try
                    {
                        item.UH = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "UW":
                    errorMask?.PushIndex((int)Phoneme_FieldIndex.UW);
                    try
                    {
                        item.UW = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "ER":
                    errorMask?.PushIndex((int)Phoneme_FieldIndex.ER);
                    try
                    {
                        item.ER = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "AX":
                    errorMask?.PushIndex((int)Phoneme_FieldIndex.AX);
                    try
                    {
                        item.AX = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "S":
                    errorMask?.PushIndex((int)Phoneme_FieldIndex.S);
                    try
                    {
                        item.S = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "SH":
                    errorMask?.PushIndex((int)Phoneme_FieldIndex.SH);
                    try
                    {
                        item.SH = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "Z":
                    errorMask?.PushIndex((int)Phoneme_FieldIndex.Z);
                    try
                    {
                        item.Z = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "ZH":
                    errorMask?.PushIndex((int)Phoneme_FieldIndex.ZH);
                    try
                    {
                        item.ZH = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "F":
                    errorMask?.PushIndex((int)Phoneme_FieldIndex.F);
                    try
                    {
                        item.F = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "TH":
                    errorMask?.PushIndex((int)Phoneme_FieldIndex.TH);
                    try
                    {
                        item.TH = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "V":
                    errorMask?.PushIndex((int)Phoneme_FieldIndex.V);
                    try
                    {
                        item.V = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "DH":
                    errorMask?.PushIndex((int)Phoneme_FieldIndex.DH);
                    try
                    {
                        item.DH = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "M":
                    errorMask?.PushIndex((int)Phoneme_FieldIndex.M);
                    try
                    {
                        item.M = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "N":
                    errorMask?.PushIndex((int)Phoneme_FieldIndex.N);
                    try
                    {
                        item.N = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "NG":
                    errorMask?.PushIndex((int)Phoneme_FieldIndex.NG);
                    try
                    {
                        item.NG = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "L":
                    errorMask?.PushIndex((int)Phoneme_FieldIndex.L);
                    try
                    {
                        item.L = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "R":
                    errorMask?.PushIndex((int)Phoneme_FieldIndex.R);
                    try
                    {
                        item.R = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "W":
                    errorMask?.PushIndex((int)Phoneme_FieldIndex.W);
                    try
                    {
                        item.W = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "Y":
                    errorMask?.PushIndex((int)Phoneme_FieldIndex.Y);
                    try
                    {
                        item.Y = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "HH":
                    errorMask?.PushIndex((int)Phoneme_FieldIndex.HH);
                    try
                    {
                        item.HH = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "B":
                    errorMask?.PushIndex((int)Phoneme_FieldIndex.B);
                    try
                    {
                        item.B = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "D":
                    errorMask?.PushIndex((int)Phoneme_FieldIndex.D);
                    try
                    {
                        item.D = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "JH":
                    errorMask?.PushIndex((int)Phoneme_FieldIndex.JH);
                    try
                    {
                        item.JH = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "G":
                    errorMask?.PushIndex((int)Phoneme_FieldIndex.G);
                    try
                    {
                        item.G = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "P":
                    errorMask?.PushIndex((int)Phoneme_FieldIndex.P);
                    try
                    {
                        item.P = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "T":
                    errorMask?.PushIndex((int)Phoneme_FieldIndex.T);
                    try
                    {
                        item.T = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "K":
                    errorMask?.PushIndex((int)Phoneme_FieldIndex.K);
                    try
                    {
                        item.K = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "CH":
                    errorMask?.PushIndex((int)Phoneme_FieldIndex.CH);
                    try
                    {
                        item.CH = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "SIL":
                    errorMask?.PushIndex((int)Phoneme_FieldIndex.SIL);
                    try
                    {
                        item.SIL = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "SHOTSIL":
                    errorMask?.PushIndex((int)Phoneme_FieldIndex.SHOTSIL);
                    try
                    {
                        item.SHOTSIL = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "FLAP":
                    errorMask?.PushIndex((int)Phoneme_FieldIndex.FLAP);
                    try
                    {
                        item.FLAP = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                default:
                    break;
            }
        }

    }

}
namespace Mutagen.Bethesda.Skyrim
{
    #region Xml Write Mixins
    public static class PhonemeXmlTranslationMixIn
    {
        public static void WriteToXml(
            this IPhonemeGetter item,
            XElement node,
            out Phoneme.ErrorMask errorMask,
            Phoneme.TranslationMask? translationMask = null,
            string? name = null)
        {
            ErrorMaskBuilder errorMaskBuilder = new ErrorMaskBuilder();
            ((PhonemeXmlWriteTranslation)item.XmlWriteTranslator).Write(
                item: item,
                name: name,
                node: node,
                errorMask: errorMaskBuilder,
                translationMask: translationMask?.GetCrystal());
            errorMask = Phoneme.ErrorMask.Factory(errorMaskBuilder);
        }

        public static void WriteToXml(
            this IPhonemeGetter item,
            string path,
            out Phoneme.ErrorMask errorMask,
            Phoneme.TranslationMask? translationMask = null,
            string? name = null)
        {
            var node = new XElement("topnode");
            WriteToXml(
                item: item,
                name: name,
                node: node,
                errorMask: out errorMask,
                translationMask: translationMask);
            node.Elements().First().SaveIfChanged(path);
        }

        public static void WriteToXml(
            this IPhonemeGetter item,
            string path,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask = null,
            string? name = null)
        {
            var node = new XElement("topnode");
            WriteToXml(
                item: item,
                name: name,
                node: node,
                errorMask: errorMask,
                translationMask: translationMask);
            node.Elements().First().SaveIfChanged(path);
        }

        public static void WriteToXml(
            this IPhonemeGetter item,
            Stream stream,
            out Phoneme.ErrorMask errorMask,
            Phoneme.TranslationMask? translationMask = null,
            string? name = null)
        {
            var node = new XElement("topnode");
            WriteToXml(
                item: item,
                name: name,
                node: node,
                errorMask: out errorMask,
                translationMask: translationMask);
            node.Elements().First().Save(stream);
        }

        public static void WriteToXml(
            this IPhonemeGetter item,
            Stream stream,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask = null,
            string? name = null)
        {
            var node = new XElement("topnode");
            WriteToXml(
                item: item,
                name: name,
                node: node,
                errorMask: errorMask,
                translationMask: translationMask);
            node.Elements().First().Save(stream);
        }

        public static void WriteToXml(
            this IPhonemeGetter item,
            XElement node,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask = null,
            string? name = null)
        {
            ((PhonemeXmlWriteTranslation)item.XmlWriteTranslator).Write(
                item: item,
                name: name,
                node: node,
                errorMask: errorMask,
                translationMask: translationMask);
        }

        public static void WriteToXml(
            this IPhonemeGetter item,
            XElement node,
            string? name = null,
            Phoneme.TranslationMask? translationMask = null)
        {
            ((PhonemeXmlWriteTranslation)item.XmlWriteTranslator).Write(
                item: item,
                name: name,
                node: node,
                errorMask: null,
                translationMask: translationMask?.GetCrystal());
        }

        public static void WriteToXml(
            this IPhonemeGetter item,
            string path,
            string? name = null)
        {
            var node = new XElement("topnode");
            ((PhonemeXmlWriteTranslation)item.XmlWriteTranslator).Write(
                item: item,
                name: name,
                node: node,
                errorMask: null,
                translationMask: null);
            node.Elements().First().SaveIfChanged(path);
        }

        public static void WriteToXml(
            this IPhonemeGetter item,
            Stream stream,
            string? name = null)
        {
            var node = new XElement("topnode");
            ((PhonemeXmlWriteTranslation)item.XmlWriteTranslator).Write(
                item: item,
                name: name,
                node: node,
                errorMask: null,
                translationMask: null);
            node.Elements().First().Save(stream);
        }

    }
    #endregion


}
#endregion

#region Binary Translation
namespace Mutagen.Bethesda.Skyrim.Internals
{
    public partial class PhonemeBinaryWriteTranslation : IBinaryWriteTranslator
    {
        public readonly static PhonemeBinaryWriteTranslation Instance = new PhonemeBinaryWriteTranslation();

        public static void WriteEmbedded(
            IPhonemeGetter item,
            MutagenWriter writer)
        {
        }

        public void Write(
            MutagenWriter writer,
            IPhonemeGetter item,
            RecordTypeConverter? recordTypeConverter = null)
        {
            WriteEmbedded(
                item: item,
                writer: writer);
        }

        public void Write(
            MutagenWriter writer,
            object item,
            RecordTypeConverter? recordTypeConverter = null)
        {
            Write(
                item: (IPhonemeGetter)item,
                writer: writer,
                recordTypeConverter: recordTypeConverter);
        }

    }

    public partial class PhonemeBinaryCreateTranslation
    {
        public readonly static PhonemeBinaryCreateTranslation Instance = new PhonemeBinaryCreateTranslation();

    }

}
namespace Mutagen.Bethesda.Skyrim
{
    #region Binary Write Mixins
    public static class PhonemeBinaryTranslationMixIn
    {
        public static void WriteToBinary(
            this IPhonemeGetter item,
            MutagenWriter writer)
        {
            ((PhonemeBinaryWriteTranslation)item.BinaryWriteTranslator).Write(
                item: item,
                writer: writer,
                recordTypeConverter: null);
        }

    }
    #endregion


}
namespace Mutagen.Bethesda.Skyrim.Internals
{
    public partial class PhonemeBinaryOverlay :
        BinaryOverlay,
        IPhonemeGetter
    {
        #region Common Routing
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILoquiRegistration ILoquiObject.Registration => Phoneme_Registration.Instance;
        public static Phoneme_Registration Registration => Phoneme_Registration.Instance;
        [DebuggerStepThrough]
        protected object CommonInstance() => PhonemeCommon.Instance;
        [DebuggerStepThrough]
        protected object CommonSetterTranslationInstance() => PhonemeSetterTranslationCommon.Instance;
        [DebuggerStepThrough]
        object IPhonemeGetter.CommonInstance() => this.CommonInstance();
        [DebuggerStepThrough]
        object? IPhonemeGetter.CommonSetterInstance() => null;
        [DebuggerStepThrough]
        object IPhonemeGetter.CommonSetterTranslationInstance() => this.CommonSetterTranslationInstance();

        #endregion

        void IPrintable.ToString(FileGeneration fg, string? name) => this.ToString(fg, name);
        IMask<bool> ILoquiObjectGetter.GetHasBeenSetIMask() => this.GetHasBeenSetMask();
        IMask<bool> IEqualsMask.GetEqualsIMask(object rhs, EqualsMaskHelper.Include include) => this.GetEqualsMask((IPhonemeGetter)rhs, include);

        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected object XmlWriteTranslator => PhonemeXmlWriteTranslation.Instance;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        object IXmlItem.XmlWriteTranslator => this.XmlWriteTranslator;
        void IXmlItem.WriteToXml(
            XElement node,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask,
            string? name = null)
        {
            ((PhonemeXmlWriteTranslation)this.XmlWriteTranslator).Write(
                item: this,
                name: name,
                node: node,
                errorMask: errorMask,
                translationMask: translationMask);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected object BinaryWriteTranslator => PhonemeBinaryWriteTranslation.Instance;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        object IBinaryItem.BinaryWriteTranslator => this.BinaryWriteTranslator;
        void IBinaryItem.WriteToBinary(
            MutagenWriter writer,
            RecordTypeConverter? recordTypeConverter = null)
        {
            ((PhonemeBinaryWriteTranslation)this.BinaryWriteTranslator).Write(
                item: this,
                writer: writer,
                recordTypeConverter: recordTypeConverter);
        }

        partial void CustomCtor(
            IBinaryReadStream stream,
            int finalPos,
            int offset);

        protected PhonemeBinaryOverlay(
            ReadOnlyMemorySlice<byte> bytes,
            BinaryOverlayFactoryPackage package)
            : base(
                bytes: bytes,
                package: package)
        {
        }

        public static PhonemeBinaryOverlay PhonemeFactory(
            BinaryMemoryReadStream stream,
            BinaryOverlayFactoryPackage package,
            RecordTypeConverter? recordTypeConverter = null)
        {
            var ret = new PhonemeBinaryOverlay(
                bytes: stream.RemainingMemory.Slice(0, 0x0),
                package: package);
            int offset = stream.Position;
            stream.Position += 0x0;
            ret.CustomCtor(
                stream: stream,
                finalPos: stream.Length,
                offset: offset);
            return ret;
        }

        public static PhonemeBinaryOverlay PhonemeFactory(
            ReadOnlyMemorySlice<byte> slice,
            BinaryOverlayFactoryPackage package,
            RecordTypeConverter? recordTypeConverter = null)
        {
            return PhonemeFactory(
                stream: new BinaryMemoryReadStream(slice),
                package: package,
                recordTypeConverter: recordTypeConverter);
        }

        #region To String

        public void ToString(
            FileGeneration fg,
            string? name = null)
        {
            PhonemeMixIn.ToString(
                item: this,
                name: name);
        }

        #endregion

    }

}
#endregion

#endregion

