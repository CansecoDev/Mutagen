/*
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
 * Autogenerated by Loqui.  Do not manually change.
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
*/
#region Usings
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Loqui;
using Loqui.Internal;
using Noggog;
using Mutagen.Bethesda.Skyrim.Internals;
using System.Reactive.Disposables;
using System.Reactive.Linq;
using System.Xml;
using System.Xml.Linq;
using System.IO;
using Noggog.Xml;
using Loqui.Xml;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using Mutagen.Bethesda.Binary;
using System.Buffers.Binary;
using Mutagen.Bethesda.Internals;
#endregion

#nullable enable
namespace Mutagen.Bethesda.Skyrim
{
    #region Class
    public partial class WeaponData :
        IWeaponData,
        ILoquiObjectSetter<WeaponData>,
        IEquatable<WeaponData>,
        IEqualsMask
    {
        #region Ctor
        public WeaponData()
        {
            CustomCtor();
        }
        partial void CustomCtor();
        #endregion

        #region AnimationType
        public WeaponAnimationType AnimationType { get; set; } = default;
        #endregion
        #region Unused
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private Byte[] _Unused = new byte[3];
        public Byte[] Unused
        {
            get => _Unused;
            set => this._Unused = value;
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ReadOnlyMemorySlice<Byte> IWeaponDataGetter.Unused => this.Unused;
        #endregion
        #region Speed
        public Single Speed { get; set; } = default;
        #endregion
        #region Reach
        public Single Reach { get; set; } = default;
        #endregion
        #region Flags
        public WeaponData.Flag Flags { get; set; } = default;
        #endregion
        #region Unused2
        public Int16 Unused2 { get; set; } = default;
        #endregion
        #region SightFOV
        public Single SightFOV { get; set; } = default;
        #endregion
        #region Unknown
        public Int32 Unknown { get; set; } = default;
        #endregion
        #region BaseVATStoHitChance
        public Byte BaseVATStoHitChance { get; set; } = default;
        #endregion
        #region AttackAnimation
        public readonly static WeaponData.AttackAnimationType _AttackAnimation_Default = WeaponData.AttackAnimationType.Default;
        public WeaponData.AttackAnimationType AttackAnimation { get; set; } = default;
        #endregion
        #region NumProjectiles
        public Byte NumProjectiles { get; set; } = default;
        #endregion
        #region EmbeddedWeaponAV
        public Byte EmbeddedWeaponAV { get; set; } = default;
        #endregion
        #region RangeMin
        public Single RangeMin { get; set; } = default;
        #endregion
        #region RangeMax
        public Single RangeMax { get; set; } = default;
        #endregion
        #region OnHit
        public WeaponData.OnHitType OnHit { get; set; } = default;
        #endregion
        #region AnimationAttackMult
        public Single AnimationAttackMult { get; set; } = default;
        #endregion
        #region Unknown2
        public Int32 Unknown2 { get; set; } = default;
        #endregion
        #region RumbleLeftMotorStrength
        public Single RumbleLeftMotorStrength { get; set; } = default;
        #endregion
        #region RumbleRightMotorStrength
        public Single RumbleRightMotorStrength { get; set; } = default;
        #endregion
        #region RumbleDuration
        public Single RumbleDuration { get; set; } = default;
        #endregion
        #region Unknown3
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private Byte[] _Unknown3 = new byte[12];
        public Byte[] Unknown3
        {
            get => _Unknown3;
            set => this._Unknown3 = value;
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ReadOnlyMemorySlice<Byte> IWeaponDataGetter.Unknown3 => this.Unknown3;
        #endregion
        #region Skill
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private Skill? _Skill;
        public Skill? Skill
        {
            get => this._Skill;
            set => this._Skill = value;
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Skill? IWeaponDataGetter.Skill => this.Skill;
        #endregion
        #region Unknown4
        public Int64 Unknown4 { get; set; } = default;
        #endregion
        #region Resist
        public readonly static ActorValueExtended _Resist_Default = ActorValueExtended.None;
        public ActorValueExtended Resist { get; set; } = default;
        #endregion
        #region Unknown5
        public Int32 Unknown5 { get; set; } = default;
        #endregion
        #region Stagger
        public Single Stagger { get; set; } = default;
        #endregion

        #region To String

        public void ToString(
            FileGeneration fg,
            string? name = null)
        {
            WeaponDataMixIn.ToString(
                item: this,
                name: name);
        }

        #endregion

        #region Equals and Hash
        public override bool Equals(object? obj)
        {
            if (!(obj is IWeaponDataGetter rhs)) return false;
            return ((WeaponDataCommon)((IWeaponDataGetter)this).CommonInstance()!).Equals(this, rhs);
        }

        public bool Equals(WeaponData obj)
        {
            return ((WeaponDataCommon)((IWeaponDataGetter)this).CommonInstance()!).Equals(this, obj);
        }

        public override int GetHashCode() => ((WeaponDataCommon)((IWeaponDataGetter)this).CommonInstance()!).GetHashCode(this);

        #endregion

        #region Xml Translation
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected object XmlWriteTranslator => WeaponDataXmlWriteTranslation.Instance;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        object IXmlItem.XmlWriteTranslator => this.XmlWriteTranslator;
        void IXmlItem.WriteToXml(
            XElement node,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask,
            string? name = null)
        {
            ((WeaponDataXmlWriteTranslation)this.XmlWriteTranslator).Write(
                item: this,
                name: name,
                node: node,
                errorMask: errorMask,
                translationMask: translationMask);
        }
        #region Xml Create
        [DebuggerStepThrough]
        public static WeaponData CreateFromXml(
            XElement node,
            WeaponData.TranslationMask? translationMask = null)
        {
            return CreateFromXml(
                node: node,
                errorMask: null,
                translationMask: translationMask?.GetCrystal());
        }

        [DebuggerStepThrough]
        public static WeaponData CreateFromXml(
            XElement node,
            out WeaponData.ErrorMask errorMask,
            WeaponData.TranslationMask? translationMask = null)
        {
            ErrorMaskBuilder errorMaskBuilder = new ErrorMaskBuilder();
            var ret = CreateFromXml(
                node: node,
                errorMask: errorMaskBuilder,
                translationMask: translationMask?.GetCrystal());
            errorMask = WeaponData.ErrorMask.Factory(errorMaskBuilder);
            return ret;
        }

        public static WeaponData CreateFromXml(
            XElement node,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask)
        {
            var ret = new WeaponData();
            ((WeaponDataSetterCommon)((IWeaponDataGetter)ret).CommonSetterInstance()!).CopyInFromXml(
                item: ret,
                node: node,
                errorMask: errorMask,
                translationMask: translationMask);
            return ret;
        }

        public static WeaponData CreateFromXml(
            string path,
            WeaponData.TranslationMask? translationMask = null)
        {
            var node = XDocument.Load(path).Root;
            return CreateFromXml(
                node: node,
                translationMask: translationMask);
        }

        public static WeaponData CreateFromXml(
            string path,
            out WeaponData.ErrorMask errorMask,
            WeaponData.TranslationMask? translationMask = null)
        {
            var node = XDocument.Load(path).Root;
            return CreateFromXml(
                node: node,
                errorMask: out errorMask,
                translationMask: translationMask);
        }

        public static WeaponData CreateFromXml(
            string path,
            ErrorMaskBuilder? errorMask,
            WeaponData.TranslationMask? translationMask = null)
        {
            var node = XDocument.Load(path).Root;
            return CreateFromXml(
                node: node,
                errorMask: errorMask,
                translationMask: translationMask?.GetCrystal());
        }

        public static WeaponData CreateFromXml(
            Stream stream,
            WeaponData.TranslationMask? translationMask = null)
        {
            var node = XDocument.Load(stream).Root;
            return CreateFromXml(
                node: node,
                translationMask: translationMask);
        }

        public static WeaponData CreateFromXml(
            Stream stream,
            out WeaponData.ErrorMask errorMask,
            WeaponData.TranslationMask? translationMask = null)
        {
            var node = XDocument.Load(stream).Root;
            return CreateFromXml(
                node: node,
                errorMask: out errorMask,
                translationMask: translationMask);
        }

        public static WeaponData CreateFromXml(
            Stream stream,
            ErrorMaskBuilder? errorMask,
            WeaponData.TranslationMask? translationMask = null)
        {
            var node = XDocument.Load(stream).Root;
            return CreateFromXml(
                node: node,
                errorMask: errorMask,
                translationMask: translationMask?.GetCrystal());
        }

        #endregion

        #endregion

        #region Mask
        public class Mask<TItem> :
            IMask<TItem>,
            IEquatable<Mask<TItem>>
            where TItem : notnull
        {
            #region Ctors
            public Mask(TItem initialValue)
            {
                this.AnimationType = initialValue;
                this.Unused = initialValue;
                this.Speed = initialValue;
                this.Reach = initialValue;
                this.Flags = initialValue;
                this.Unused2 = initialValue;
                this.SightFOV = initialValue;
                this.Unknown = initialValue;
                this.BaseVATStoHitChance = initialValue;
                this.AttackAnimation = initialValue;
                this.NumProjectiles = initialValue;
                this.EmbeddedWeaponAV = initialValue;
                this.RangeMin = initialValue;
                this.RangeMax = initialValue;
                this.OnHit = initialValue;
                this.AnimationAttackMult = initialValue;
                this.Unknown2 = initialValue;
                this.RumbleLeftMotorStrength = initialValue;
                this.RumbleRightMotorStrength = initialValue;
                this.RumbleDuration = initialValue;
                this.Unknown3 = initialValue;
                this.Skill = initialValue;
                this.Unknown4 = initialValue;
                this.Resist = initialValue;
                this.Unknown5 = initialValue;
                this.Stagger = initialValue;
            }

            public Mask(
                TItem AnimationType,
                TItem Unused,
                TItem Speed,
                TItem Reach,
                TItem Flags,
                TItem Unused2,
                TItem SightFOV,
                TItem Unknown,
                TItem BaseVATStoHitChance,
                TItem AttackAnimation,
                TItem NumProjectiles,
                TItem EmbeddedWeaponAV,
                TItem RangeMin,
                TItem RangeMax,
                TItem OnHit,
                TItem AnimationAttackMult,
                TItem Unknown2,
                TItem RumbleLeftMotorStrength,
                TItem RumbleRightMotorStrength,
                TItem RumbleDuration,
                TItem Unknown3,
                TItem Skill,
                TItem Unknown4,
                TItem Resist,
                TItem Unknown5,
                TItem Stagger)
            {
                this.AnimationType = AnimationType;
                this.Unused = Unused;
                this.Speed = Speed;
                this.Reach = Reach;
                this.Flags = Flags;
                this.Unused2 = Unused2;
                this.SightFOV = SightFOV;
                this.Unknown = Unknown;
                this.BaseVATStoHitChance = BaseVATStoHitChance;
                this.AttackAnimation = AttackAnimation;
                this.NumProjectiles = NumProjectiles;
                this.EmbeddedWeaponAV = EmbeddedWeaponAV;
                this.RangeMin = RangeMin;
                this.RangeMax = RangeMax;
                this.OnHit = OnHit;
                this.AnimationAttackMult = AnimationAttackMult;
                this.Unknown2 = Unknown2;
                this.RumbleLeftMotorStrength = RumbleLeftMotorStrength;
                this.RumbleRightMotorStrength = RumbleRightMotorStrength;
                this.RumbleDuration = RumbleDuration;
                this.Unknown3 = Unknown3;
                this.Skill = Skill;
                this.Unknown4 = Unknown4;
                this.Resist = Resist;
                this.Unknown5 = Unknown5;
                this.Stagger = Stagger;
            }

            #pragma warning disable CS8618
            protected Mask()
            {
            }
            #pragma warning restore CS8618

            #endregion

            #region Members
            public TItem AnimationType;
            public TItem Unused;
            public TItem Speed;
            public TItem Reach;
            public TItem Flags;
            public TItem Unused2;
            public TItem SightFOV;
            public TItem Unknown;
            public TItem BaseVATStoHitChance;
            public TItem AttackAnimation;
            public TItem NumProjectiles;
            public TItem EmbeddedWeaponAV;
            public TItem RangeMin;
            public TItem RangeMax;
            public TItem OnHit;
            public TItem AnimationAttackMult;
            public TItem Unknown2;
            public TItem RumbleLeftMotorStrength;
            public TItem RumbleRightMotorStrength;
            public TItem RumbleDuration;
            public TItem Unknown3;
            public TItem Skill;
            public TItem Unknown4;
            public TItem Resist;
            public TItem Unknown5;
            public TItem Stagger;
            #endregion

            #region Equals
            public override bool Equals(object? obj)
            {
                if (!(obj is Mask<TItem> rhs)) return false;
                return Equals(rhs);
            }

            public bool Equals(Mask<TItem> rhs)
            {
                if (rhs == null) return false;
                if (!object.Equals(this.AnimationType, rhs.AnimationType)) return false;
                if (!object.Equals(this.Unused, rhs.Unused)) return false;
                if (!object.Equals(this.Speed, rhs.Speed)) return false;
                if (!object.Equals(this.Reach, rhs.Reach)) return false;
                if (!object.Equals(this.Flags, rhs.Flags)) return false;
                if (!object.Equals(this.Unused2, rhs.Unused2)) return false;
                if (!object.Equals(this.SightFOV, rhs.SightFOV)) return false;
                if (!object.Equals(this.Unknown, rhs.Unknown)) return false;
                if (!object.Equals(this.BaseVATStoHitChance, rhs.BaseVATStoHitChance)) return false;
                if (!object.Equals(this.AttackAnimation, rhs.AttackAnimation)) return false;
                if (!object.Equals(this.NumProjectiles, rhs.NumProjectiles)) return false;
                if (!object.Equals(this.EmbeddedWeaponAV, rhs.EmbeddedWeaponAV)) return false;
                if (!object.Equals(this.RangeMin, rhs.RangeMin)) return false;
                if (!object.Equals(this.RangeMax, rhs.RangeMax)) return false;
                if (!object.Equals(this.OnHit, rhs.OnHit)) return false;
                if (!object.Equals(this.AnimationAttackMult, rhs.AnimationAttackMult)) return false;
                if (!object.Equals(this.Unknown2, rhs.Unknown2)) return false;
                if (!object.Equals(this.RumbleLeftMotorStrength, rhs.RumbleLeftMotorStrength)) return false;
                if (!object.Equals(this.RumbleRightMotorStrength, rhs.RumbleRightMotorStrength)) return false;
                if (!object.Equals(this.RumbleDuration, rhs.RumbleDuration)) return false;
                if (!object.Equals(this.Unknown3, rhs.Unknown3)) return false;
                if (!object.Equals(this.Skill, rhs.Skill)) return false;
                if (!object.Equals(this.Unknown4, rhs.Unknown4)) return false;
                if (!object.Equals(this.Resist, rhs.Resist)) return false;
                if (!object.Equals(this.Unknown5, rhs.Unknown5)) return false;
                if (!object.Equals(this.Stagger, rhs.Stagger)) return false;
                return true;
            }
            public override int GetHashCode()
            {
                var hash = new HashCode();
                hash.Add(this.AnimationType);
                hash.Add(this.Unused);
                hash.Add(this.Speed);
                hash.Add(this.Reach);
                hash.Add(this.Flags);
                hash.Add(this.Unused2);
                hash.Add(this.SightFOV);
                hash.Add(this.Unknown);
                hash.Add(this.BaseVATStoHitChance);
                hash.Add(this.AttackAnimation);
                hash.Add(this.NumProjectiles);
                hash.Add(this.EmbeddedWeaponAV);
                hash.Add(this.RangeMin);
                hash.Add(this.RangeMax);
                hash.Add(this.OnHit);
                hash.Add(this.AnimationAttackMult);
                hash.Add(this.Unknown2);
                hash.Add(this.RumbleLeftMotorStrength);
                hash.Add(this.RumbleRightMotorStrength);
                hash.Add(this.RumbleDuration);
                hash.Add(this.Unknown3);
                hash.Add(this.Skill);
                hash.Add(this.Unknown4);
                hash.Add(this.Resist);
                hash.Add(this.Unknown5);
                hash.Add(this.Stagger);
                return hash.ToHashCode();
            }

            #endregion

            #region All
            public bool All(Func<TItem, bool> eval)
            {
                if (!eval(this.AnimationType)) return false;
                if (!eval(this.Unused)) return false;
                if (!eval(this.Speed)) return false;
                if (!eval(this.Reach)) return false;
                if (!eval(this.Flags)) return false;
                if (!eval(this.Unused2)) return false;
                if (!eval(this.SightFOV)) return false;
                if (!eval(this.Unknown)) return false;
                if (!eval(this.BaseVATStoHitChance)) return false;
                if (!eval(this.AttackAnimation)) return false;
                if (!eval(this.NumProjectiles)) return false;
                if (!eval(this.EmbeddedWeaponAV)) return false;
                if (!eval(this.RangeMin)) return false;
                if (!eval(this.RangeMax)) return false;
                if (!eval(this.OnHit)) return false;
                if (!eval(this.AnimationAttackMult)) return false;
                if (!eval(this.Unknown2)) return false;
                if (!eval(this.RumbleLeftMotorStrength)) return false;
                if (!eval(this.RumbleRightMotorStrength)) return false;
                if (!eval(this.RumbleDuration)) return false;
                if (!eval(this.Unknown3)) return false;
                if (!eval(this.Skill)) return false;
                if (!eval(this.Unknown4)) return false;
                if (!eval(this.Resist)) return false;
                if (!eval(this.Unknown5)) return false;
                if (!eval(this.Stagger)) return false;
                return true;
            }
            #endregion

            #region Any
            public bool Any(Func<TItem, bool> eval)
            {
                if (eval(this.AnimationType)) return true;
                if (eval(this.Unused)) return true;
                if (eval(this.Speed)) return true;
                if (eval(this.Reach)) return true;
                if (eval(this.Flags)) return true;
                if (eval(this.Unused2)) return true;
                if (eval(this.SightFOV)) return true;
                if (eval(this.Unknown)) return true;
                if (eval(this.BaseVATStoHitChance)) return true;
                if (eval(this.AttackAnimation)) return true;
                if (eval(this.NumProjectiles)) return true;
                if (eval(this.EmbeddedWeaponAV)) return true;
                if (eval(this.RangeMin)) return true;
                if (eval(this.RangeMax)) return true;
                if (eval(this.OnHit)) return true;
                if (eval(this.AnimationAttackMult)) return true;
                if (eval(this.Unknown2)) return true;
                if (eval(this.RumbleLeftMotorStrength)) return true;
                if (eval(this.RumbleRightMotorStrength)) return true;
                if (eval(this.RumbleDuration)) return true;
                if (eval(this.Unknown3)) return true;
                if (eval(this.Skill)) return true;
                if (eval(this.Unknown4)) return true;
                if (eval(this.Resist)) return true;
                if (eval(this.Unknown5)) return true;
                if (eval(this.Stagger)) return true;
                return false;
            }
            #endregion

            #region Translate
            public Mask<R> Translate<R>(Func<TItem, R> eval)
            {
                var ret = new WeaponData.Mask<R>();
                this.Translate_InternalFill(ret, eval);
                return ret;
            }

            protected void Translate_InternalFill<R>(Mask<R> obj, Func<TItem, R> eval)
            {
                obj.AnimationType = eval(this.AnimationType);
                obj.Unused = eval(this.Unused);
                obj.Speed = eval(this.Speed);
                obj.Reach = eval(this.Reach);
                obj.Flags = eval(this.Flags);
                obj.Unused2 = eval(this.Unused2);
                obj.SightFOV = eval(this.SightFOV);
                obj.Unknown = eval(this.Unknown);
                obj.BaseVATStoHitChance = eval(this.BaseVATStoHitChance);
                obj.AttackAnimation = eval(this.AttackAnimation);
                obj.NumProjectiles = eval(this.NumProjectiles);
                obj.EmbeddedWeaponAV = eval(this.EmbeddedWeaponAV);
                obj.RangeMin = eval(this.RangeMin);
                obj.RangeMax = eval(this.RangeMax);
                obj.OnHit = eval(this.OnHit);
                obj.AnimationAttackMult = eval(this.AnimationAttackMult);
                obj.Unknown2 = eval(this.Unknown2);
                obj.RumbleLeftMotorStrength = eval(this.RumbleLeftMotorStrength);
                obj.RumbleRightMotorStrength = eval(this.RumbleRightMotorStrength);
                obj.RumbleDuration = eval(this.RumbleDuration);
                obj.Unknown3 = eval(this.Unknown3);
                obj.Skill = eval(this.Skill);
                obj.Unknown4 = eval(this.Unknown4);
                obj.Resist = eval(this.Resist);
                obj.Unknown5 = eval(this.Unknown5);
                obj.Stagger = eval(this.Stagger);
            }
            #endregion

            #region To String
            public override string ToString()
            {
                return ToString(printMask: null);
            }

            public string ToString(WeaponData.Mask<bool>? printMask = null)
            {
                var fg = new FileGeneration();
                ToString(fg, printMask);
                return fg.ToString();
            }

            public void ToString(FileGeneration fg, WeaponData.Mask<bool>? printMask = null)
            {
                fg.AppendLine($"{nameof(WeaponData.Mask<TItem>)} =>");
                fg.AppendLine("[");
                using (new DepthWrapper(fg))
                {
                    if (printMask?.AnimationType ?? true)
                    {
                        fg.AppendItem(AnimationType, "AnimationType");
                    }
                    if (printMask?.Unused ?? true)
                    {
                        fg.AppendItem(Unused, "Unused");
                    }
                    if (printMask?.Speed ?? true)
                    {
                        fg.AppendItem(Speed, "Speed");
                    }
                    if (printMask?.Reach ?? true)
                    {
                        fg.AppendItem(Reach, "Reach");
                    }
                    if (printMask?.Flags ?? true)
                    {
                        fg.AppendItem(Flags, "Flags");
                    }
                    if (printMask?.Unused2 ?? true)
                    {
                        fg.AppendItem(Unused2, "Unused2");
                    }
                    if (printMask?.SightFOV ?? true)
                    {
                        fg.AppendItem(SightFOV, "SightFOV");
                    }
                    if (printMask?.Unknown ?? true)
                    {
                        fg.AppendItem(Unknown, "Unknown");
                    }
                    if (printMask?.BaseVATStoHitChance ?? true)
                    {
                        fg.AppendItem(BaseVATStoHitChance, "BaseVATStoHitChance");
                    }
                    if (printMask?.AttackAnimation ?? true)
                    {
                        fg.AppendItem(AttackAnimation, "AttackAnimation");
                    }
                    if (printMask?.NumProjectiles ?? true)
                    {
                        fg.AppendItem(NumProjectiles, "NumProjectiles");
                    }
                    if (printMask?.EmbeddedWeaponAV ?? true)
                    {
                        fg.AppendItem(EmbeddedWeaponAV, "EmbeddedWeaponAV");
                    }
                    if (printMask?.RangeMin ?? true)
                    {
                        fg.AppendItem(RangeMin, "RangeMin");
                    }
                    if (printMask?.RangeMax ?? true)
                    {
                        fg.AppendItem(RangeMax, "RangeMax");
                    }
                    if (printMask?.OnHit ?? true)
                    {
                        fg.AppendItem(OnHit, "OnHit");
                    }
                    if (printMask?.AnimationAttackMult ?? true)
                    {
                        fg.AppendItem(AnimationAttackMult, "AnimationAttackMult");
                    }
                    if (printMask?.Unknown2 ?? true)
                    {
                        fg.AppendItem(Unknown2, "Unknown2");
                    }
                    if (printMask?.RumbleLeftMotorStrength ?? true)
                    {
                        fg.AppendItem(RumbleLeftMotorStrength, "RumbleLeftMotorStrength");
                    }
                    if (printMask?.RumbleRightMotorStrength ?? true)
                    {
                        fg.AppendItem(RumbleRightMotorStrength, "RumbleRightMotorStrength");
                    }
                    if (printMask?.RumbleDuration ?? true)
                    {
                        fg.AppendItem(RumbleDuration, "RumbleDuration");
                    }
                    if (printMask?.Unknown3 ?? true)
                    {
                        fg.AppendItem(Unknown3, "Unknown3");
                    }
                    if (printMask?.Skill ?? true)
                    {
                        fg.AppendItem(Skill, "Skill");
                    }
                    if (printMask?.Unknown4 ?? true)
                    {
                        fg.AppendItem(Unknown4, "Unknown4");
                    }
                    if (printMask?.Resist ?? true)
                    {
                        fg.AppendItem(Resist, "Resist");
                    }
                    if (printMask?.Unknown5 ?? true)
                    {
                        fg.AppendItem(Unknown5, "Unknown5");
                    }
                    if (printMask?.Stagger ?? true)
                    {
                        fg.AppendItem(Stagger, "Stagger");
                    }
                }
                fg.AppendLine("]");
            }
            #endregion

        }

        public class ErrorMask :
            IErrorMask,
            IErrorMask<ErrorMask>
        {
            #region Members
            public Exception? Overall { get; set; }
            private List<string>? _warnings;
            public List<string> Warnings
            {
                get
                {
                    if (_warnings == null)
                    {
                        _warnings = new List<string>();
                    }
                    return _warnings;
                }
            }
            public Exception? AnimationType;
            public Exception? Unused;
            public Exception? Speed;
            public Exception? Reach;
            public Exception? Flags;
            public Exception? Unused2;
            public Exception? SightFOV;
            public Exception? Unknown;
            public Exception? BaseVATStoHitChance;
            public Exception? AttackAnimation;
            public Exception? NumProjectiles;
            public Exception? EmbeddedWeaponAV;
            public Exception? RangeMin;
            public Exception? RangeMax;
            public Exception? OnHit;
            public Exception? AnimationAttackMult;
            public Exception? Unknown2;
            public Exception? RumbleLeftMotorStrength;
            public Exception? RumbleRightMotorStrength;
            public Exception? RumbleDuration;
            public Exception? Unknown3;
            public Exception? Skill;
            public Exception? Unknown4;
            public Exception? Resist;
            public Exception? Unknown5;
            public Exception? Stagger;
            #endregion

            #region IErrorMask
            public object? GetNthMask(int index)
            {
                WeaponData_FieldIndex enu = (WeaponData_FieldIndex)index;
                switch (enu)
                {
                    case WeaponData_FieldIndex.AnimationType:
                        return AnimationType;
                    case WeaponData_FieldIndex.Unused:
                        return Unused;
                    case WeaponData_FieldIndex.Speed:
                        return Speed;
                    case WeaponData_FieldIndex.Reach:
                        return Reach;
                    case WeaponData_FieldIndex.Flags:
                        return Flags;
                    case WeaponData_FieldIndex.Unused2:
                        return Unused2;
                    case WeaponData_FieldIndex.SightFOV:
                        return SightFOV;
                    case WeaponData_FieldIndex.Unknown:
                        return Unknown;
                    case WeaponData_FieldIndex.BaseVATStoHitChance:
                        return BaseVATStoHitChance;
                    case WeaponData_FieldIndex.AttackAnimation:
                        return AttackAnimation;
                    case WeaponData_FieldIndex.NumProjectiles:
                        return NumProjectiles;
                    case WeaponData_FieldIndex.EmbeddedWeaponAV:
                        return EmbeddedWeaponAV;
                    case WeaponData_FieldIndex.RangeMin:
                        return RangeMin;
                    case WeaponData_FieldIndex.RangeMax:
                        return RangeMax;
                    case WeaponData_FieldIndex.OnHit:
                        return OnHit;
                    case WeaponData_FieldIndex.AnimationAttackMult:
                        return AnimationAttackMult;
                    case WeaponData_FieldIndex.Unknown2:
                        return Unknown2;
                    case WeaponData_FieldIndex.RumbleLeftMotorStrength:
                        return RumbleLeftMotorStrength;
                    case WeaponData_FieldIndex.RumbleRightMotorStrength:
                        return RumbleRightMotorStrength;
                    case WeaponData_FieldIndex.RumbleDuration:
                        return RumbleDuration;
                    case WeaponData_FieldIndex.Unknown3:
                        return Unknown3;
                    case WeaponData_FieldIndex.Skill:
                        return Skill;
                    case WeaponData_FieldIndex.Unknown4:
                        return Unknown4;
                    case WeaponData_FieldIndex.Resist:
                        return Resist;
                    case WeaponData_FieldIndex.Unknown5:
                        return Unknown5;
                    case WeaponData_FieldIndex.Stagger:
                        return Stagger;
                    default:
                        throw new ArgumentException($"Index is out of range: {index}");
                }
            }

            public void SetNthException(int index, Exception ex)
            {
                WeaponData_FieldIndex enu = (WeaponData_FieldIndex)index;
                switch (enu)
                {
                    case WeaponData_FieldIndex.AnimationType:
                        this.AnimationType = ex;
                        break;
                    case WeaponData_FieldIndex.Unused:
                        this.Unused = ex;
                        break;
                    case WeaponData_FieldIndex.Speed:
                        this.Speed = ex;
                        break;
                    case WeaponData_FieldIndex.Reach:
                        this.Reach = ex;
                        break;
                    case WeaponData_FieldIndex.Flags:
                        this.Flags = ex;
                        break;
                    case WeaponData_FieldIndex.Unused2:
                        this.Unused2 = ex;
                        break;
                    case WeaponData_FieldIndex.SightFOV:
                        this.SightFOV = ex;
                        break;
                    case WeaponData_FieldIndex.Unknown:
                        this.Unknown = ex;
                        break;
                    case WeaponData_FieldIndex.BaseVATStoHitChance:
                        this.BaseVATStoHitChance = ex;
                        break;
                    case WeaponData_FieldIndex.AttackAnimation:
                        this.AttackAnimation = ex;
                        break;
                    case WeaponData_FieldIndex.NumProjectiles:
                        this.NumProjectiles = ex;
                        break;
                    case WeaponData_FieldIndex.EmbeddedWeaponAV:
                        this.EmbeddedWeaponAV = ex;
                        break;
                    case WeaponData_FieldIndex.RangeMin:
                        this.RangeMin = ex;
                        break;
                    case WeaponData_FieldIndex.RangeMax:
                        this.RangeMax = ex;
                        break;
                    case WeaponData_FieldIndex.OnHit:
                        this.OnHit = ex;
                        break;
                    case WeaponData_FieldIndex.AnimationAttackMult:
                        this.AnimationAttackMult = ex;
                        break;
                    case WeaponData_FieldIndex.Unknown2:
                        this.Unknown2 = ex;
                        break;
                    case WeaponData_FieldIndex.RumbleLeftMotorStrength:
                        this.RumbleLeftMotorStrength = ex;
                        break;
                    case WeaponData_FieldIndex.RumbleRightMotorStrength:
                        this.RumbleRightMotorStrength = ex;
                        break;
                    case WeaponData_FieldIndex.RumbleDuration:
                        this.RumbleDuration = ex;
                        break;
                    case WeaponData_FieldIndex.Unknown3:
                        this.Unknown3 = ex;
                        break;
                    case WeaponData_FieldIndex.Skill:
                        this.Skill = ex;
                        break;
                    case WeaponData_FieldIndex.Unknown4:
                        this.Unknown4 = ex;
                        break;
                    case WeaponData_FieldIndex.Resist:
                        this.Resist = ex;
                        break;
                    case WeaponData_FieldIndex.Unknown5:
                        this.Unknown5 = ex;
                        break;
                    case WeaponData_FieldIndex.Stagger:
                        this.Stagger = ex;
                        break;
                    default:
                        throw new ArgumentException($"Index is out of range: {index}");
                }
            }

            public void SetNthMask(int index, object obj)
            {
                WeaponData_FieldIndex enu = (WeaponData_FieldIndex)index;
                switch (enu)
                {
                    case WeaponData_FieldIndex.AnimationType:
                        this.AnimationType = (Exception?)obj;
                        break;
                    case WeaponData_FieldIndex.Unused:
                        this.Unused = (Exception?)obj;
                        break;
                    case WeaponData_FieldIndex.Speed:
                        this.Speed = (Exception?)obj;
                        break;
                    case WeaponData_FieldIndex.Reach:
                        this.Reach = (Exception?)obj;
                        break;
                    case WeaponData_FieldIndex.Flags:
                        this.Flags = (Exception?)obj;
                        break;
                    case WeaponData_FieldIndex.Unused2:
                        this.Unused2 = (Exception?)obj;
                        break;
                    case WeaponData_FieldIndex.SightFOV:
                        this.SightFOV = (Exception?)obj;
                        break;
                    case WeaponData_FieldIndex.Unknown:
                        this.Unknown = (Exception?)obj;
                        break;
                    case WeaponData_FieldIndex.BaseVATStoHitChance:
                        this.BaseVATStoHitChance = (Exception?)obj;
                        break;
                    case WeaponData_FieldIndex.AttackAnimation:
                        this.AttackAnimation = (Exception?)obj;
                        break;
                    case WeaponData_FieldIndex.NumProjectiles:
                        this.NumProjectiles = (Exception?)obj;
                        break;
                    case WeaponData_FieldIndex.EmbeddedWeaponAV:
                        this.EmbeddedWeaponAV = (Exception?)obj;
                        break;
                    case WeaponData_FieldIndex.RangeMin:
                        this.RangeMin = (Exception?)obj;
                        break;
                    case WeaponData_FieldIndex.RangeMax:
                        this.RangeMax = (Exception?)obj;
                        break;
                    case WeaponData_FieldIndex.OnHit:
                        this.OnHit = (Exception?)obj;
                        break;
                    case WeaponData_FieldIndex.AnimationAttackMult:
                        this.AnimationAttackMult = (Exception?)obj;
                        break;
                    case WeaponData_FieldIndex.Unknown2:
                        this.Unknown2 = (Exception?)obj;
                        break;
                    case WeaponData_FieldIndex.RumbleLeftMotorStrength:
                        this.RumbleLeftMotorStrength = (Exception?)obj;
                        break;
                    case WeaponData_FieldIndex.RumbleRightMotorStrength:
                        this.RumbleRightMotorStrength = (Exception?)obj;
                        break;
                    case WeaponData_FieldIndex.RumbleDuration:
                        this.RumbleDuration = (Exception?)obj;
                        break;
                    case WeaponData_FieldIndex.Unknown3:
                        this.Unknown3 = (Exception?)obj;
                        break;
                    case WeaponData_FieldIndex.Skill:
                        this.Skill = (Exception?)obj;
                        break;
                    case WeaponData_FieldIndex.Unknown4:
                        this.Unknown4 = (Exception?)obj;
                        break;
                    case WeaponData_FieldIndex.Resist:
                        this.Resist = (Exception?)obj;
                        break;
                    case WeaponData_FieldIndex.Unknown5:
                        this.Unknown5 = (Exception?)obj;
                        break;
                    case WeaponData_FieldIndex.Stagger:
                        this.Stagger = (Exception?)obj;
                        break;
                    default:
                        throw new ArgumentException($"Index is out of range: {index}");
                }
            }

            public bool IsInError()
            {
                if (Overall != null) return true;
                if (AnimationType != null) return true;
                if (Unused != null) return true;
                if (Speed != null) return true;
                if (Reach != null) return true;
                if (Flags != null) return true;
                if (Unused2 != null) return true;
                if (SightFOV != null) return true;
                if (Unknown != null) return true;
                if (BaseVATStoHitChance != null) return true;
                if (AttackAnimation != null) return true;
                if (NumProjectiles != null) return true;
                if (EmbeddedWeaponAV != null) return true;
                if (RangeMin != null) return true;
                if (RangeMax != null) return true;
                if (OnHit != null) return true;
                if (AnimationAttackMult != null) return true;
                if (Unknown2 != null) return true;
                if (RumbleLeftMotorStrength != null) return true;
                if (RumbleRightMotorStrength != null) return true;
                if (RumbleDuration != null) return true;
                if (Unknown3 != null) return true;
                if (Skill != null) return true;
                if (Unknown4 != null) return true;
                if (Resist != null) return true;
                if (Unknown5 != null) return true;
                if (Stagger != null) return true;
                return false;
            }
            #endregion

            #region To String
            public override string ToString()
            {
                var fg = new FileGeneration();
                ToString(fg, null);
                return fg.ToString();
            }

            public void ToString(FileGeneration fg, string? name = null)
            {
                fg.AppendLine($"{(name ?? "ErrorMask")} =>");
                fg.AppendLine("[");
                using (new DepthWrapper(fg))
                {
                    if (this.Overall != null)
                    {
                        fg.AppendLine("Overall =>");
                        fg.AppendLine("[");
                        using (new DepthWrapper(fg))
                        {
                            fg.AppendLine($"{this.Overall}");
                        }
                        fg.AppendLine("]");
                    }
                    ToString_FillInternal(fg);
                }
                fg.AppendLine("]");
            }
            protected void ToString_FillInternal(FileGeneration fg)
            {
                fg.AppendItem(AnimationType, "AnimationType");
                fg.AppendItem(Unused, "Unused");
                fg.AppendItem(Speed, "Speed");
                fg.AppendItem(Reach, "Reach");
                fg.AppendItem(Flags, "Flags");
                fg.AppendItem(Unused2, "Unused2");
                fg.AppendItem(SightFOV, "SightFOV");
                fg.AppendItem(Unknown, "Unknown");
                fg.AppendItem(BaseVATStoHitChance, "BaseVATStoHitChance");
                fg.AppendItem(AttackAnimation, "AttackAnimation");
                fg.AppendItem(NumProjectiles, "NumProjectiles");
                fg.AppendItem(EmbeddedWeaponAV, "EmbeddedWeaponAV");
                fg.AppendItem(RangeMin, "RangeMin");
                fg.AppendItem(RangeMax, "RangeMax");
                fg.AppendItem(OnHit, "OnHit");
                fg.AppendItem(AnimationAttackMult, "AnimationAttackMult");
                fg.AppendItem(Unknown2, "Unknown2");
                fg.AppendItem(RumbleLeftMotorStrength, "RumbleLeftMotorStrength");
                fg.AppendItem(RumbleRightMotorStrength, "RumbleRightMotorStrength");
                fg.AppendItem(RumbleDuration, "RumbleDuration");
                fg.AppendItem(Unknown3, "Unknown3");
                fg.AppendItem(Skill, "Skill");
                fg.AppendItem(Unknown4, "Unknown4");
                fg.AppendItem(Resist, "Resist");
                fg.AppendItem(Unknown5, "Unknown5");
                fg.AppendItem(Stagger, "Stagger");
            }
            #endregion

            #region Combine
            public ErrorMask Combine(ErrorMask? rhs)
            {
                if (rhs == null) return this;
                var ret = new ErrorMask();
                ret.AnimationType = this.AnimationType.Combine(rhs.AnimationType);
                ret.Unused = this.Unused.Combine(rhs.Unused);
                ret.Speed = this.Speed.Combine(rhs.Speed);
                ret.Reach = this.Reach.Combine(rhs.Reach);
                ret.Flags = this.Flags.Combine(rhs.Flags);
                ret.Unused2 = this.Unused2.Combine(rhs.Unused2);
                ret.SightFOV = this.SightFOV.Combine(rhs.SightFOV);
                ret.Unknown = this.Unknown.Combine(rhs.Unknown);
                ret.BaseVATStoHitChance = this.BaseVATStoHitChance.Combine(rhs.BaseVATStoHitChance);
                ret.AttackAnimation = this.AttackAnimation.Combine(rhs.AttackAnimation);
                ret.NumProjectiles = this.NumProjectiles.Combine(rhs.NumProjectiles);
                ret.EmbeddedWeaponAV = this.EmbeddedWeaponAV.Combine(rhs.EmbeddedWeaponAV);
                ret.RangeMin = this.RangeMin.Combine(rhs.RangeMin);
                ret.RangeMax = this.RangeMax.Combine(rhs.RangeMax);
                ret.OnHit = this.OnHit.Combine(rhs.OnHit);
                ret.AnimationAttackMult = this.AnimationAttackMult.Combine(rhs.AnimationAttackMult);
                ret.Unknown2 = this.Unknown2.Combine(rhs.Unknown2);
                ret.RumbleLeftMotorStrength = this.RumbleLeftMotorStrength.Combine(rhs.RumbleLeftMotorStrength);
                ret.RumbleRightMotorStrength = this.RumbleRightMotorStrength.Combine(rhs.RumbleRightMotorStrength);
                ret.RumbleDuration = this.RumbleDuration.Combine(rhs.RumbleDuration);
                ret.Unknown3 = this.Unknown3.Combine(rhs.Unknown3);
                ret.Skill = this.Skill.Combine(rhs.Skill);
                ret.Unknown4 = this.Unknown4.Combine(rhs.Unknown4);
                ret.Resist = this.Resist.Combine(rhs.Resist);
                ret.Unknown5 = this.Unknown5.Combine(rhs.Unknown5);
                ret.Stagger = this.Stagger.Combine(rhs.Stagger);
                return ret;
            }
            public static ErrorMask? Combine(ErrorMask? lhs, ErrorMask? rhs)
            {
                if (lhs != null && rhs != null) return lhs.Combine(rhs);
                return lhs ?? rhs;
            }
            #endregion

            #region Factory
            public static ErrorMask Factory(ErrorMaskBuilder errorMask)
            {
                return new ErrorMask();
            }
            #endregion

        }
        public class TranslationMask : ITranslationMask
        {
            #region Members
            private TranslationCrystal? _crystal;
            public bool AnimationType;
            public bool Unused;
            public bool Speed;
            public bool Reach;
            public bool Flags;
            public bool Unused2;
            public bool SightFOV;
            public bool Unknown;
            public bool BaseVATStoHitChance;
            public bool AttackAnimation;
            public bool NumProjectiles;
            public bool EmbeddedWeaponAV;
            public bool RangeMin;
            public bool RangeMax;
            public bool OnHit;
            public bool AnimationAttackMult;
            public bool Unknown2;
            public bool RumbleLeftMotorStrength;
            public bool RumbleRightMotorStrength;
            public bool RumbleDuration;
            public bool Unknown3;
            public bool Skill;
            public bool Unknown4;
            public bool Resist;
            public bool Unknown5;
            public bool Stagger;
            #endregion

            #region Ctors
            public TranslationMask(bool defaultOn)
            {
                this.AnimationType = defaultOn;
                this.Unused = defaultOn;
                this.Speed = defaultOn;
                this.Reach = defaultOn;
                this.Flags = defaultOn;
                this.Unused2 = defaultOn;
                this.SightFOV = defaultOn;
                this.Unknown = defaultOn;
                this.BaseVATStoHitChance = defaultOn;
                this.AttackAnimation = defaultOn;
                this.NumProjectiles = defaultOn;
                this.EmbeddedWeaponAV = defaultOn;
                this.RangeMin = defaultOn;
                this.RangeMax = defaultOn;
                this.OnHit = defaultOn;
                this.AnimationAttackMult = defaultOn;
                this.Unknown2 = defaultOn;
                this.RumbleLeftMotorStrength = defaultOn;
                this.RumbleRightMotorStrength = defaultOn;
                this.RumbleDuration = defaultOn;
                this.Unknown3 = defaultOn;
                this.Skill = defaultOn;
                this.Unknown4 = defaultOn;
                this.Resist = defaultOn;
                this.Unknown5 = defaultOn;
                this.Stagger = defaultOn;
            }

            #endregion

            public TranslationCrystal GetCrystal()
            {
                if (_crystal != null) return _crystal;
                var ret = new List<(bool On, TranslationCrystal? SubCrystal)>();
                GetCrystal(ret);
                _crystal = new TranslationCrystal(ret.ToArray());
                return _crystal;
            }

            protected void GetCrystal(List<(bool On, TranslationCrystal? SubCrystal)> ret)
            {
                ret.Add((AnimationType, null));
                ret.Add((Unused, null));
                ret.Add((Speed, null));
                ret.Add((Reach, null));
                ret.Add((Flags, null));
                ret.Add((Unused2, null));
                ret.Add((SightFOV, null));
                ret.Add((Unknown, null));
                ret.Add((BaseVATStoHitChance, null));
                ret.Add((AttackAnimation, null));
                ret.Add((NumProjectiles, null));
                ret.Add((EmbeddedWeaponAV, null));
                ret.Add((RangeMin, null));
                ret.Add((RangeMax, null));
                ret.Add((OnHit, null));
                ret.Add((AnimationAttackMult, null));
                ret.Add((Unknown2, null));
                ret.Add((RumbleLeftMotorStrength, null));
                ret.Add((RumbleRightMotorStrength, null));
                ret.Add((RumbleDuration, null));
                ret.Add((Unknown3, null));
                ret.Add((Skill, null));
                ret.Add((Unknown4, null));
                ret.Add((Resist, null));
                ret.Add((Unknown5, null));
                ret.Add((Stagger, null));
            }
        }
        #endregion

        #region Mutagen
        public new static readonly RecordType GrupRecordType = WeaponData_Registration.TriggeringRecordType;
        #endregion

        #region Binary Translation
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected object BinaryWriteTranslator => WeaponDataBinaryWriteTranslation.Instance;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        object IBinaryItem.BinaryWriteTranslator => this.BinaryWriteTranslator;
        void IBinaryItem.WriteToBinary(
            MutagenWriter writer,
            RecordTypeConverter? recordTypeConverter = null)
        {
            ((WeaponDataBinaryWriteTranslation)this.BinaryWriteTranslator).Write(
                item: this,
                writer: writer,
                recordTypeConverter: recordTypeConverter);
        }
        #region Binary Create
        [DebuggerStepThrough]
        public static WeaponData CreateFromBinary(MutagenFrame frame)
        {
            return CreateFromBinary(
                frame: frame,
                recordTypeConverter: null);
        }

        public static WeaponData CreateFromBinary(
            MutagenFrame frame,
            RecordTypeConverter? recordTypeConverter = null)
        {
            var ret = new WeaponData();
            ((WeaponDataSetterCommon)((IWeaponDataGetter)ret).CommonSetterInstance()!).CopyInFromBinary(
                item: ret,
                frame: frame,
                recordTypeConverter: recordTypeConverter);
            return ret;
        }

        #endregion

        #endregion

        void IPrintable.ToString(FileGeneration fg, string? name) => this.ToString(fg, name);
        IMask<bool> ILoquiObjectGetter.GetHasBeenSetIMask() => this.GetHasBeenSetMask();
        IMask<bool> IEqualsMask.GetEqualsIMask(object rhs, EqualsMaskHelper.Include include) => this.GetEqualsMask((IWeaponDataGetter)rhs, include);

        void IClearable.Clear()
        {
            ((WeaponDataSetterCommon)((IWeaponDataGetter)this).CommonSetterInstance()!).Clear(this);
        }

        internal static WeaponData GetNew()
        {
            return new WeaponData();
        }

    }
    #endregion

    #region Interface
    public partial interface IWeaponData :
        IWeaponDataGetter,
        ILoquiObjectSetter<IWeaponData>
    {
        new WeaponAnimationType AnimationType { get; set; }
        new Byte[] Unused { get; set; }
        new Single Speed { get; set; }
        new Single Reach { get; set; }
        new WeaponData.Flag Flags { get; set; }
        new Int16 Unused2 { get; set; }
        new Single SightFOV { get; set; }
        new Int32 Unknown { get; set; }
        new Byte BaseVATStoHitChance { get; set; }
        new WeaponData.AttackAnimationType AttackAnimation { get; set; }
        new Byte NumProjectiles { get; set; }
        new Byte EmbeddedWeaponAV { get; set; }
        new Single RangeMin { get; set; }
        new Single RangeMax { get; set; }
        new WeaponData.OnHitType OnHit { get; set; }
        new Single AnimationAttackMult { get; set; }
        new Int32 Unknown2 { get; set; }
        new Single RumbleLeftMotorStrength { get; set; }
        new Single RumbleRightMotorStrength { get; set; }
        new Single RumbleDuration { get; set; }
        new Byte[] Unknown3 { get; set; }
        new Skill? Skill { get; set; }
        new Int64 Unknown4 { get; set; }
        new ActorValueExtended Resist { get; set; }
        new Int32 Unknown5 { get; set; }
        new Single Stagger { get; set; }
    }

    public partial interface IWeaponDataGetter :
        ILoquiObject,
        ILoquiObject<IWeaponDataGetter>,
        IXmlItem,
        IBinaryItem
    {
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        object CommonInstance();
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        object? CommonSetterInstance();
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        object CommonSetterTranslationInstance();
        static ILoquiRegistration Registration => WeaponData_Registration.Instance;
        WeaponAnimationType AnimationType { get; }
        ReadOnlyMemorySlice<Byte> Unused { get; }
        Single Speed { get; }
        Single Reach { get; }
        WeaponData.Flag Flags { get; }
        Int16 Unused2 { get; }
        Single SightFOV { get; }
        Int32 Unknown { get; }
        Byte BaseVATStoHitChance { get; }
        WeaponData.AttackAnimationType AttackAnimation { get; }
        Byte NumProjectiles { get; }
        Byte EmbeddedWeaponAV { get; }
        Single RangeMin { get; }
        Single RangeMax { get; }
        WeaponData.OnHitType OnHit { get; }
        Single AnimationAttackMult { get; }
        Int32 Unknown2 { get; }
        Single RumbleLeftMotorStrength { get; }
        Single RumbleRightMotorStrength { get; }
        Single RumbleDuration { get; }
        ReadOnlyMemorySlice<Byte> Unknown3 { get; }
        Skill? Skill { get; }
        Int64 Unknown4 { get; }
        ActorValueExtended Resist { get; }
        Int32 Unknown5 { get; }
        Single Stagger { get; }

    }

    #endregion

    #region Common MixIn
    public static partial class WeaponDataMixIn
    {
        public static void Clear(this IWeaponData item)
        {
            ((WeaponDataSetterCommon)((IWeaponDataGetter)item).CommonSetterInstance()!).Clear(item: item);
        }

        public static WeaponData.Mask<bool> GetEqualsMask(
            this IWeaponDataGetter item,
            IWeaponDataGetter rhs,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            return ((WeaponDataCommon)((IWeaponDataGetter)item).CommonInstance()!).GetEqualsMask(
                item: item,
                rhs: rhs,
                include: include);
        }

        public static string ToString(
            this IWeaponDataGetter item,
            string? name = null,
            WeaponData.Mask<bool>? printMask = null)
        {
            return ((WeaponDataCommon)((IWeaponDataGetter)item).CommonInstance()!).ToString(
                item: item,
                name: name,
                printMask: printMask);
        }

        public static void ToString(
            this IWeaponDataGetter item,
            FileGeneration fg,
            string? name = null,
            WeaponData.Mask<bool>? printMask = null)
        {
            ((WeaponDataCommon)((IWeaponDataGetter)item).CommonInstance()!).ToString(
                item: item,
                fg: fg,
                name: name,
                printMask: printMask);
        }

        public static bool HasBeenSet(
            this IWeaponDataGetter item,
            WeaponData.Mask<bool?> checkMask)
        {
            return ((WeaponDataCommon)((IWeaponDataGetter)item).CommonInstance()!).HasBeenSet(
                item: item,
                checkMask: checkMask);
        }

        public static WeaponData.Mask<bool> GetHasBeenSetMask(this IWeaponDataGetter item)
        {
            var ret = new WeaponData.Mask<bool>(false);
            ((WeaponDataCommon)((IWeaponDataGetter)item).CommonInstance()!).FillHasBeenSetMask(
                item: item,
                mask: ret);
            return ret;
        }

        public static bool Equals(
            this IWeaponDataGetter item,
            IWeaponDataGetter rhs)
        {
            return ((WeaponDataCommon)((IWeaponDataGetter)item).CommonInstance()!).Equals(
                lhs: item,
                rhs: rhs);
        }

        public static void DeepCopyIn(
            this IWeaponData lhs,
            IWeaponDataGetter rhs)
        {
            ((WeaponDataSetterTranslationCommon)((IWeaponDataGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: default,
                copyMask: default);
        }

        public static void DeepCopyIn(
            this IWeaponData lhs,
            IWeaponDataGetter rhs,
            WeaponData.TranslationMask? copyMask = null)
        {
            ((WeaponDataSetterTranslationCommon)((IWeaponDataGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: default,
                copyMask: copyMask?.GetCrystal());
        }

        public static void DeepCopyIn(
            this IWeaponData lhs,
            IWeaponDataGetter rhs,
            out WeaponData.ErrorMask errorMask,
            WeaponData.TranslationMask? copyMask = null)
        {
            var errorMaskBuilder = new ErrorMaskBuilder();
            ((WeaponDataSetterTranslationCommon)((IWeaponDataGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: errorMaskBuilder,
                copyMask: copyMask?.GetCrystal());
            errorMask = WeaponData.ErrorMask.Factory(errorMaskBuilder);
        }

        public static void DeepCopyIn(
            this IWeaponData lhs,
            IWeaponDataGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask)
        {
            ((WeaponDataSetterTranslationCommon)((IWeaponDataGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: errorMask,
                copyMask: copyMask);
        }

        public static WeaponData DeepCopy(
            this IWeaponDataGetter item,
            WeaponData.TranslationMask? copyMask = null)
        {
            return ((WeaponDataSetterTranslationCommon)((IWeaponDataGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask);
        }

        public static WeaponData DeepCopy(
            this IWeaponDataGetter item,
            out WeaponData.ErrorMask errorMask,
            WeaponData.TranslationMask? copyMask = null)
        {
            return ((WeaponDataSetterTranslationCommon)((IWeaponDataGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask,
                errorMask: out errorMask);
        }

        public static WeaponData DeepCopy(
            this IWeaponDataGetter item,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask = null)
        {
            return ((WeaponDataSetterTranslationCommon)((IWeaponDataGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask,
                errorMask: errorMask);
        }

        #region Xml Translation
        [DebuggerStepThrough]
        public static void CopyInFromXml(
            this IWeaponData item,
            XElement node,
            WeaponData.TranslationMask? translationMask = null)
        {
            CopyInFromXml(
                item: item,
                node: node,
                errorMask: null,
                translationMask: translationMask?.GetCrystal());
        }

        [DebuggerStepThrough]
        public static void CopyInFromXml(
            this IWeaponData item,
            XElement node,
            out WeaponData.ErrorMask errorMask,
            WeaponData.TranslationMask? translationMask = null)
        {
            ErrorMaskBuilder errorMaskBuilder = new ErrorMaskBuilder();
            CopyInFromXml(
                item: item,
                node: node,
                errorMask: errorMaskBuilder,
                translationMask: translationMask?.GetCrystal());
            errorMask = WeaponData.ErrorMask.Factory(errorMaskBuilder);
        }

        public static void CopyInFromXml(
            this IWeaponData item,
            XElement node,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask)
        {
            ((WeaponDataSetterCommon)((IWeaponDataGetter)item).CommonSetterInstance()!).CopyInFromXml(
                item: item,
                node: node,
                errorMask: errorMask,
                translationMask: translationMask);
        }

        public static void CopyInFromXml(
            this IWeaponData item,
            string path,
            WeaponData.TranslationMask? translationMask = null)
        {
            var node = XDocument.Load(path).Root;
            CopyInFromXml(
                item: item,
                node: node,
                translationMask: translationMask);
        }

        public static void CopyInFromXml(
            this IWeaponData item,
            string path,
            out WeaponData.ErrorMask errorMask,
            WeaponData.TranslationMask? translationMask = null)
        {
            var node = XDocument.Load(path).Root;
            CopyInFromXml(
                item: item,
                node: node,
                errorMask: out errorMask,
                translationMask: translationMask);
        }

        public static void CopyInFromXml(
            this IWeaponData item,
            string path,
            ErrorMaskBuilder? errorMask,
            WeaponData.TranslationMask? translationMask = null)
        {
            var node = XDocument.Load(path).Root;
            CopyInFromXml(
                item: item,
                node: node,
                errorMask: errorMask,
                translationMask: translationMask?.GetCrystal());
        }

        public static void CopyInFromXml(
            this IWeaponData item,
            Stream stream,
            WeaponData.TranslationMask? translationMask = null)
        {
            var node = XDocument.Load(stream).Root;
            CopyInFromXml(
                item: item,
                node: node,
                translationMask: translationMask);
        }

        public static void CopyInFromXml(
            this IWeaponData item,
            Stream stream,
            out WeaponData.ErrorMask errorMask,
            WeaponData.TranslationMask? translationMask = null)
        {
            var node = XDocument.Load(stream).Root;
            CopyInFromXml(
                item: item,
                node: node,
                errorMask: out errorMask,
                translationMask: translationMask);
        }

        public static void CopyInFromXml(
            this IWeaponData item,
            Stream stream,
            ErrorMaskBuilder? errorMask,
            WeaponData.TranslationMask? translationMask = null)
        {
            var node = XDocument.Load(stream).Root;
            CopyInFromXml(
                item: item,
                node: node,
                errorMask: errorMask,
                translationMask: translationMask?.GetCrystal());
        }

        #endregion

        #region Binary Translation
        [DebuggerStepThrough]
        public static void CopyInFromBinary(
            this IWeaponData item,
            MutagenFrame frame)
        {
            CopyInFromBinary(
                item: item,
                frame: frame,
                recordTypeConverter: null);
        }

        public static void CopyInFromBinary(
            this IWeaponData item,
            MutagenFrame frame,
            RecordTypeConverter? recordTypeConverter = null)
        {
            ((WeaponDataSetterCommon)((IWeaponDataGetter)item).CommonSetterInstance()!).CopyInFromBinary(
                item: item,
                frame: frame,
                recordTypeConverter: recordTypeConverter);
        }

        #endregion

    }
    #endregion

}

namespace Mutagen.Bethesda.Skyrim.Internals
{
    #region Field Index
    public enum WeaponData_FieldIndex
    {
        AnimationType = 0,
        Unused = 1,
        Speed = 2,
        Reach = 3,
        Flags = 4,
        Unused2 = 5,
        SightFOV = 6,
        Unknown = 7,
        BaseVATStoHitChance = 8,
        AttackAnimation = 9,
        NumProjectiles = 10,
        EmbeddedWeaponAV = 11,
        RangeMin = 12,
        RangeMax = 13,
        OnHit = 14,
        AnimationAttackMult = 15,
        Unknown2 = 16,
        RumbleLeftMotorStrength = 17,
        RumbleRightMotorStrength = 18,
        RumbleDuration = 19,
        Unknown3 = 20,
        Skill = 21,
        Unknown4 = 22,
        Resist = 23,
        Unknown5 = 24,
        Stagger = 25,
    }
    #endregion

    #region Registration
    public partial class WeaponData_Registration : ILoquiRegistration
    {
        public static readonly WeaponData_Registration Instance = new WeaponData_Registration();

        public static ProtocolKey ProtocolKey => ProtocolDefinition_Skyrim.ProtocolKey;

        public static readonly ObjectKey ObjectKey = new ObjectKey(
            protocolKey: ProtocolDefinition_Skyrim.ProtocolKey,
            msgID: 197,
            version: 0);

        public const string GUID = "e4fd60a3-168d-4947-be5a-75a762ff8b1f";

        public const ushort AdditionalFieldCount = 26;

        public const ushort FieldCount = 26;

        public static readonly Type MaskType = typeof(WeaponData.Mask<>);

        public static readonly Type ErrorMaskType = typeof(WeaponData.ErrorMask);

        public static readonly Type ClassType = typeof(WeaponData);

        public static readonly Type GetterType = typeof(IWeaponDataGetter);

        public static readonly Type? InternalGetterType = null;

        public static readonly Type SetterType = typeof(IWeaponData);

        public static readonly Type? InternalSetterType = null;

        public const string FullName = "Mutagen.Bethesda.Skyrim.WeaponData";

        public const string Name = "WeaponData";

        public const string Namespace = "Mutagen.Bethesda.Skyrim";

        public const byte GenericCount = 0;

        public static readonly Type? GenericRegistrationType = null;

        public static ushort? GetNameIndex(StringCaseAgnostic str)
        {
            switch (str.Upper)
            {
                case "ANIMATIONTYPE":
                    return (ushort)WeaponData_FieldIndex.AnimationType;
                case "UNUSED":
                    return (ushort)WeaponData_FieldIndex.Unused;
                case "SPEED":
                    return (ushort)WeaponData_FieldIndex.Speed;
                case "REACH":
                    return (ushort)WeaponData_FieldIndex.Reach;
                case "FLAGS":
                    return (ushort)WeaponData_FieldIndex.Flags;
                case "UNUSED2":
                    return (ushort)WeaponData_FieldIndex.Unused2;
                case "SIGHTFOV":
                    return (ushort)WeaponData_FieldIndex.SightFOV;
                case "UNKNOWN":
                    return (ushort)WeaponData_FieldIndex.Unknown;
                case "BASEVATSTOHITCHANCE":
                    return (ushort)WeaponData_FieldIndex.BaseVATStoHitChance;
                case "ATTACKANIMATION":
                    return (ushort)WeaponData_FieldIndex.AttackAnimation;
                case "NUMPROJECTILES":
                    return (ushort)WeaponData_FieldIndex.NumProjectiles;
                case "EMBEDDEDWEAPONAV":
                    return (ushort)WeaponData_FieldIndex.EmbeddedWeaponAV;
                case "RANGEMIN":
                    return (ushort)WeaponData_FieldIndex.RangeMin;
                case "RANGEMAX":
                    return (ushort)WeaponData_FieldIndex.RangeMax;
                case "ONHIT":
                    return (ushort)WeaponData_FieldIndex.OnHit;
                case "ANIMATIONATTACKMULT":
                    return (ushort)WeaponData_FieldIndex.AnimationAttackMult;
                case "UNKNOWN2":
                    return (ushort)WeaponData_FieldIndex.Unknown2;
                case "RUMBLELEFTMOTORSTRENGTH":
                    return (ushort)WeaponData_FieldIndex.RumbleLeftMotorStrength;
                case "RUMBLERIGHTMOTORSTRENGTH":
                    return (ushort)WeaponData_FieldIndex.RumbleRightMotorStrength;
                case "RUMBLEDURATION":
                    return (ushort)WeaponData_FieldIndex.RumbleDuration;
                case "UNKNOWN3":
                    return (ushort)WeaponData_FieldIndex.Unknown3;
                case "SKILL":
                    return (ushort)WeaponData_FieldIndex.Skill;
                case "UNKNOWN4":
                    return (ushort)WeaponData_FieldIndex.Unknown4;
                case "RESIST":
                    return (ushort)WeaponData_FieldIndex.Resist;
                case "UNKNOWN5":
                    return (ushort)WeaponData_FieldIndex.Unknown5;
                case "STAGGER":
                    return (ushort)WeaponData_FieldIndex.Stagger;
                default:
                    return null;
            }
        }

        public static bool GetNthIsEnumerable(ushort index)
        {
            WeaponData_FieldIndex enu = (WeaponData_FieldIndex)index;
            switch (enu)
            {
                case WeaponData_FieldIndex.AnimationType:
                case WeaponData_FieldIndex.Unused:
                case WeaponData_FieldIndex.Speed:
                case WeaponData_FieldIndex.Reach:
                case WeaponData_FieldIndex.Flags:
                case WeaponData_FieldIndex.Unused2:
                case WeaponData_FieldIndex.SightFOV:
                case WeaponData_FieldIndex.Unknown:
                case WeaponData_FieldIndex.BaseVATStoHitChance:
                case WeaponData_FieldIndex.AttackAnimation:
                case WeaponData_FieldIndex.NumProjectiles:
                case WeaponData_FieldIndex.EmbeddedWeaponAV:
                case WeaponData_FieldIndex.RangeMin:
                case WeaponData_FieldIndex.RangeMax:
                case WeaponData_FieldIndex.OnHit:
                case WeaponData_FieldIndex.AnimationAttackMult:
                case WeaponData_FieldIndex.Unknown2:
                case WeaponData_FieldIndex.RumbleLeftMotorStrength:
                case WeaponData_FieldIndex.RumbleRightMotorStrength:
                case WeaponData_FieldIndex.RumbleDuration:
                case WeaponData_FieldIndex.Unknown3:
                case WeaponData_FieldIndex.Skill:
                case WeaponData_FieldIndex.Unknown4:
                case WeaponData_FieldIndex.Resist:
                case WeaponData_FieldIndex.Unknown5:
                case WeaponData_FieldIndex.Stagger:
                    return false;
                default:
                    throw new ArgumentException($"Index is out of range: {index}");
            }
        }

        public static bool GetNthIsLoqui(ushort index)
        {
            WeaponData_FieldIndex enu = (WeaponData_FieldIndex)index;
            switch (enu)
            {
                case WeaponData_FieldIndex.AnimationType:
                case WeaponData_FieldIndex.Unused:
                case WeaponData_FieldIndex.Speed:
                case WeaponData_FieldIndex.Reach:
                case WeaponData_FieldIndex.Flags:
                case WeaponData_FieldIndex.Unused2:
                case WeaponData_FieldIndex.SightFOV:
                case WeaponData_FieldIndex.Unknown:
                case WeaponData_FieldIndex.BaseVATStoHitChance:
                case WeaponData_FieldIndex.AttackAnimation:
                case WeaponData_FieldIndex.NumProjectiles:
                case WeaponData_FieldIndex.EmbeddedWeaponAV:
                case WeaponData_FieldIndex.RangeMin:
                case WeaponData_FieldIndex.RangeMax:
                case WeaponData_FieldIndex.OnHit:
                case WeaponData_FieldIndex.AnimationAttackMult:
                case WeaponData_FieldIndex.Unknown2:
                case WeaponData_FieldIndex.RumbleLeftMotorStrength:
                case WeaponData_FieldIndex.RumbleRightMotorStrength:
                case WeaponData_FieldIndex.RumbleDuration:
                case WeaponData_FieldIndex.Unknown3:
                case WeaponData_FieldIndex.Skill:
                case WeaponData_FieldIndex.Unknown4:
                case WeaponData_FieldIndex.Resist:
                case WeaponData_FieldIndex.Unknown5:
                case WeaponData_FieldIndex.Stagger:
                    return false;
                default:
                    throw new ArgumentException($"Index is out of range: {index}");
            }
        }

        public static bool GetNthIsSingleton(ushort index)
        {
            WeaponData_FieldIndex enu = (WeaponData_FieldIndex)index;
            switch (enu)
            {
                case WeaponData_FieldIndex.AnimationType:
                case WeaponData_FieldIndex.Unused:
                case WeaponData_FieldIndex.Speed:
                case WeaponData_FieldIndex.Reach:
                case WeaponData_FieldIndex.Flags:
                case WeaponData_FieldIndex.Unused2:
                case WeaponData_FieldIndex.SightFOV:
                case WeaponData_FieldIndex.Unknown:
                case WeaponData_FieldIndex.BaseVATStoHitChance:
                case WeaponData_FieldIndex.AttackAnimation:
                case WeaponData_FieldIndex.NumProjectiles:
                case WeaponData_FieldIndex.EmbeddedWeaponAV:
                case WeaponData_FieldIndex.RangeMin:
                case WeaponData_FieldIndex.RangeMax:
                case WeaponData_FieldIndex.OnHit:
                case WeaponData_FieldIndex.AnimationAttackMult:
                case WeaponData_FieldIndex.Unknown2:
                case WeaponData_FieldIndex.RumbleLeftMotorStrength:
                case WeaponData_FieldIndex.RumbleRightMotorStrength:
                case WeaponData_FieldIndex.RumbleDuration:
                case WeaponData_FieldIndex.Unknown3:
                case WeaponData_FieldIndex.Skill:
                case WeaponData_FieldIndex.Unknown4:
                case WeaponData_FieldIndex.Resist:
                case WeaponData_FieldIndex.Unknown5:
                case WeaponData_FieldIndex.Stagger:
                    return false;
                default:
                    throw new ArgumentException($"Index is out of range: {index}");
            }
        }

        public static string GetNthName(ushort index)
        {
            WeaponData_FieldIndex enu = (WeaponData_FieldIndex)index;
            switch (enu)
            {
                case WeaponData_FieldIndex.AnimationType:
                    return "AnimationType";
                case WeaponData_FieldIndex.Unused:
                    return "Unused";
                case WeaponData_FieldIndex.Speed:
                    return "Speed";
                case WeaponData_FieldIndex.Reach:
                    return "Reach";
                case WeaponData_FieldIndex.Flags:
                    return "Flags";
                case WeaponData_FieldIndex.Unused2:
                    return "Unused2";
                case WeaponData_FieldIndex.SightFOV:
                    return "SightFOV";
                case WeaponData_FieldIndex.Unknown:
                    return "Unknown";
                case WeaponData_FieldIndex.BaseVATStoHitChance:
                    return "BaseVATStoHitChance";
                case WeaponData_FieldIndex.AttackAnimation:
                    return "AttackAnimation";
                case WeaponData_FieldIndex.NumProjectiles:
                    return "NumProjectiles";
                case WeaponData_FieldIndex.EmbeddedWeaponAV:
                    return "EmbeddedWeaponAV";
                case WeaponData_FieldIndex.RangeMin:
                    return "RangeMin";
                case WeaponData_FieldIndex.RangeMax:
                    return "RangeMax";
                case WeaponData_FieldIndex.OnHit:
                    return "OnHit";
                case WeaponData_FieldIndex.AnimationAttackMult:
                    return "AnimationAttackMult";
                case WeaponData_FieldIndex.Unknown2:
                    return "Unknown2";
                case WeaponData_FieldIndex.RumbleLeftMotorStrength:
                    return "RumbleLeftMotorStrength";
                case WeaponData_FieldIndex.RumbleRightMotorStrength:
                    return "RumbleRightMotorStrength";
                case WeaponData_FieldIndex.RumbleDuration:
                    return "RumbleDuration";
                case WeaponData_FieldIndex.Unknown3:
                    return "Unknown3";
                case WeaponData_FieldIndex.Skill:
                    return "Skill";
                case WeaponData_FieldIndex.Unknown4:
                    return "Unknown4";
                case WeaponData_FieldIndex.Resist:
                    return "Resist";
                case WeaponData_FieldIndex.Unknown5:
                    return "Unknown5";
                case WeaponData_FieldIndex.Stagger:
                    return "Stagger";
                default:
                    throw new ArgumentException($"Index is out of range: {index}");
            }
        }

        public static bool IsNthDerivative(ushort index)
        {
            WeaponData_FieldIndex enu = (WeaponData_FieldIndex)index;
            switch (enu)
            {
                case WeaponData_FieldIndex.AnimationType:
                case WeaponData_FieldIndex.Unused:
                case WeaponData_FieldIndex.Speed:
                case WeaponData_FieldIndex.Reach:
                case WeaponData_FieldIndex.Flags:
                case WeaponData_FieldIndex.Unused2:
                case WeaponData_FieldIndex.SightFOV:
                case WeaponData_FieldIndex.Unknown:
                case WeaponData_FieldIndex.BaseVATStoHitChance:
                case WeaponData_FieldIndex.AttackAnimation:
                case WeaponData_FieldIndex.NumProjectiles:
                case WeaponData_FieldIndex.EmbeddedWeaponAV:
                case WeaponData_FieldIndex.RangeMin:
                case WeaponData_FieldIndex.RangeMax:
                case WeaponData_FieldIndex.OnHit:
                case WeaponData_FieldIndex.AnimationAttackMult:
                case WeaponData_FieldIndex.Unknown2:
                case WeaponData_FieldIndex.RumbleLeftMotorStrength:
                case WeaponData_FieldIndex.RumbleRightMotorStrength:
                case WeaponData_FieldIndex.RumbleDuration:
                case WeaponData_FieldIndex.Unknown3:
                case WeaponData_FieldIndex.Skill:
                case WeaponData_FieldIndex.Unknown4:
                case WeaponData_FieldIndex.Resist:
                case WeaponData_FieldIndex.Unknown5:
                case WeaponData_FieldIndex.Stagger:
                    return false;
                default:
                    throw new ArgumentException($"Index is out of range: {index}");
            }
        }

        public static bool IsProtected(ushort index)
        {
            WeaponData_FieldIndex enu = (WeaponData_FieldIndex)index;
            switch (enu)
            {
                case WeaponData_FieldIndex.AnimationType:
                case WeaponData_FieldIndex.Unused:
                case WeaponData_FieldIndex.Speed:
                case WeaponData_FieldIndex.Reach:
                case WeaponData_FieldIndex.Flags:
                case WeaponData_FieldIndex.Unused2:
                case WeaponData_FieldIndex.SightFOV:
                case WeaponData_FieldIndex.Unknown:
                case WeaponData_FieldIndex.BaseVATStoHitChance:
                case WeaponData_FieldIndex.AttackAnimation:
                case WeaponData_FieldIndex.NumProjectiles:
                case WeaponData_FieldIndex.EmbeddedWeaponAV:
                case WeaponData_FieldIndex.RangeMin:
                case WeaponData_FieldIndex.RangeMax:
                case WeaponData_FieldIndex.OnHit:
                case WeaponData_FieldIndex.AnimationAttackMult:
                case WeaponData_FieldIndex.Unknown2:
                case WeaponData_FieldIndex.RumbleLeftMotorStrength:
                case WeaponData_FieldIndex.RumbleRightMotorStrength:
                case WeaponData_FieldIndex.RumbleDuration:
                case WeaponData_FieldIndex.Unknown3:
                case WeaponData_FieldIndex.Skill:
                case WeaponData_FieldIndex.Unknown4:
                case WeaponData_FieldIndex.Resist:
                case WeaponData_FieldIndex.Unknown5:
                case WeaponData_FieldIndex.Stagger:
                    return false;
                default:
                    throw new ArgumentException($"Index is out of range: {index}");
            }
        }

        public static Type GetNthType(ushort index)
        {
            WeaponData_FieldIndex enu = (WeaponData_FieldIndex)index;
            switch (enu)
            {
                case WeaponData_FieldIndex.AnimationType:
                    return typeof(WeaponAnimationType);
                case WeaponData_FieldIndex.Unused:
                    return typeof(Byte[]);
                case WeaponData_FieldIndex.Speed:
                    return typeof(Single);
                case WeaponData_FieldIndex.Reach:
                    return typeof(Single);
                case WeaponData_FieldIndex.Flags:
                    return typeof(WeaponData.Flag);
                case WeaponData_FieldIndex.Unused2:
                    return typeof(Int16);
                case WeaponData_FieldIndex.SightFOV:
                    return typeof(Single);
                case WeaponData_FieldIndex.Unknown:
                    return typeof(Int32);
                case WeaponData_FieldIndex.BaseVATStoHitChance:
                    return typeof(Byte);
                case WeaponData_FieldIndex.AttackAnimation:
                    return typeof(WeaponData.AttackAnimationType);
                case WeaponData_FieldIndex.NumProjectiles:
                    return typeof(Byte);
                case WeaponData_FieldIndex.EmbeddedWeaponAV:
                    return typeof(Byte);
                case WeaponData_FieldIndex.RangeMin:
                    return typeof(Single);
                case WeaponData_FieldIndex.RangeMax:
                    return typeof(Single);
                case WeaponData_FieldIndex.OnHit:
                    return typeof(WeaponData.OnHitType);
                case WeaponData_FieldIndex.AnimationAttackMult:
                    return typeof(Single);
                case WeaponData_FieldIndex.Unknown2:
                    return typeof(Int32);
                case WeaponData_FieldIndex.RumbleLeftMotorStrength:
                    return typeof(Single);
                case WeaponData_FieldIndex.RumbleRightMotorStrength:
                    return typeof(Single);
                case WeaponData_FieldIndex.RumbleDuration:
                    return typeof(Single);
                case WeaponData_FieldIndex.Unknown3:
                    return typeof(Byte[]);
                case WeaponData_FieldIndex.Skill:
                    return typeof(Skill);
                case WeaponData_FieldIndex.Unknown4:
                    return typeof(Int64);
                case WeaponData_FieldIndex.Resist:
                    return typeof(ActorValueExtended);
                case WeaponData_FieldIndex.Unknown5:
                    return typeof(Int32);
                case WeaponData_FieldIndex.Stagger:
                    return typeof(Single);
                default:
                    throw new ArgumentException($"Index is out of range: {index}");
            }
        }

        public static readonly Type XmlWriteTranslation = typeof(WeaponDataXmlWriteTranslation);
        public static readonly RecordType DNAM_HEADER = new RecordType("DNAM");
        public static readonly RecordType TriggeringRecordType = DNAM_HEADER;
        public const int NumStructFields = 26;
        public const int NumTypedFields = 0;
        public static readonly Type BinaryWriteTranslation = typeof(WeaponDataBinaryWriteTranslation);
        #region Interface
        ProtocolKey ILoquiRegistration.ProtocolKey => ProtocolKey;
        ObjectKey ILoquiRegistration.ObjectKey => ObjectKey;
        string ILoquiRegistration.GUID => GUID;
        ushort ILoquiRegistration.FieldCount => FieldCount;
        ushort ILoquiRegistration.AdditionalFieldCount => AdditionalFieldCount;
        Type ILoquiRegistration.MaskType => MaskType;
        Type ILoquiRegistration.ErrorMaskType => ErrorMaskType;
        Type ILoquiRegistration.ClassType => ClassType;
        Type ILoquiRegistration.SetterType => SetterType;
        Type? ILoquiRegistration.InternalSetterType => InternalSetterType;
        Type ILoquiRegistration.GetterType => GetterType;
        Type? ILoquiRegistration.InternalGetterType => InternalGetterType;
        string ILoquiRegistration.FullName => FullName;
        string ILoquiRegistration.Name => Name;
        string ILoquiRegistration.Namespace => Namespace;
        byte ILoquiRegistration.GenericCount => GenericCount;
        Type? ILoquiRegistration.GenericRegistrationType => GenericRegistrationType;
        ushort? ILoquiRegistration.GetNameIndex(StringCaseAgnostic name) => GetNameIndex(name);
        bool ILoquiRegistration.GetNthIsEnumerable(ushort index) => GetNthIsEnumerable(index);
        bool ILoquiRegistration.GetNthIsLoqui(ushort index) => GetNthIsLoqui(index);
        bool ILoquiRegistration.GetNthIsSingleton(ushort index) => GetNthIsSingleton(index);
        string ILoquiRegistration.GetNthName(ushort index) => GetNthName(index);
        bool ILoquiRegistration.IsNthDerivative(ushort index) => IsNthDerivative(index);
        bool ILoquiRegistration.IsProtected(ushort index) => IsProtected(index);
        Type ILoquiRegistration.GetNthType(ushort index) => GetNthType(index);
        #endregion

    }
    #endregion

    #region Common
    public partial class WeaponDataSetterCommon
    {
        public static readonly WeaponDataSetterCommon Instance = new WeaponDataSetterCommon();

        partial void ClearPartial();
        
        public void Clear(IWeaponData item)
        {
            ClearPartial();
            item.AnimationType = default;
            item.Unused = new byte[3];
            item.Speed = default;
            item.Reach = default;
            item.Flags = default;
            item.Unused2 = default;
            item.SightFOV = default;
            item.Unknown = default;
            item.BaseVATStoHitChance = default;
            item.AttackAnimation = WeaponData._AttackAnimation_Default;
            item.NumProjectiles = default;
            item.EmbeddedWeaponAV = default;
            item.RangeMin = default;
            item.RangeMax = default;
            item.OnHit = default;
            item.AnimationAttackMult = default;
            item.Unknown2 = default;
            item.RumbleLeftMotorStrength = default;
            item.RumbleRightMotorStrength = default;
            item.RumbleDuration = default;
            item.Unknown3 = new byte[12];
            item.Skill = default;
            item.Unknown4 = default;
            item.Resist = WeaponData._Resist_Default;
            item.Unknown5 = default;
            item.Stagger = default;
        }
        
        #region Xml Translation
        public virtual void CopyInFromXml(
            IWeaponData item,
            XElement node,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask)
        {
            try
            {
                foreach (var elem in node.Elements())
                {
                    WeaponDataXmlCreateTranslation.FillPublicElementXml(
                        item: item,
                        node: elem,
                        name: elem.Name.LocalName,
                        errorMask: errorMask,
                        translationMask: translationMask);
                }
            }
            catch (Exception ex)
            when (errorMask != null)
            {
                errorMask.ReportException(ex);
            }
        }
        
        #endregion
        
        #region Binary Translation
        protected static void FillBinaryStructs(
            IWeaponData item,
            MutagenFrame frame)
        {
            item.AnimationType = EnumBinaryTranslation<WeaponAnimationType>.Instance.Parse(frame: frame.SpawnWithLength(1));
            item.Unused = Mutagen.Bethesda.Binary.ByteArrayBinaryTranslation.Instance.Parse(frame: frame.SpawnWithLength(3));
            item.Speed = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
            item.Reach = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
            WeaponDataBinaryCreateTranslation.FillBinaryFlagsCustomPublic(
                frame: frame,
                item: item);
            item.Unused2 = frame.ReadInt16();
            item.SightFOV = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
            item.Unknown = frame.ReadInt32();
            item.BaseVATStoHitChance = frame.ReadUInt8();
            item.AttackAnimation = EnumBinaryTranslation<WeaponData.AttackAnimationType>.Instance.Parse(frame: frame.SpawnWithLength(1));
            item.NumProjectiles = frame.ReadUInt8();
            item.EmbeddedWeaponAV = frame.ReadUInt8();
            item.RangeMin = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
            item.RangeMax = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
            item.OnHit = EnumBinaryTranslation<WeaponData.OnHitType>.Instance.Parse(frame: frame.SpawnWithLength(4));
            WeaponDataBinaryCreateTranslation.FillBinaryFlags2CustomPublic(
                frame: frame,
                item: item);
            item.AnimationAttackMult = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
            item.Unknown2 = frame.ReadInt32();
            item.RumbleLeftMotorStrength = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
            item.RumbleRightMotorStrength = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
            item.RumbleDuration = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
            item.Unknown3 = Mutagen.Bethesda.Binary.ByteArrayBinaryTranslation.Instance.Parse(frame: frame.SpawnWithLength(12));
            if (frame.Complete) return;
            item.Skill = EnumBinaryTranslation<Skill>.Instance.Parse(frame: frame.SpawnWithLength(4));
            item.Unknown4 = frame.ReadInt64();
            item.Resist = EnumBinaryTranslation<ActorValueExtended>.Instance.Parse(frame: frame.SpawnWithLength(4));
            item.Unknown5 = frame.ReadInt32();
            item.Stagger = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
        }
        
        public virtual void CopyInFromBinary(
            IWeaponData item,
            MutagenFrame frame,
            RecordTypeConverter? recordTypeConverter = null)
        {
            frame = frame.SpawnWithFinalPosition(HeaderTranslation.ParseSubrecord(
                frame.Reader,
                recordTypeConverter.ConvertToCustom(WeaponData_Registration.DNAM_HEADER)));
            UtilityTranslation.SubrecordParse(
                record: item,
                frame: frame,
                recordTypeConverter: recordTypeConverter,
                fillStructs: FillBinaryStructs);
        }
        
        #endregion
        
    }
    public partial class WeaponDataCommon
    {
        public static readonly WeaponDataCommon Instance = new WeaponDataCommon();

        public WeaponData.Mask<bool> GetEqualsMask(
            IWeaponDataGetter item,
            IWeaponDataGetter rhs,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            var ret = new WeaponData.Mask<bool>(false);
            ((WeaponDataCommon)((IWeaponDataGetter)item).CommonInstance()!).FillEqualsMask(
                item: item,
                rhs: rhs,
                ret: ret,
                include: include);
            return ret;
        }
        
        public void FillEqualsMask(
            IWeaponDataGetter item,
            IWeaponDataGetter rhs,
            WeaponData.Mask<bool> ret,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            if (rhs == null) return;
            ret.AnimationType = item.AnimationType == rhs.AnimationType;
            ret.Unused = MemoryExtensions.SequenceEqual(item.Unused.Span, rhs.Unused.Span);
            ret.Speed = item.Speed.EqualsWithin(rhs.Speed);
            ret.Reach = item.Reach.EqualsWithin(rhs.Reach);
            ret.Flags = item.Flags == rhs.Flags;
            ret.Unused2 = item.Unused2 == rhs.Unused2;
            ret.SightFOV = item.SightFOV.EqualsWithin(rhs.SightFOV);
            ret.Unknown = item.Unknown == rhs.Unknown;
            ret.BaseVATStoHitChance = item.BaseVATStoHitChance == rhs.BaseVATStoHitChance;
            ret.AttackAnimation = item.AttackAnimation == rhs.AttackAnimation;
            ret.NumProjectiles = item.NumProjectiles == rhs.NumProjectiles;
            ret.EmbeddedWeaponAV = item.EmbeddedWeaponAV == rhs.EmbeddedWeaponAV;
            ret.RangeMin = item.RangeMin.EqualsWithin(rhs.RangeMin);
            ret.RangeMax = item.RangeMax.EqualsWithin(rhs.RangeMax);
            ret.OnHit = item.OnHit == rhs.OnHit;
            ret.AnimationAttackMult = item.AnimationAttackMult.EqualsWithin(rhs.AnimationAttackMult);
            ret.Unknown2 = item.Unknown2 == rhs.Unknown2;
            ret.RumbleLeftMotorStrength = item.RumbleLeftMotorStrength.EqualsWithin(rhs.RumbleLeftMotorStrength);
            ret.RumbleRightMotorStrength = item.RumbleRightMotorStrength.EqualsWithin(rhs.RumbleRightMotorStrength);
            ret.RumbleDuration = item.RumbleDuration.EqualsWithin(rhs.RumbleDuration);
            ret.Unknown3 = MemoryExtensions.SequenceEqual(item.Unknown3.Span, rhs.Unknown3.Span);
            ret.Skill = item.Skill == rhs.Skill;
            ret.Unknown4 = item.Unknown4 == rhs.Unknown4;
            ret.Resist = item.Resist == rhs.Resist;
            ret.Unknown5 = item.Unknown5 == rhs.Unknown5;
            ret.Stagger = item.Stagger.EqualsWithin(rhs.Stagger);
        }
        
        public string ToString(
            IWeaponDataGetter item,
            string? name = null,
            WeaponData.Mask<bool>? printMask = null)
        {
            var fg = new FileGeneration();
            ToString(
                item: item,
                fg: fg,
                name: name,
                printMask: printMask);
            return fg.ToString();
        }
        
        public void ToString(
            IWeaponDataGetter item,
            FileGeneration fg,
            string? name = null,
            WeaponData.Mask<bool>? printMask = null)
        {
            if (name == null)
            {
                fg.AppendLine($"WeaponData =>");
            }
            else
            {
                fg.AppendLine($"{name} (WeaponData) =>");
            }
            fg.AppendLine("[");
            using (new DepthWrapper(fg))
            {
                ToStringFields(
                    item: item,
                    fg: fg,
                    printMask: printMask);
            }
            fg.AppendLine("]");
        }
        
        protected static void ToStringFields(
            IWeaponDataGetter item,
            FileGeneration fg,
            WeaponData.Mask<bool>? printMask = null)
        {
            if (printMask?.AnimationType ?? true)
            {
                fg.AppendItem(item.AnimationType, "AnimationType");
            }
            if (printMask?.Unused ?? true)
            {
                fg.AppendLine($"Unused => {SpanExt.ToHexString(item.Unused)}");
            }
            if (printMask?.Speed ?? true)
            {
                fg.AppendItem(item.Speed, "Speed");
            }
            if (printMask?.Reach ?? true)
            {
                fg.AppendItem(item.Reach, "Reach");
            }
            if (printMask?.Flags ?? true)
            {
                fg.AppendItem(item.Flags, "Flags");
            }
            if (printMask?.Unused2 ?? true)
            {
                fg.AppendItem(item.Unused2, "Unused2");
            }
            if (printMask?.SightFOV ?? true)
            {
                fg.AppendItem(item.SightFOV, "SightFOV");
            }
            if (printMask?.Unknown ?? true)
            {
                fg.AppendItem(item.Unknown, "Unknown");
            }
            if (printMask?.BaseVATStoHitChance ?? true)
            {
                fg.AppendItem(item.BaseVATStoHitChance, "BaseVATStoHitChance");
            }
            if (printMask?.AttackAnimation ?? true)
            {
                fg.AppendItem(item.AttackAnimation, "AttackAnimation");
            }
            if (printMask?.NumProjectiles ?? true)
            {
                fg.AppendItem(item.NumProjectiles, "NumProjectiles");
            }
            if (printMask?.EmbeddedWeaponAV ?? true)
            {
                fg.AppendItem(item.EmbeddedWeaponAV, "EmbeddedWeaponAV");
            }
            if (printMask?.RangeMin ?? true)
            {
                fg.AppendItem(item.RangeMin, "RangeMin");
            }
            if (printMask?.RangeMax ?? true)
            {
                fg.AppendItem(item.RangeMax, "RangeMax");
            }
            if (printMask?.OnHit ?? true)
            {
                fg.AppendItem(item.OnHit, "OnHit");
            }
            if (printMask?.AnimationAttackMult ?? true)
            {
                fg.AppendItem(item.AnimationAttackMult, "AnimationAttackMult");
            }
            if (printMask?.Unknown2 ?? true)
            {
                fg.AppendItem(item.Unknown2, "Unknown2");
            }
            if (printMask?.RumbleLeftMotorStrength ?? true)
            {
                fg.AppendItem(item.RumbleLeftMotorStrength, "RumbleLeftMotorStrength");
            }
            if (printMask?.RumbleRightMotorStrength ?? true)
            {
                fg.AppendItem(item.RumbleRightMotorStrength, "RumbleRightMotorStrength");
            }
            if (printMask?.RumbleDuration ?? true)
            {
                fg.AppendItem(item.RumbleDuration, "RumbleDuration");
            }
            if (printMask?.Unknown3 ?? true)
            {
                fg.AppendLine($"Unknown3 => {SpanExt.ToHexString(item.Unknown3)}");
            }
            if ((printMask?.Skill ?? true)
                && item.Skill.TryGet(out var SkillItem))
            {
                fg.AppendItem(SkillItem, "Skill");
            }
            if (printMask?.Unknown4 ?? true)
            {
                fg.AppendItem(item.Unknown4, "Unknown4");
            }
            if (printMask?.Resist ?? true)
            {
                fg.AppendItem(item.Resist, "Resist");
            }
            if (printMask?.Unknown5 ?? true)
            {
                fg.AppendItem(item.Unknown5, "Unknown5");
            }
            if (printMask?.Stagger ?? true)
            {
                fg.AppendItem(item.Stagger, "Stagger");
            }
        }
        
        public bool HasBeenSet(
            IWeaponDataGetter item,
            WeaponData.Mask<bool?> checkMask)
        {
            if (checkMask.Skill.HasValue && checkMask.Skill.Value != (item.Skill != null)) return false;
            return true;
        }
        
        public void FillHasBeenSetMask(
            IWeaponDataGetter item,
            WeaponData.Mask<bool> mask)
        {
            mask.AnimationType = true;
            mask.Unused = true;
            mask.Speed = true;
            mask.Reach = true;
            mask.Flags = true;
            mask.Unused2 = true;
            mask.SightFOV = true;
            mask.Unknown = true;
            mask.BaseVATStoHitChance = true;
            mask.AttackAnimation = true;
            mask.NumProjectiles = true;
            mask.EmbeddedWeaponAV = true;
            mask.RangeMin = true;
            mask.RangeMax = true;
            mask.OnHit = true;
            mask.AnimationAttackMult = true;
            mask.Unknown2 = true;
            mask.RumbleLeftMotorStrength = true;
            mask.RumbleRightMotorStrength = true;
            mask.RumbleDuration = true;
            mask.Unknown3 = true;
            mask.Skill = (item.Skill != null);
            mask.Unknown4 = true;
            mask.Resist = true;
            mask.Unknown5 = true;
            mask.Stagger = true;
        }
        
        #region Equals and Hash
        public virtual bool Equals(
            IWeaponDataGetter? lhs,
            IWeaponDataGetter? rhs)
        {
            if (lhs == null && rhs == null) return false;
            if (lhs == null || rhs == null) return false;
            if (lhs.AnimationType != rhs.AnimationType) return false;
            if (!MemoryExtensions.SequenceEqual(lhs.Unused.Span, rhs.Unused.Span)) return false;
            if (!lhs.Speed.EqualsWithin(rhs.Speed)) return false;
            if (!lhs.Reach.EqualsWithin(rhs.Reach)) return false;
            if (lhs.Flags != rhs.Flags) return false;
            if (lhs.Unused2 != rhs.Unused2) return false;
            if (!lhs.SightFOV.EqualsWithin(rhs.SightFOV)) return false;
            if (lhs.Unknown != rhs.Unknown) return false;
            if (lhs.BaseVATStoHitChance != rhs.BaseVATStoHitChance) return false;
            if (lhs.AttackAnimation != rhs.AttackAnimation) return false;
            if (lhs.NumProjectiles != rhs.NumProjectiles) return false;
            if (lhs.EmbeddedWeaponAV != rhs.EmbeddedWeaponAV) return false;
            if (!lhs.RangeMin.EqualsWithin(rhs.RangeMin)) return false;
            if (!lhs.RangeMax.EqualsWithin(rhs.RangeMax)) return false;
            if (lhs.OnHit != rhs.OnHit) return false;
            if (!lhs.AnimationAttackMult.EqualsWithin(rhs.AnimationAttackMult)) return false;
            if (lhs.Unknown2 != rhs.Unknown2) return false;
            if (!lhs.RumbleLeftMotorStrength.EqualsWithin(rhs.RumbleLeftMotorStrength)) return false;
            if (!lhs.RumbleRightMotorStrength.EqualsWithin(rhs.RumbleRightMotorStrength)) return false;
            if (!lhs.RumbleDuration.EqualsWithin(rhs.RumbleDuration)) return false;
            if (!MemoryExtensions.SequenceEqual(lhs.Unknown3.Span, rhs.Unknown3.Span)) return false;
            if (lhs.Skill != rhs.Skill) return false;
            if (lhs.Unknown4 != rhs.Unknown4) return false;
            if (lhs.Resist != rhs.Resist) return false;
            if (lhs.Unknown5 != rhs.Unknown5) return false;
            if (!lhs.Stagger.EqualsWithin(rhs.Stagger)) return false;
            return true;
        }
        
        public virtual int GetHashCode(IWeaponDataGetter item)
        {
            var hash = new HashCode();
            hash.Add(item.AnimationType);
            hash.Add(item.Unused);
            hash.Add(item.Speed);
            hash.Add(item.Reach);
            hash.Add(item.Flags);
            hash.Add(item.Unused2);
            hash.Add(item.SightFOV);
            hash.Add(item.Unknown);
            hash.Add(item.BaseVATStoHitChance);
            hash.Add(item.AttackAnimation);
            hash.Add(item.NumProjectiles);
            hash.Add(item.EmbeddedWeaponAV);
            hash.Add(item.RangeMin);
            hash.Add(item.RangeMax);
            hash.Add(item.OnHit);
            hash.Add(item.AnimationAttackMult);
            hash.Add(item.Unknown2);
            hash.Add(item.RumbleLeftMotorStrength);
            hash.Add(item.RumbleRightMotorStrength);
            hash.Add(item.RumbleDuration);
            hash.Add(item.Unknown3);
            if (item.Skill.TryGet(out var Skillitem))
            {
                hash.Add(Skillitem);
            }
            hash.Add(item.Unknown4);
            hash.Add(item.Resist);
            hash.Add(item.Unknown5);
            hash.Add(item.Stagger);
            return hash.ToHashCode();
        }
        
        #endregion
        
        
        public object GetNew()
        {
            return WeaponData.GetNew();
        }
        
        #region Mutagen
        public IEnumerable<FormKey> GetLinkFormKeys(IWeaponDataGetter obj)
        {
            yield break;
        }
        
        public void RemapLinks(IWeaponDataGetter obj, IReadOnlyDictionary<FormKey, FormKey> mapping) => throw new NotImplementedException();
        #endregion
        
    }
    public partial class WeaponDataSetterTranslationCommon
    {
        public static readonly WeaponDataSetterTranslationCommon Instance = new WeaponDataSetterTranslationCommon();

        #region Deep Copy Fields From
        public void DeepCopyIn(
            IWeaponData item,
            IWeaponDataGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask)
        {
            if ((copyMask?.GetShouldTranslate((int)WeaponData_FieldIndex.AnimationType) ?? true))
            {
                item.AnimationType = rhs.AnimationType;
            }
            if ((copyMask?.GetShouldTranslate((int)WeaponData_FieldIndex.Unused) ?? true))
            {
                item.Unused = rhs.Unused.ToArray();
            }
            if ((copyMask?.GetShouldTranslate((int)WeaponData_FieldIndex.Speed) ?? true))
            {
                item.Speed = rhs.Speed;
            }
            if ((copyMask?.GetShouldTranslate((int)WeaponData_FieldIndex.Reach) ?? true))
            {
                item.Reach = rhs.Reach;
            }
            if ((copyMask?.GetShouldTranslate((int)WeaponData_FieldIndex.Flags) ?? true))
            {
                item.Flags = rhs.Flags;
            }
            if ((copyMask?.GetShouldTranslate((int)WeaponData_FieldIndex.Unused2) ?? true))
            {
                item.Unused2 = rhs.Unused2;
            }
            if ((copyMask?.GetShouldTranslate((int)WeaponData_FieldIndex.SightFOV) ?? true))
            {
                item.SightFOV = rhs.SightFOV;
            }
            if ((copyMask?.GetShouldTranslate((int)WeaponData_FieldIndex.Unknown) ?? true))
            {
                item.Unknown = rhs.Unknown;
            }
            if ((copyMask?.GetShouldTranslate((int)WeaponData_FieldIndex.BaseVATStoHitChance) ?? true))
            {
                item.BaseVATStoHitChance = rhs.BaseVATStoHitChance;
            }
            if ((copyMask?.GetShouldTranslate((int)WeaponData_FieldIndex.AttackAnimation) ?? true))
            {
                item.AttackAnimation = rhs.AttackAnimation;
            }
            if ((copyMask?.GetShouldTranslate((int)WeaponData_FieldIndex.NumProjectiles) ?? true))
            {
                item.NumProjectiles = rhs.NumProjectiles;
            }
            if ((copyMask?.GetShouldTranslate((int)WeaponData_FieldIndex.EmbeddedWeaponAV) ?? true))
            {
                item.EmbeddedWeaponAV = rhs.EmbeddedWeaponAV;
            }
            if ((copyMask?.GetShouldTranslate((int)WeaponData_FieldIndex.RangeMin) ?? true))
            {
                item.RangeMin = rhs.RangeMin;
            }
            if ((copyMask?.GetShouldTranslate((int)WeaponData_FieldIndex.RangeMax) ?? true))
            {
                item.RangeMax = rhs.RangeMax;
            }
            if ((copyMask?.GetShouldTranslate((int)WeaponData_FieldIndex.OnHit) ?? true))
            {
                item.OnHit = rhs.OnHit;
            }
            if ((copyMask?.GetShouldTranslate((int)WeaponData_FieldIndex.AnimationAttackMult) ?? true))
            {
                item.AnimationAttackMult = rhs.AnimationAttackMult;
            }
            if ((copyMask?.GetShouldTranslate((int)WeaponData_FieldIndex.Unknown2) ?? true))
            {
                item.Unknown2 = rhs.Unknown2;
            }
            if ((copyMask?.GetShouldTranslate((int)WeaponData_FieldIndex.RumbleLeftMotorStrength) ?? true))
            {
                item.RumbleLeftMotorStrength = rhs.RumbleLeftMotorStrength;
            }
            if ((copyMask?.GetShouldTranslate((int)WeaponData_FieldIndex.RumbleRightMotorStrength) ?? true))
            {
                item.RumbleRightMotorStrength = rhs.RumbleRightMotorStrength;
            }
            if ((copyMask?.GetShouldTranslate((int)WeaponData_FieldIndex.RumbleDuration) ?? true))
            {
                item.RumbleDuration = rhs.RumbleDuration;
            }
            if ((copyMask?.GetShouldTranslate((int)WeaponData_FieldIndex.Unknown3) ?? true))
            {
                item.Unknown3 = rhs.Unknown3.ToArray();
            }
            if ((copyMask?.GetShouldTranslate((int)WeaponData_FieldIndex.Skill) ?? true))
            {
                item.Skill = rhs.Skill;
            }
            if ((copyMask?.GetShouldTranslate((int)WeaponData_FieldIndex.Unknown4) ?? true))
            {
                item.Unknown4 = rhs.Unknown4;
            }
            if ((copyMask?.GetShouldTranslate((int)WeaponData_FieldIndex.Resist) ?? true))
            {
                item.Resist = rhs.Resist;
            }
            if ((copyMask?.GetShouldTranslate((int)WeaponData_FieldIndex.Unknown5) ?? true))
            {
                item.Unknown5 = rhs.Unknown5;
            }
            if ((copyMask?.GetShouldTranslate((int)WeaponData_FieldIndex.Stagger) ?? true))
            {
                item.Stagger = rhs.Stagger;
            }
        }
        
        #endregion
        
        public WeaponData DeepCopy(
            IWeaponDataGetter item,
            WeaponData.TranslationMask? copyMask = null)
        {
            WeaponData ret = (WeaponData)((WeaponDataCommon)((IWeaponDataGetter)item).CommonInstance()!).GetNew();
            ret.DeepCopyIn(
                item,
                copyMask: copyMask);
            return ret;
        }
        
        public WeaponData DeepCopy(
            IWeaponDataGetter item,
            out WeaponData.ErrorMask errorMask,
            WeaponData.TranslationMask? copyMask = null)
        {
            WeaponData ret = (WeaponData)((WeaponDataCommon)((IWeaponDataGetter)item).CommonInstance()!).GetNew();
            ret.DeepCopyIn(
                item,
                errorMask: out errorMask,
                copyMask: copyMask);
            return ret;
        }
        
        public WeaponData DeepCopy(
            IWeaponDataGetter item,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask = null)
        {
            WeaponData ret = (WeaponData)((WeaponDataCommon)((IWeaponDataGetter)item).CommonInstance()!).GetNew();
            ret.DeepCopyIn(
                item,
                errorMask: errorMask,
                copyMask: copyMask);
            return ret;
        }
        
    }
    #endregion

}

namespace Mutagen.Bethesda.Skyrim
{
    public partial class WeaponData
    {
        #region Common Routing
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILoquiRegistration ILoquiObject.Registration => WeaponData_Registration.Instance;
        public static WeaponData_Registration Registration => WeaponData_Registration.Instance;
        [DebuggerStepThrough]
        protected object CommonInstance() => WeaponDataCommon.Instance;
        [DebuggerStepThrough]
        protected object CommonSetterInstance()
        {
            return WeaponDataSetterCommon.Instance;
        }
        [DebuggerStepThrough]
        protected object CommonSetterTranslationInstance() => WeaponDataSetterTranslationCommon.Instance;
        [DebuggerStepThrough]
        object IWeaponDataGetter.CommonInstance() => this.CommonInstance();
        [DebuggerStepThrough]
        object IWeaponDataGetter.CommonSetterInstance() => this.CommonSetterInstance();
        [DebuggerStepThrough]
        object IWeaponDataGetter.CommonSetterTranslationInstance() => this.CommonSetterTranslationInstance();

        #endregion

    }
}

#region Modules
#region Xml Translation
namespace Mutagen.Bethesda.Skyrim.Internals
{
    public partial class WeaponDataXmlWriteTranslation : IXmlWriteTranslator
    {
        public readonly static WeaponDataXmlWriteTranslation Instance = new WeaponDataXmlWriteTranslation();

        public static void WriteToNodeXml(
            IWeaponDataGetter item,
            XElement node,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask)
        {
            if ((translationMask?.GetShouldTranslate((int)WeaponData_FieldIndex.AnimationType) ?? true))
            {
                EnumXmlTranslation<WeaponAnimationType>.Instance.Write(
                    node: node,
                    name: nameof(item.AnimationType),
                    item: item.AnimationType,
                    fieldIndex: (int)WeaponData_FieldIndex.AnimationType,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)WeaponData_FieldIndex.Unused) ?? true))
            {
                ByteArrayXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.Unused),
                    item: item.Unused,
                    fieldIndex: (int)WeaponData_FieldIndex.Unused,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)WeaponData_FieldIndex.Speed) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.Speed),
                    item: item.Speed,
                    fieldIndex: (int)WeaponData_FieldIndex.Speed,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)WeaponData_FieldIndex.Reach) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.Reach),
                    item: item.Reach,
                    fieldIndex: (int)WeaponData_FieldIndex.Reach,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)WeaponData_FieldIndex.Flags) ?? true))
            {
                EnumXmlTranslation<WeaponData.Flag>.Instance.Write(
                    node: node,
                    name: nameof(item.Flags),
                    item: item.Flags,
                    fieldIndex: (int)WeaponData_FieldIndex.Flags,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)WeaponData_FieldIndex.Unused2) ?? true))
            {
                Int16XmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.Unused2),
                    item: item.Unused2,
                    fieldIndex: (int)WeaponData_FieldIndex.Unused2,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)WeaponData_FieldIndex.SightFOV) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.SightFOV),
                    item: item.SightFOV,
                    fieldIndex: (int)WeaponData_FieldIndex.SightFOV,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)WeaponData_FieldIndex.Unknown) ?? true))
            {
                Int32XmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.Unknown),
                    item: item.Unknown,
                    fieldIndex: (int)WeaponData_FieldIndex.Unknown,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)WeaponData_FieldIndex.BaseVATStoHitChance) ?? true))
            {
                ByteXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.BaseVATStoHitChance),
                    item: item.BaseVATStoHitChance,
                    fieldIndex: (int)WeaponData_FieldIndex.BaseVATStoHitChance,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)WeaponData_FieldIndex.AttackAnimation) ?? true))
            {
                EnumXmlTranslation<WeaponData.AttackAnimationType>.Instance.Write(
                    node: node,
                    name: nameof(item.AttackAnimation),
                    item: item.AttackAnimation,
                    fieldIndex: (int)WeaponData_FieldIndex.AttackAnimation,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)WeaponData_FieldIndex.NumProjectiles) ?? true))
            {
                ByteXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.NumProjectiles),
                    item: item.NumProjectiles,
                    fieldIndex: (int)WeaponData_FieldIndex.NumProjectiles,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)WeaponData_FieldIndex.EmbeddedWeaponAV) ?? true))
            {
                ByteXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.EmbeddedWeaponAV),
                    item: item.EmbeddedWeaponAV,
                    fieldIndex: (int)WeaponData_FieldIndex.EmbeddedWeaponAV,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)WeaponData_FieldIndex.RangeMin) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.RangeMin),
                    item: item.RangeMin,
                    fieldIndex: (int)WeaponData_FieldIndex.RangeMin,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)WeaponData_FieldIndex.RangeMax) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.RangeMax),
                    item: item.RangeMax,
                    fieldIndex: (int)WeaponData_FieldIndex.RangeMax,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)WeaponData_FieldIndex.OnHit) ?? true))
            {
                EnumXmlTranslation<WeaponData.OnHitType>.Instance.Write(
                    node: node,
                    name: nameof(item.OnHit),
                    item: item.OnHit,
                    fieldIndex: (int)WeaponData_FieldIndex.OnHit,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)WeaponData_FieldIndex.AnimationAttackMult) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.AnimationAttackMult),
                    item: item.AnimationAttackMult,
                    fieldIndex: (int)WeaponData_FieldIndex.AnimationAttackMult,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)WeaponData_FieldIndex.Unknown2) ?? true))
            {
                Int32XmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.Unknown2),
                    item: item.Unknown2,
                    fieldIndex: (int)WeaponData_FieldIndex.Unknown2,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)WeaponData_FieldIndex.RumbleLeftMotorStrength) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.RumbleLeftMotorStrength),
                    item: item.RumbleLeftMotorStrength,
                    fieldIndex: (int)WeaponData_FieldIndex.RumbleLeftMotorStrength,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)WeaponData_FieldIndex.RumbleRightMotorStrength) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.RumbleRightMotorStrength),
                    item: item.RumbleRightMotorStrength,
                    fieldIndex: (int)WeaponData_FieldIndex.RumbleRightMotorStrength,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)WeaponData_FieldIndex.RumbleDuration) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.RumbleDuration),
                    item: item.RumbleDuration,
                    fieldIndex: (int)WeaponData_FieldIndex.RumbleDuration,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)WeaponData_FieldIndex.Unknown3) ?? true))
            {
                ByteArrayXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.Unknown3),
                    item: item.Unknown3,
                    fieldIndex: (int)WeaponData_FieldIndex.Unknown3,
                    errorMask: errorMask);
            }
            if ((item.Skill != null)
                && (translationMask?.GetShouldTranslate((int)WeaponData_FieldIndex.Skill) ?? true))
            {
                EnumXmlTranslation<Skill>.Instance.Write(
                    node: node,
                    name: nameof(item.Skill),
                    item: item.Skill,
                    fieldIndex: (int)WeaponData_FieldIndex.Skill,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)WeaponData_FieldIndex.Unknown4) ?? true))
            {
                Int64XmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.Unknown4),
                    item: item.Unknown4,
                    fieldIndex: (int)WeaponData_FieldIndex.Unknown4,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)WeaponData_FieldIndex.Resist) ?? true))
            {
                EnumXmlTranslation<ActorValueExtended>.Instance.Write(
                    node: node,
                    name: nameof(item.Resist),
                    item: item.Resist,
                    fieldIndex: (int)WeaponData_FieldIndex.Resist,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)WeaponData_FieldIndex.Unknown5) ?? true))
            {
                Int32XmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.Unknown5),
                    item: item.Unknown5,
                    fieldIndex: (int)WeaponData_FieldIndex.Unknown5,
                    errorMask: errorMask);
            }
            if ((translationMask?.GetShouldTranslate((int)WeaponData_FieldIndex.Stagger) ?? true))
            {
                FloatXmlTranslation.Instance.Write(
                    node: node,
                    name: nameof(item.Stagger),
                    item: item.Stagger,
                    fieldIndex: (int)WeaponData_FieldIndex.Stagger,
                    errorMask: errorMask);
            }
        }

        public void Write(
            XElement node,
            IWeaponDataGetter item,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask,
            string? name = null)
        {
            var elem = new XElement(name ?? "Mutagen.Bethesda.Skyrim.WeaponData");
            node.Add(elem);
            if (name != null)
            {
                elem.SetAttributeValue("type", "Mutagen.Bethesda.Skyrim.WeaponData");
            }
            WriteToNodeXml(
                item: item,
                node: elem,
                errorMask: errorMask,
                translationMask: translationMask);
        }

        public void Write(
            XElement node,
            object item,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask,
            string? name = null)
        {
            Write(
                item: (IWeaponDataGetter)item,
                name: name,
                node: node,
                errorMask: errorMask,
                translationMask: translationMask);
        }

        public void Write(
            XElement node,
            IWeaponDataGetter item,
            ErrorMaskBuilder? errorMask,
            int fieldIndex,
            TranslationCrystal? translationMask,
            string? name = null)
        {
            errorMask?.PushIndex(fieldIndex);
            try
            {
                Write(
                    item: (IWeaponDataGetter)item,
                    name: name,
                    node: node,
                    errorMask: errorMask,
                    translationMask: translationMask);
            }
            catch (Exception ex)
            when (errorMask != null)
            {
                errorMask.ReportException(ex);
            }
            finally
            {
                errorMask?.PopIndex();
            }
        }

    }

    public partial class WeaponDataXmlCreateTranslation
    {
        public readonly static WeaponDataXmlCreateTranslation Instance = new WeaponDataXmlCreateTranslation();

        public static void FillPublicXml(
            IWeaponData item,
            XElement node,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask)
        {
            try
            {
                foreach (var elem in node.Elements())
                {
                    WeaponDataXmlCreateTranslation.FillPublicElementXml(
                        item: item,
                        node: elem,
                        name: elem.Name.LocalName,
                        errorMask: errorMask,
                        translationMask: translationMask);
                }
            }
            catch (Exception ex)
            when (errorMask != null)
            {
                errorMask.ReportException(ex);
            }
        }

        public static void FillPublicElementXml(
            IWeaponData item,
            XElement node,
            string name,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask)
        {
            switch (name)
            {
                case "AnimationType":
                    errorMask?.PushIndex((int)WeaponData_FieldIndex.AnimationType);
                    try
                    {
                        item.AnimationType = EnumXmlTranslation<WeaponAnimationType>.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "Unused":
                    errorMask?.PushIndex((int)WeaponData_FieldIndex.Unused);
                    try
                    {
                        item.Unused = ByteArrayXmlTranslation.Instance.Parse(
                            node: node,
                            fallbackLength: 3,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "Speed":
                    errorMask?.PushIndex((int)WeaponData_FieldIndex.Speed);
                    try
                    {
                        item.Speed = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "Reach":
                    errorMask?.PushIndex((int)WeaponData_FieldIndex.Reach);
                    try
                    {
                        item.Reach = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "Flags":
                    errorMask?.PushIndex((int)WeaponData_FieldIndex.Flags);
                    try
                    {
                        item.Flags = EnumXmlTranslation<WeaponData.Flag>.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "Unused2":
                    errorMask?.PushIndex((int)WeaponData_FieldIndex.Unused2);
                    try
                    {
                        item.Unused2 = Int16XmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "SightFOV":
                    errorMask?.PushIndex((int)WeaponData_FieldIndex.SightFOV);
                    try
                    {
                        item.SightFOV = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "Unknown":
                    errorMask?.PushIndex((int)WeaponData_FieldIndex.Unknown);
                    try
                    {
                        item.Unknown = Int32XmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "BaseVATStoHitChance":
                    errorMask?.PushIndex((int)WeaponData_FieldIndex.BaseVATStoHitChance);
                    try
                    {
                        item.BaseVATStoHitChance = ByteXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "AttackAnimation":
                    errorMask?.PushIndex((int)WeaponData_FieldIndex.AttackAnimation);
                    try
                    {
                        item.AttackAnimation = EnumXmlTranslation<WeaponData.AttackAnimationType>.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "NumProjectiles":
                    errorMask?.PushIndex((int)WeaponData_FieldIndex.NumProjectiles);
                    try
                    {
                        item.NumProjectiles = ByteXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "EmbeddedWeaponAV":
                    errorMask?.PushIndex((int)WeaponData_FieldIndex.EmbeddedWeaponAV);
                    try
                    {
                        item.EmbeddedWeaponAV = ByteXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "RangeMin":
                    errorMask?.PushIndex((int)WeaponData_FieldIndex.RangeMin);
                    try
                    {
                        item.RangeMin = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "RangeMax":
                    errorMask?.PushIndex((int)WeaponData_FieldIndex.RangeMax);
                    try
                    {
                        item.RangeMax = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "OnHit":
                    errorMask?.PushIndex((int)WeaponData_FieldIndex.OnHit);
                    try
                    {
                        item.OnHit = EnumXmlTranslation<WeaponData.OnHitType>.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "AnimationAttackMult":
                    errorMask?.PushIndex((int)WeaponData_FieldIndex.AnimationAttackMult);
                    try
                    {
                        item.AnimationAttackMult = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "Unknown2":
                    errorMask?.PushIndex((int)WeaponData_FieldIndex.Unknown2);
                    try
                    {
                        item.Unknown2 = Int32XmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "RumbleLeftMotorStrength":
                    errorMask?.PushIndex((int)WeaponData_FieldIndex.RumbleLeftMotorStrength);
                    try
                    {
                        item.RumbleLeftMotorStrength = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "RumbleRightMotorStrength":
                    errorMask?.PushIndex((int)WeaponData_FieldIndex.RumbleRightMotorStrength);
                    try
                    {
                        item.RumbleRightMotorStrength = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "RumbleDuration":
                    errorMask?.PushIndex((int)WeaponData_FieldIndex.RumbleDuration);
                    try
                    {
                        item.RumbleDuration = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "Unknown3":
                    errorMask?.PushIndex((int)WeaponData_FieldIndex.Unknown3);
                    try
                    {
                        item.Unknown3 = ByteArrayXmlTranslation.Instance.Parse(
                            node: node,
                            fallbackLength: 12,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "Skill":
                    errorMask?.PushIndex((int)WeaponData_FieldIndex.Skill);
                    try
                    {
                        item.Skill = EnumXmlTranslation<Skill>.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "Unknown4":
                    errorMask?.PushIndex((int)WeaponData_FieldIndex.Unknown4);
                    try
                    {
                        item.Unknown4 = Int64XmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "Resist":
                    errorMask?.PushIndex((int)WeaponData_FieldIndex.Resist);
                    try
                    {
                        item.Resist = EnumXmlTranslation<ActorValueExtended>.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "Unknown5":
                    errorMask?.PushIndex((int)WeaponData_FieldIndex.Unknown5);
                    try
                    {
                        item.Unknown5 = Int32XmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                case "Stagger":
                    errorMask?.PushIndex((int)WeaponData_FieldIndex.Stagger);
                    try
                    {
                        item.Stagger = FloatXmlTranslation.Instance.Parse(
                            node: node,
                            errorMask: errorMask);
                    }
                    catch (Exception ex)
                    when (errorMask != null)
                    {
                        errorMask.ReportException(ex);
                    }
                    finally
                    {
                        errorMask?.PopIndex();
                    }
                    break;
                default:
                    break;
            }
        }

    }

}
namespace Mutagen.Bethesda.Skyrim
{
    #region Xml Write Mixins
    public static class WeaponDataXmlTranslationMixIn
    {
        public static void WriteToXml(
            this IWeaponDataGetter item,
            XElement node,
            out WeaponData.ErrorMask errorMask,
            WeaponData.TranslationMask? translationMask = null,
            string? name = null)
        {
            ErrorMaskBuilder errorMaskBuilder = new ErrorMaskBuilder();
            ((WeaponDataXmlWriteTranslation)item.XmlWriteTranslator).Write(
                item: item,
                name: name,
                node: node,
                errorMask: errorMaskBuilder,
                translationMask: translationMask?.GetCrystal());
            errorMask = WeaponData.ErrorMask.Factory(errorMaskBuilder);
        }

        public static void WriteToXml(
            this IWeaponDataGetter item,
            string path,
            out WeaponData.ErrorMask errorMask,
            WeaponData.TranslationMask? translationMask = null,
            string? name = null)
        {
            var node = new XElement("topnode");
            WriteToXml(
                item: item,
                name: name,
                node: node,
                errorMask: out errorMask,
                translationMask: translationMask);
            node.Elements().First().SaveIfChanged(path);
        }

        public static void WriteToXml(
            this IWeaponDataGetter item,
            string path,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask = null,
            string? name = null)
        {
            var node = new XElement("topnode");
            WriteToXml(
                item: item,
                name: name,
                node: node,
                errorMask: errorMask,
                translationMask: translationMask);
            node.Elements().First().SaveIfChanged(path);
        }

        public static void WriteToXml(
            this IWeaponDataGetter item,
            Stream stream,
            out WeaponData.ErrorMask errorMask,
            WeaponData.TranslationMask? translationMask = null,
            string? name = null)
        {
            var node = new XElement("topnode");
            WriteToXml(
                item: item,
                name: name,
                node: node,
                errorMask: out errorMask,
                translationMask: translationMask);
            node.Elements().First().Save(stream);
        }

        public static void WriteToXml(
            this IWeaponDataGetter item,
            Stream stream,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask = null,
            string? name = null)
        {
            var node = new XElement("topnode");
            WriteToXml(
                item: item,
                name: name,
                node: node,
                errorMask: errorMask,
                translationMask: translationMask);
            node.Elements().First().Save(stream);
        }

        public static void WriteToXml(
            this IWeaponDataGetter item,
            XElement node,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask = null,
            string? name = null)
        {
            ((WeaponDataXmlWriteTranslation)item.XmlWriteTranslator).Write(
                item: item,
                name: name,
                node: node,
                errorMask: errorMask,
                translationMask: translationMask);
        }

        public static void WriteToXml(
            this IWeaponDataGetter item,
            XElement node,
            string? name = null,
            WeaponData.TranslationMask? translationMask = null)
        {
            ((WeaponDataXmlWriteTranslation)item.XmlWriteTranslator).Write(
                item: item,
                name: name,
                node: node,
                errorMask: null,
                translationMask: translationMask?.GetCrystal());
        }

        public static void WriteToXml(
            this IWeaponDataGetter item,
            string path,
            string? name = null)
        {
            var node = new XElement("topnode");
            ((WeaponDataXmlWriteTranslation)item.XmlWriteTranslator).Write(
                item: item,
                name: name,
                node: node,
                errorMask: null,
                translationMask: null);
            node.Elements().First().SaveIfChanged(path);
        }

        public static void WriteToXml(
            this IWeaponDataGetter item,
            Stream stream,
            string? name = null)
        {
            var node = new XElement("topnode");
            ((WeaponDataXmlWriteTranslation)item.XmlWriteTranslator).Write(
                item: item,
                name: name,
                node: node,
                errorMask: null,
                translationMask: null);
            node.Elements().First().Save(stream);
        }

    }
    #endregion


}
#endregion

#region Binary Translation
namespace Mutagen.Bethesda.Skyrim.Internals
{
    public partial class WeaponDataBinaryWriteTranslation : IBinaryWriteTranslator
    {
        public readonly static WeaponDataBinaryWriteTranslation Instance = new WeaponDataBinaryWriteTranslation();

        static partial void WriteBinaryFlagsCustom(
            MutagenWriter writer,
            IWeaponDataGetter item);

        public static void WriteBinaryFlags(
            MutagenWriter writer,
            IWeaponDataGetter item)
        {
            WriteBinaryFlagsCustom(
                writer: writer,
                item: item);
        }

        static partial void WriteBinaryFlags2Custom(
            MutagenWriter writer,
            IWeaponDataGetter item);

        public static void WriteBinaryFlags2(
            MutagenWriter writer,
            IWeaponDataGetter item)
        {
            WriteBinaryFlags2Custom(
                writer: writer,
                item: item);
        }

        public static void WriteEmbedded(
            IWeaponDataGetter item,
            MutagenWriter writer)
        {
            Mutagen.Bethesda.Binary.EnumBinaryTranslation<WeaponAnimationType>.Instance.Write(
                writer,
                item.AnimationType,
                length: 1);
            Mutagen.Bethesda.Binary.ByteArrayBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.Unused);
            Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.Speed);
            Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.Reach);
            WeaponDataBinaryWriteTranslation.WriteBinaryFlags(
                writer: writer,
                item: item);
            writer.Write(item.Unused2);
            Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.SightFOV);
            writer.Write(item.Unknown);
            writer.Write(item.BaseVATStoHitChance);
            Mutagen.Bethesda.Binary.EnumBinaryTranslation<WeaponData.AttackAnimationType>.Instance.Write(
                writer,
                item.AttackAnimation,
                length: 1);
            writer.Write(item.NumProjectiles);
            writer.Write(item.EmbeddedWeaponAV);
            Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.RangeMin);
            Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.RangeMax);
            Mutagen.Bethesda.Binary.EnumBinaryTranslation<WeaponData.OnHitType>.Instance.Write(
                writer,
                item.OnHit,
                length: 4);
            WeaponDataBinaryWriteTranslation.WriteBinaryFlags2(
                writer: writer,
                item: item);
            Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.AnimationAttackMult);
            writer.Write(item.Unknown2);
            Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.RumbleLeftMotorStrength);
            Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.RumbleRightMotorStrength);
            Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.RumbleDuration);
            Mutagen.Bethesda.Binary.ByteArrayBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.Unknown3);
            Mutagen.Bethesda.Binary.EnumBinaryTranslation<Skill>.Instance.Write(
                writer,
                ((int?)item.Skill) ?? -1,
                length: 4);
            writer.Write(item.Unknown4);
            Mutagen.Bethesda.Binary.EnumBinaryTranslation<ActorValueExtended>.Instance.Write(
                writer,
                item.Resist,
                length: 4);
            writer.Write(item.Unknown5);
            Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.Stagger);
        }

        public void Write(
            MutagenWriter writer,
            IWeaponDataGetter item,
            RecordTypeConverter? recordTypeConverter = null)
        {
            using (HeaderExport.ExportHeader(
                writer: writer,
                record: recordTypeConverter.ConvertToCustom(WeaponData_Registration.DNAM_HEADER),
                type: Mutagen.Bethesda.Binary.ObjectType.Subrecord))
            {
                WriteEmbedded(
                    item: item,
                    writer: writer);
            }
        }

        public void Write(
            MutagenWriter writer,
            object item,
            RecordTypeConverter? recordTypeConverter = null)
        {
            Write(
                item: (IWeaponDataGetter)item,
                writer: writer,
                recordTypeConverter: recordTypeConverter);
        }

    }

    public partial class WeaponDataBinaryCreateTranslation
    {
        public readonly static WeaponDataBinaryCreateTranslation Instance = new WeaponDataBinaryCreateTranslation();

        static partial void FillBinaryFlagsCustom(
            MutagenFrame frame,
            IWeaponData item);

        public static void FillBinaryFlagsCustomPublic(
            MutagenFrame frame,
            IWeaponData item)
        {
            FillBinaryFlagsCustom(
                frame: frame,
                item: item);
        }

        static partial void FillBinaryFlags2Custom(
            MutagenFrame frame,
            IWeaponData item);

        public static void FillBinaryFlags2CustomPublic(
            MutagenFrame frame,
            IWeaponData item)
        {
            FillBinaryFlags2Custom(
                frame: frame,
                item: item);
        }

    }

}
namespace Mutagen.Bethesda.Skyrim
{
    #region Binary Write Mixins
    public static class WeaponDataBinaryTranslationMixIn
    {
        public static void WriteToBinary(
            this IWeaponDataGetter item,
            MutagenWriter writer)
        {
            ((WeaponDataBinaryWriteTranslation)item.BinaryWriteTranslator).Write(
                item: item,
                writer: writer,
                recordTypeConverter: null);
        }

    }
    #endregion


}
namespace Mutagen.Bethesda.Skyrim.Internals
{
    public partial class WeaponDataBinaryOverlay :
        BinaryOverlay,
        IWeaponDataGetter
    {
        #region Common Routing
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILoquiRegistration ILoquiObject.Registration => WeaponData_Registration.Instance;
        public static WeaponData_Registration Registration => WeaponData_Registration.Instance;
        [DebuggerStepThrough]
        protected object CommonInstance() => WeaponDataCommon.Instance;
        [DebuggerStepThrough]
        protected object CommonSetterTranslationInstance() => WeaponDataSetterTranslationCommon.Instance;
        [DebuggerStepThrough]
        object IWeaponDataGetter.CommonInstance() => this.CommonInstance();
        [DebuggerStepThrough]
        object? IWeaponDataGetter.CommonSetterInstance() => null;
        [DebuggerStepThrough]
        object IWeaponDataGetter.CommonSetterTranslationInstance() => this.CommonSetterTranslationInstance();

        #endregion

        void IPrintable.ToString(FileGeneration fg, string? name) => this.ToString(fg, name);
        IMask<bool> ILoquiObjectGetter.GetHasBeenSetIMask() => this.GetHasBeenSetMask();
        IMask<bool> IEqualsMask.GetEqualsIMask(object rhs, EqualsMaskHelper.Include include) => this.GetEqualsMask((IWeaponDataGetter)rhs, include);

        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected object XmlWriteTranslator => WeaponDataXmlWriteTranslation.Instance;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        object IXmlItem.XmlWriteTranslator => this.XmlWriteTranslator;
        void IXmlItem.WriteToXml(
            XElement node,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? translationMask,
            string? name = null)
        {
            ((WeaponDataXmlWriteTranslation)this.XmlWriteTranslator).Write(
                item: this,
                name: name,
                node: node,
                errorMask: errorMask,
                translationMask: translationMask);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected object BinaryWriteTranslator => WeaponDataBinaryWriteTranslation.Instance;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        object IBinaryItem.BinaryWriteTranslator => this.BinaryWriteTranslator;
        void IBinaryItem.WriteToBinary(
            MutagenWriter writer,
            RecordTypeConverter? recordTypeConverter = null)
        {
            ((WeaponDataBinaryWriteTranslation)this.BinaryWriteTranslator).Write(
                item: this,
                writer: writer,
                recordTypeConverter: recordTypeConverter);
        }

        public WeaponAnimationType AnimationType => (WeaponAnimationType)_data.Span.Slice(0x0, 0x1)[0];
        public ReadOnlyMemorySlice<Byte> Unused => _data.Span.Slice(0x1, 0x3).ToArray();
        public Single Speed => SpanExt.GetFloat(_data.Slice(0x4, 0x4));
        public Single Reach => SpanExt.GetFloat(_data.Slice(0x8, 0x4));
        public WeaponData.Flag Flags => GetFlagsCustom(location: 0xC);
        public Int16 Unused2 => BinaryPrimitives.ReadInt16LittleEndian(_data.Slice(0xE, 0x2));
        public Single SightFOV => SpanExt.GetFloat(_data.Slice(0x10, 0x4));
        public Int32 Unknown => BinaryPrimitives.ReadInt32LittleEndian(_data.Slice(0x14, 0x4));
        public Byte BaseVATStoHitChance => _data.Span[0x18];
        public WeaponData.AttackAnimationType AttackAnimation => (WeaponData.AttackAnimationType)_data.Span.Slice(0x19, 0x1)[0];
        public Byte NumProjectiles => _data.Span[0x1A];
        public Byte EmbeddedWeaponAV => _data.Span[0x1B];
        public Single RangeMin => SpanExt.GetFloat(_data.Slice(0x1C, 0x4));
        public Single RangeMax => SpanExt.GetFloat(_data.Slice(0x20, 0x4));
        public WeaponData.OnHitType OnHit => (WeaponData.OnHitType)BinaryPrimitives.ReadInt32LittleEndian(_data.Span.Slice(0x24, 0x4));
        #region Flags2
        partial void Flags2CustomParse(
            BinaryMemoryReadStream stream,
            int offset);
        #endregion
        public Single AnimationAttackMult => SpanExt.GetFloat(_data.Slice(0x2C, 0x4));
        public Int32 Unknown2 => BinaryPrimitives.ReadInt32LittleEndian(_data.Slice(0x30, 0x4));
        public Single RumbleLeftMotorStrength => SpanExt.GetFloat(_data.Slice(0x34, 0x4));
        public Single RumbleRightMotorStrength => SpanExt.GetFloat(_data.Slice(0x38, 0x4));
        public Single RumbleDuration => SpanExt.GetFloat(_data.Slice(0x3C, 0x4));
        public ReadOnlyMemorySlice<Byte> Unknown3 => _data.Span.Slice(0x40, 0xC).ToArray();
        #region Skill
        public Skill? Skill
        {
            get
            {
                var val = (Skill)BinaryPrimitives.ReadInt32LittleEndian(_data.Span.Slice(0x4C, 0x4));
                if (((int)val) == -1) return null;
                return val;
            }
        }
        #endregion
        public Int64 Unknown4 => BinaryPrimitives.ReadInt64LittleEndian(_data.Slice(0x50, 0x8));
        public ActorValueExtended Resist => (ActorValueExtended)BinaryPrimitives.ReadInt32LittleEndian(_data.Span.Slice(0x58, 0x4));
        public Int32 Unknown5 => BinaryPrimitives.ReadInt32LittleEndian(_data.Slice(0x5C, 0x4));
        public Single Stagger => SpanExt.GetFloat(_data.Slice(0x60, 0x4));
        partial void CustomCtor(
            IBinaryReadStream stream,
            int finalPos,
            int offset);

        protected WeaponDataBinaryOverlay(
            ReadOnlyMemorySlice<byte> bytes,
            BinaryOverlayFactoryPackage package)
            : base(
                bytes: bytes,
                package: package)
        {
        }

        public static WeaponDataBinaryOverlay WeaponDataFactory(
            BinaryMemoryReadStream stream,
            BinaryOverlayFactoryPackage package,
            RecordTypeConverter? recordTypeConverter = null)
        {
            var ret = new WeaponDataBinaryOverlay(
                bytes: HeaderTranslation.ExtractSubrecordMemory(stream.RemainingMemory, package.Meta),
                package: package);
            var finalPos = checked((int)(stream.Position + package.Meta.Subrecord(stream.RemainingSpan).TotalLength));
            int offset = stream.Position + package.Meta.SubConstants.TypeAndLengthLength;
            stream.Position += 0x64 + package.Meta.SubConstants.HeaderLength;
            ret.CustomCtor(
                stream: stream,
                finalPos: stream.Length,
                offset: offset);
            return ret;
        }

        public static WeaponDataBinaryOverlay WeaponDataFactory(
            ReadOnlyMemorySlice<byte> slice,
            BinaryOverlayFactoryPackage package,
            RecordTypeConverter? recordTypeConverter = null)
        {
            return WeaponDataFactory(
                stream: new BinaryMemoryReadStream(slice),
                package: package,
                recordTypeConverter: recordTypeConverter);
        }

        #region To String

        public void ToString(
            FileGeneration fg,
            string? name = null)
        {
            WeaponDataMixIn.ToString(
                item: this,
                name: name);
        }

        #endregion

    }

}
#endregion

#endregion

